[
    {
        "task_id": 0,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovss  %xmm0,-0x20(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    88 <func0+0x88>\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    7c <func0+0x7c>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nsubss  %xmm1,%xmm0\nmovss  0x0(%rip),%xmm1\n00\nandps  %xmm0,%xmm1\nmovss  -0x20(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njbe    78 <func0+0x78>\nmov    $0x1,%eax\njmp    95 <func0+0x95>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     28 <func0+0x28>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1d <func0+0x1d>\nmov    $0x0,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 1,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%r13\nmov    %rsi,%r14\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%rbp\nmov    $0x50,%edi\ncallq  37 <func0+0x37>\nmov    %rax,%r15\nlea    0x1(%rbp),%edi\nmovslq %edi,%rdi\ncallq  45 <func0+0x45>\nmov    %rax,%r12\nmovl   $0x0,(%r14)\ntest   %ebp,%ebp\njle    fc <func0+0xfc>\nmov    %r13,%rbx\nlea    -0x1(%rbp),%eax\nlea    0x1(%r13,%rax,1),%r13\nmov    $0x0,%edx\nmovl   $0xa,0x4(%rsp)\n00\nmov    $0x0,%ebp\njmp    8d <func0+0x8d>\nadd    $0x1,%ebp\nmovslq %edx,%rax\nmovb   $0x28,(%r12,%rax,1)\nlea    0x1(%rdx),%edx\nadd    $0x1,%rbx\ncmp    %r13,%rbx\nje     fc <func0+0xfc>\nmovzbl (%rbx),%eax\ncmp    $0x28,%al\nje     76 <func0+0x76>\ncmp    $0x29,%al\njne    84 <func0+0x84>\nlea    0x1(%rdx),%eax\nmovslq %edx,%rdx\nmovb   $0x29,(%r12,%rdx,1)\nmov    %eax,%edx\nsub    $0x1,%ebp\njne    84 <func0+0x84>\ncltq\nmovb   $0x0,(%r12,%rax,1)\nmovslq (%r14),%rax\nlea    (%r15,%rax,8),%rax\nmov    %rax,0x8(%rsp)\nmov    %r12,%rdi\ncallq  c5 <func0+0xc5>\nmov    0x8(%rsp),%rsi\nmov    %rax,(%rsi)\nmov    (%r14),%eax\nadd    $0x1,%eax\nmov    %eax,(%r14)\nmov    %ebp,%edx\ncmp    0x4(%rsp),%eax\njl     84 <func0+0x84>\nshll   0x4(%rsp)\nmov    0x4(%rsp),%eax\nmovslq %eax,%rsi\nshl    $0x3,%rsi\nmov    %r15,%rdi\ncallq  f5 <func0+0xf5>\nmov    %rax,%r15\nmov    %ebp,%edx\njmp    84 <func0+0x84>\nmov    %r12,%rdi\ncallq  104 <func0+0x104>\nmov    %r15,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 2,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncvttss2si %xmm0,%eax\npxor   %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\nsubss  %xmm1,%xmm0\nretq"
    },
    {
        "task_id": 4,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    5c <func0+0x5c>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%edx\nlea    0x4(%rdi,%rdx,4),%rdx\npxor   %xmm0,%xmm0\naddss  (%rdi),%xmm0\nadd    $0x4,%rdi\ncmp    %rdx,%rdi\njne    17 <func0+0x17>\npxor   %xmm4,%xmm4\ncvtsi2ss %esi,%xmm4\ndivss  %xmm4,%xmm0\npxor   %xmm2,%xmm2\nmovss  0x0(%rip),%xmm3\n00\nmovss  (%rax),%xmm1\nsubss  %xmm0,%xmm1\nandps  %xmm3,%xmm1\naddss  %xmm1,%xmm2\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    3c <func0+0x3c>\ndivss  %xmm4,%xmm2\nmovaps %xmm2,%xmm0\nretq\npxor   %xmm4,%xmm4\ncvtsi2ss %esi,%xmm4\npxor   %xmm2,%xmm2\njmp    54 <func0+0x54>"
    },
    {
        "task_id": 6,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovq   $0x0,-0x8(%rbp)\n00\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmpq   ce <func0+0xce>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x19(%rbp)\ncmpb   $0x28,-0x19(%rbp)\njne    71 <func0+0x71>\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njle    ca <func0+0xca>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x14(%rbp)\njmp    ca <func0+0xca>\ncmpb   $0x29,-0x19(%rbp)\njne    ca <func0+0xca>\nsubl   $0x1,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njne    ca <func0+0xca>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  a0 <func0+0xa0>\nmov    %rax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\nmovl   $0x0,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    44 <func0+0x44>\nmov    -0x30(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 6,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rsi,%r13\nmovzbl (%rdi),%edx\ntest   %dl,%dl\nje     7d <func0+0x7d>\nlea    0x1(%rdi),%rbx\nmov    $0x0,%r14d\nmov    $0x0,%r12d\nmov    $0x0,%ebp\nmov    $0x0,%eax\njmp    4e <func0+0x4e>\nadd    $0x1,%ebp\ncmp    %ebp,%r12d\ncmovl  %ebp,%r12d\nadd    $0x1,%rbx\nmovzbl -0x1(%rbx),%edx\ntest   %dl,%dl\nje     88 <func0+0x88>\ncmp    $0x28,%dl\nje     38 <func0+0x38>\ncmp    $0x29,%dl\njne    42 <func0+0x42>\nsub    $0x1,%ebp\njne    42 <func0+0x42>\nadd    $0x1,%r14d\nmovslq %r14d,%r15\nshl    $0x2,%r15\nmov    %r15,%rsi\nmov    %rax,%rdi\ncallq  73 <func0+0x73>\nmov    %r12d,-0x4(%rax,%r15,1)\nmov    %ebp,%r12d\njmp    42 <func0+0x42>\nmov    $0x0,%r14d\nmov    $0x0,%eax\nmov    %r14d,0x0(%r13)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 6,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%edx\ntest   %dl,%dl\nje     98 <func0+0x98>\nlea    0x1(%rdi),%rbx\nxor    %r14d,%r14d\nxor    %r12d,%r12d\nxor    %ebp,%ebp\nxor    %eax,%eax\njmp    40 <func0+0x40>\nnopl   0x0(%rax)\ncmp    $0x29,%dl\nje     70 <func0+0x70>\nmovzbl (%rbx),%edx\nadd    $0x1,%rbx\ntest   %dl,%dl\nje     5a <func0+0x5a>\ncmp    $0x28,%dl\njne    30 <func0+0x30>\nadd    $0x1,%ebp\ncmp    %ebp,%r12d\ncmovl  %ebp,%r12d\nmovzbl (%rbx),%edx\nadd    $0x1,%rbx\ntest   %dl,%dl\njne    40 <func0+0x40>\nmov    %r14d,0x0(%r13)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   (%rax)\nsub    $0x1,%ebp\njne    35 <func0+0x35>\nadd    $0x1,%r14d\nmov    %rax,%rdi\nmovslq %r14d,%r15\nshl    $0x2,%r15\nmov    %r15,%rsi\ncallq  8b <func0+0x8b>\nmov    %r12d,-0x4(%rax,%r15,1)\nxor    %r12d,%r12d\njmp    35 <func0+0x35>\nnopl   (%rax)\nxor    %r14d,%r14d\nxor    %eax,%eax\njmp    5a <func0+0x5a>"
    },
    {
        "task_id": 6,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%edx\ntest   %dl,%dl\nje     98 <func0+0x98>\nlea    0x1(%rdi),%rbx\nxor    %r14d,%r14d\nxor    %r12d,%r12d\nxor    %ebp,%ebp\nxor    %eax,%eax\njmp    40 <func0+0x40>\nnopl   0x0(%rax)\ncmp    $0x29,%dl\nje     70 <func0+0x70>\nmovzbl (%rbx),%edx\nadd    $0x1,%rbx\ntest   %dl,%dl\nje     5a <func0+0x5a>\ncmp    $0x28,%dl\njne    30 <func0+0x30>\nadd    $0x1,%ebp\ncmp    %ebp,%r12d\ncmovl  %ebp,%r12d\nmovzbl (%rbx),%edx\nadd    $0x1,%rbx\ntest   %dl,%dl\njne    40 <func0+0x40>\nmov    %r14d,0x0(%r13)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   (%rax)\nsub    $0x1,%ebp\njne    35 <func0+0x35>\nadd    $0x1,%r14d\nmov    %rax,%rdi\nmovslq %r14d,%r15\nshl    $0x2,%r15\nmov    %r15,%rsi\ncallq  8b <func0+0x8b>\nmov    %r12d,-0x4(%rax,%r15,1)\nxor    %r12d,%r12d\njmp    35 <func0+0x35>\nnopl   (%rax)\nxor    %r14d,%r14d\nxor    %eax,%eax\njmp    5a <func0+0x5a>"
    }
]