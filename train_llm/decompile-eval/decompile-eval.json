[
    {
        "task_id": 0,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovss  %xmm0,-0x20(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    88 <func0+0x88>\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    7c <func0+0x7c>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nsubss  %xmm1,%xmm0\nmovss  0x0(%rip),%xmm1\n00\nandps  %xmm0,%xmm1\nmovss  -0x20(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njbe    78 <func0+0x78>\nmov    $0x1,%eax\njmp    95 <func0+0x95>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     28 <func0+0x28>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1d <func0+0x1d>\nmov    $0x0,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 0,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    48 <func0+0x48>\nlea    -0x1(%rsi),%ecx\nadd    $0x1,%rcx\nmov    $0x1,%edx\nmovss  0x0(%rip),%xmm3\n00\ncmp    %rcx,%rdx\nje     4e <func0+0x4e>\nmovss  -0x4(%rdi,%rdx,4),%xmm2\nmov    %rdx,%rax\nmovaps %xmm2,%xmm1\nsubss  (%rdi,%rax,4),%xmm1\nandps  %xmm3,%xmm1\ncomiss %xmm1,%xmm0\nja     54 <func0+0x54>\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     2a <func0+0x2a>\nadd    $0x1,%rdx\njmp    1c <func0+0x1c>\nmov    $0x0,%eax\nretq\nmov    $0x0,%eax\nretq\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 0,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    59 <func0+0x59>\nlea    -0x1(%rsi),%ecx\nmov    $0x1,%edx\nmovss  0x0(%rip),%xmm3\n00\nadd    $0x1,%rcx\ncmp    %rcx,%rdx\nje     59 <func0+0x59>\nmovss  -0x4(%rdi,%rdx,4),%xmm2\nmov    %rdx,%rax\njmp    38 <func0+0x38>\nnopl   0x0(%rax)\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    50 <func0+0x50>\nmovaps %xmm2,%xmm1\nsubss  (%rdi,%rax,4),%xmm1\nandps  %xmm3,%xmm1\ncomiss %xmm1,%xmm0\njbe    30 <func0+0x30>\nmov    $0x1,%eax\nretq\nxchg   %ax,%ax\nadd    $0x1,%rdx\ncmp    %rcx,%rdx\njne    21 <func0+0x21>\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 0,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    59 <func0+0x59>\nlea    -0x1(%rsi),%ecx\nmov    $0x1,%edx\nmovss  0x0(%rip),%xmm3\n00\nadd    $0x1,%rcx\ncmp    %rdx,%rcx\nje     59 <func0+0x59>\nmovss  -0x4(%rdi,%rdx,4),%xmm2\nmov    %rdx,%rax\njmp    38 <func0+0x38>\nnopl   0x0(%rax)\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    50 <func0+0x50>\nmovaps %xmm2,%xmm1\nsubss  (%rdi,%rax,4),%xmm1\nandps  %xmm3,%xmm1\ncomiss %xmm1,%xmm0\njbe    30 <func0+0x30>\nmov    $0x1,%eax\nretq\nxchg   %ax,%ax\nadd    $0x1,%rdx\ncmp    %rdx,%rcx\njne    21 <func0+0x21>\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 1,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncallq  21 <func0+0x21>\nmov    %eax,-0x24(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmovl   $0xa,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncallq  43 <func0+0x43>\nmov    %rax,-0x20(%rbp)\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncallq  57 <func0+0x57>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x50(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x28(%rbp)\njmpq   15f <func0+0x15f>\nmov    -0x28(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x35(%rbp)\ncmpb   $0x28,-0x35(%rbp)\njne    b3 <func0+0xb3>\naddl   $0x1,-0x34(%rbp)\nmov    -0x2c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x2c(%rbp)\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x35(%rbp),%eax\nmov    %al,(%rdx)\njmpq   15b <func0+0x15b>\ncmpb   $0x29,-0x35(%rbp)\njne    15b <func0+0x15b>\nsubl   $0x1,-0x34(%rbp)\nmov    -0x2c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x2c(%rbp)\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x35(%rbp),%eax\nmov    %al,(%rdx)\ncmpl   $0x0,-0x34(%rbp)\njne    15b <func0+0x15b>\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x50(%rbp),%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  114 <func0+0x114>\nmov    %rax,(%rbx)\nmov    -0x50(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x50(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x50(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x30(%rbp)\njg     154 <func0+0x154>\nshll   -0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  150 <func0+0x150>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x2c(%rbp)\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     78 <func0+0x78>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  177 <func0+0x177>\nmov    -0x20(%rbp),%rax\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 1,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%r13\nmov    %rsi,%r14\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%rbp\nmov    $0x50,%edi\ncallq  37 <func0+0x37>\nmov    %rax,%r15\nlea    0x1(%rbp),%edi\nmovslq %edi,%rdi\ncallq  45 <func0+0x45>\nmov    %rax,%r12\nmovl   $0x0,(%r14)\ntest   %ebp,%ebp\njle    fc <func0+0xfc>\nmov    %r13,%rbx\nlea    -0x1(%rbp),%eax\nlea    0x1(%r13,%rax,1),%r13\nmov    $0x0,%edx\nmovl   $0xa,0x4(%rsp)\n00\nmov    $0x0,%ebp\njmp    8d <func0+0x8d>\nadd    $0x1,%ebp\nmovslq %edx,%rax\nmovb   $0x28,(%r12,%rax,1)\nlea    0x1(%rdx),%edx\nadd    $0x1,%rbx\ncmp    %r13,%rbx\nje     fc <func0+0xfc>\nmovzbl (%rbx),%eax\ncmp    $0x28,%al\nje     76 <func0+0x76>\ncmp    $0x29,%al\njne    84 <func0+0x84>\nlea    0x1(%rdx),%eax\nmovslq %edx,%rdx\nmovb   $0x29,(%r12,%rdx,1)\nmov    %eax,%edx\nsub    $0x1,%ebp\njne    84 <func0+0x84>\ncltq\nmovb   $0x0,(%r12,%rax,1)\nmovslq (%r14),%rax\nlea    (%r15,%rax,8),%rax\nmov    %rax,0x8(%rsp)\nmov    %r12,%rdi\ncallq  c5 <func0+0xc5>\nmov    0x8(%rsp),%rsi\nmov    %rax,(%rsi)\nmov    (%r14),%eax\nadd    $0x1,%eax\nmov    %eax,(%r14)\nmov    %ebp,%edx\ncmp    0x4(%rsp),%eax\njl     84 <func0+0x84>\nshll   0x4(%rsp)\nmov    0x4(%rsp),%eax\nmovslq %eax,%rsi\nshl    $0x3,%rsi\nmov    %r15,%rdi\ncallq  f5 <func0+0xf5>\nmov    %rax,%r15\nmov    %ebp,%edx\njmp    84 <func0+0x84>\nmov    %r12,%rdi\ncallq  104 <func0+0x104>\nmov    %r15,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 1,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rsi,%r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x18,%rsp\ncallq  1d <func0+0x1d>\nmov    $0x50,%edi\nmov    %rax,%rbp\ncallq  2a <func0+0x2a>\nlea    0x1(%rbp),%edi\nmovslq %edi,%rdi\nmov    %rax,%r12\ncallq  38 <func0+0x38>\nmovl   $0x0,(%r15)\nmov    %rax,%r14\ntest   %ebp,%ebp\njle    8b <func0+0x8b>\nlea    -0x1(%rbp),%eax\nxor    %edx,%edx\nmov    $0xa,%ecx\nxor    %ebp,%ebp\nlea    0x1(%rbx,%rax,1),%r13\njmp    6d <func0+0x6d>\nnopl   0x0(%rax)\ncmp    $0x29,%al\nje     a8 <func0+0xa8>\nadd    $0x1,%rbx\ncmp    %r13,%rbx\nje     8b <func0+0x8b>\nmovzbl (%rbx),%eax\ncmp    $0x28,%al\njne    60 <func0+0x60>\nmovslq %edx,%rax\nadd    $0x1,%rbx\nadd    $0x1,%ebp\nadd    $0x1,%edx\nmovb   $0x28,(%r14,%rax,1)\ncmp    %r13,%rbx\njne    6d <func0+0x6d>\nmov    %r14,%rdi\ncallq  93 <func0+0x93>\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   (%rax)\nmovslq %edx,%rax\nadd    $0x1,%edx\nmovb   $0x29,(%r14,%rax,1)\nsub    $0x1,%ebp\njne    64 <func0+0x64>\nmovslq (%r15),%rax\nmovslq %edx,%rdx\nmov    %r14,%rdi\nmov    %ecx,0xc(%rsp)\nmovb   $0x0,(%r14,%rdx,1)\nlea    (%r12,%rax,8),%rdx\nmov    %rdx,(%rsp)\ncallq  d7 <func0+0xd7>\nmov    (%rsp),%rdx\nmov    0xc(%rsp),%ecx\nmov    %rax,(%rdx)\nmov    (%r15),%eax\nxor    %edx,%edx\nadd    $0x1,%eax\nmov    %eax,(%r15)\ncmp    %ecx,%eax\njl     64 <func0+0x64>\nadd    %ecx,%ecx\nmov    %r12,%rdi\nmovslq %ecx,%rsi\nmov    %ecx,(%rsp)\nshl    $0x3,%rsi\ncallq  109 <func0+0x109>\nmov    (%rsp),%ecx\nmov    %ebp,%edx\nmov    %rax,%r12\njmpq   64 <func0+0x64>"
    },
    {
        "task_id": 1,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rsi,%r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x18,%rsp\ncallq  1d <func0+0x1d>\nmov    $0x50,%edi\nmov    %rax,%rbp\ncallq  2a <func0+0x2a>\nlea    0x1(%rbp),%edi\nmovslq %edi,%rdi\nmov    %rax,%r12\ncallq  38 <func0+0x38>\nmovl   $0x0,(%r15)\nmov    %rax,%r14\ntest   %ebp,%ebp\njle    8b <func0+0x8b>\nlea    -0x1(%rbp),%eax\nxor    %edx,%edx\nmov    $0xa,%ecx\nxor    %ebp,%ebp\nlea    0x1(%rbx,%rax,1),%r13\njmp    6d <func0+0x6d>\nnopl   0x0(%rax)\ncmp    $0x29,%al\nje     a8 <func0+0xa8>\nadd    $0x1,%rbx\ncmp    %rbx,%r13\nje     8b <func0+0x8b>\nmovzbl (%rbx),%eax\ncmp    $0x28,%al\njne    60 <func0+0x60>\nmovslq %edx,%rax\nadd    $0x1,%rbx\nadd    $0x1,%ebp\nadd    $0x1,%edx\nmovb   $0x28,(%r14,%rax,1)\ncmp    %rbx,%r13\njne    6d <func0+0x6d>\nmov    %r14,%rdi\ncallq  93 <func0+0x93>\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   (%rax)\nmovslq %edx,%rax\nadd    $0x1,%edx\nmovb   $0x29,(%r14,%rax,1)\nsub    $0x1,%ebp\njne    64 <func0+0x64>\nmovslq (%r15),%rax\nmovslq %edx,%rdx\nmov    %r14,%rdi\nmov    %ecx,0xc(%rsp)\nmovb   $0x0,(%r14,%rdx,1)\nlea    (%r12,%rax,8),%rdx\nmov    %rdx,(%rsp)\ncallq  d7 <func0+0xd7>\nmov    (%rsp),%rdx\nmov    0xc(%rsp),%ecx\nmov    %rax,(%rdx)\nmov    (%r15),%eax\nxor    %edx,%edx\nadd    $0x1,%eax\nmov    %eax,(%r15)\ncmp    %ecx,%eax\njl     64 <func0+0x64>\nadd    %ecx,%ecx\nmov    %r12,%rdi\nmovslq %ecx,%rsi\nmov    %ecx,(%rsp)\nshl    $0x3,%rsi\ncallq  109 <func0+0x109>\nmov    (%rsp),%ecx\nmov    %ebp,%edx\nmov    %rax,%r12\njmpq   64 <func0+0x64>"
    },
    {
        "task_id": 2,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm0\ncvttss2si %xmm0,%eax\ncvtsi2ss %eax,%xmm1\nmovss  -0x4(%rbp),%xmm0\nsubss  %xmm1,%xmm0\npop    %rbp\nretq"
    },
    {
        "task_id": 2,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncvttss2si %xmm0,%eax\npxor   %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\nsubss  %xmm1,%xmm0\nretq"
    },
    {
        "task_id": 2,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncvttss2si %xmm0,%eax\npxor   %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\nsubss  %xmm1,%xmm0\nretq"
    },
    {
        "task_id": 2,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncvttss2si %xmm0,%eax\npxor   %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\nsubss  %xmm1,%xmm0\nretq"
    },
    {
        "task_id": 3,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    49 <func0+0x49>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njns    45 <func0+0x45>\nmov    $0x1,%eax\njmp    56 <func0+0x56>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1f <func0+0x1f>\nmov    $0x0,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 3,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    38 <func0+0x38>\nmov    (%rdi),%edx\ntest   %edx,%edx\njs     3e <func0+0x3e>\nadd    $0x4,%rdi\nlea    -0x1(%rsi),%eax\nlea    (%rdi,%rax,4),%rcx\ncmp    %rcx,%rdi\nje     32 <func0+0x32>\nmov    %edx,%eax\nadd    (%rdi),%eax\nmov    %eax,%edx\nadd    $0x4,%rdi\ntest   %eax,%eax\njns    19 <func0+0x19>\nmov    $0x1,%eax\nretq\nmov    $0x0,%eax\nretq\nmov    $0x0,%eax\nretq\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 3,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    2f <func0+0x2f>\nmov    (%rdi),%eax\ntest   %eax,%eax\njs     38 <func0+0x38>\nadd    $0x4,%rdi\nlea    -0x1(%rsi),%edx\nlea    (%rdi,%rdx,4),%rdx\njmp    2a <func0+0x2a>\nnopl   0x0(%rax,%rax,1)\nadd    (%rdi),%eax\nadd    $0x4,%rdi\ntest   %eax,%eax\njs     38 <func0+0x38>\ncmp    %rdx,%rdi\njne    20 <func0+0x20>\nxor    %eax,%eax\nretq\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 3,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    2f <func0+0x2f>\nmov    (%rdi),%eax\ntest   %eax,%eax\njs     38 <func0+0x38>\nadd    $0x4,%rdi\nlea    -0x1(%rsi),%edx\nlea    (%rdi,%rdx,4),%rdx\njmp    2a <func0+0x2a>\nnopl   0x0(%rax,%rax,1)\nadd    (%rdi),%eax\nadd    $0x4,%rdi\ntest   %eax,%eax\njs     38 <func0+0x38>\ncmp    %rdx,%rdi\njne    20 <func0+0x20>\nxor    %eax,%eax\nretq\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 4,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\npxor   %xmm0,%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    52 <func0+0x52>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  -0x10(%rbp),%xmm1\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0x10(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     28 <func0+0x28>\ncvtsi2ssl -0x1c(%rbp),%xmm1\nmovss  -0x10(%rbp),%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\npxor   %xmm0,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    b9 <func0+0xb9>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nsubss  -0x4(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1\n00\nandps  %xmm1,%xmm0\nmovss  -0xc(%rbp),%xmm1\naddss  %xmm1,%xmm0\nmovss  %xmm0,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     7f <func0+0x7f>\ncvtsi2ssl -0x1c(%rbp),%xmm1\nmovss  -0xc(%rbp),%xmm0\ndivss  %xmm1,%xmm0\npop    %rbp\nretq"
    },
    {
        "task_id": 4,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    5c <func0+0x5c>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%edx\nlea    0x4(%rdi,%rdx,4),%rdx\npxor   %xmm0,%xmm0\naddss  (%rdi),%xmm0\nadd    $0x4,%rdi\ncmp    %rdx,%rdi\njne    17 <func0+0x17>\npxor   %xmm4,%xmm4\ncvtsi2ss %esi,%xmm4\ndivss  %xmm4,%xmm0\npxor   %xmm2,%xmm2\nmovss  0x0(%rip),%xmm3\n00\nmovss  (%rax),%xmm1\nsubss  %xmm0,%xmm1\nandps  %xmm3,%xmm1\naddss  %xmm1,%xmm2\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    3c <func0+0x3c>\ndivss  %xmm4,%xmm2\nmovaps %xmm2,%xmm0\nretq\npxor   %xmm4,%xmm4\ncvtsi2ss %esi,%xmm4\npxor   %xmm2,%xmm2\njmp    54 <func0+0x54>"
    },
    {
        "task_id": 4,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npxor   %xmm4,%xmm4\ncvtsi2ss %esi,%xmm4\ntest   %esi,%esi\njle    60 <func0+0x60>\nlea    -0x1(%rsi),%eax\npxor   %xmm0,%xmm0\nlea    0x4(%rdi,%rax,4),%rdx\nmov    %rdi,%rax\nnop\naddss  (%rax),%xmm0\nadd    $0x4,%rax\ncmp    %rax,%rdx\njne    20 <func0+0x20>\ndivss  %xmm4,%xmm0\npxor   %xmm2,%xmm2\nmovss  0x0(%rip),%xmm3\n00\nnopl   (%rax)\nmovss  (%rdi),%xmm1\nadd    $0x4,%rdi\nsubss  %xmm0,%xmm1\nandps  %xmm3,%xmm1\naddss  %xmm1,%xmm2\ncmp    %rdi,%rdx\njne    40 <func0+0x40>\ndivss  %xmm4,%xmm2\nmovaps %xmm2,%xmm0\nretq\npxor   %xmm2,%xmm2\ndivss  %xmm4,%xmm2\nmovaps %xmm2,%xmm0\nretq"
    },
    {
        "task_id": 4,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npxor   %xmm5,%xmm5\ncvtsi2ss %esi,%xmm5\ntest   %esi,%esi\njle    178 <func0+0x178>\nlea    -0x1(%rsi),%ecx\ncmp    $0x2,%ecx\njbe    185 <func0+0x185>\nmov    %esi,%edx\npxor   %xmm0,%xmm0\nmov    %rdi,%rax\nshr    $0x2,%edx\nmovaps %xmm0,%xmm3\nshl    $0x4,%rdx\nadd    %rdi,%rdx\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmovups (%rax),%xmm2\nadd    $0x10,%rax\naddss  %xmm2,%xmm3\nmovaps %xmm2,%xmm1\nshufps $0x55,%xmm2,%xmm1\naddss  %xmm1,%xmm3\nmovaps %xmm2,%xmm1\nunpckhps %xmm2,%xmm1\nshufps $0xff,%xmm2,%xmm2\naddss  %xmm1,%xmm3\naddss  %xmm2,%xmm3\ncmp    %rdx,%rax\njne    40 <func0+0x40>\nmov    %esi,%eax\nand    $0xfffffffc,%eax\ncmp    %eax,%esi\nje     168 <func0+0x168>\nmovslq %eax,%rdx\naddss  (%rdi,%rdx,4),%xmm3\nlea    0x1(%rax),%edx\nmovaps %xmm3,%xmm2\ncmp    %edx,%esi\njle    a2 <func0+0xa2>\nmovslq %edx,%rdx\nadd    $0x2,%eax\naddss  (%rdi,%rdx,4),%xmm2\ncmp    %eax,%esi\njle    a2 <func0+0xa2>\ncltq\naddss  (%rdi,%rax,4),%xmm2\ndivss  %xmm5,%xmm2\ncmp    $0x2,%ecx\njbe    181 <func0+0x181>\nmov    %esi,%edx\nmovaps 0x0(%rip),%xmm7\nmovaps %xmm2,%xmm3\nmov    %rdi,%rax\nshr    $0x2,%edx\nshufps $0x0,%xmm3,%xmm3\nshl    $0x4,%rdx\nadd    %rdi,%rdx\nnopl   0x0(%rax)\nmovups (%rax),%xmm1\nadd    $0x10,%rax\nsubps  %xmm3,%xmm1\nandps  %xmm7,%xmm1\naddss  %xmm1,%xmm0\nmovaps %xmm1,%xmm6\nmovaps %xmm1,%xmm4\nshufps $0x55,%xmm1,%xmm6\nunpckhps %xmm1,%xmm4\nshufps $0xff,%xmm1,%xmm1\naddss  %xmm6,%xmm0\naddss  %xmm0,%xmm4\nmovaps %xmm1,%xmm0\naddss  %xmm4,%xmm0\ncmp    %rdx,%rax\njne    d0 <func0+0xd0>\nmov    %esi,%eax\nand    $0xfffffffc,%eax\ntest   $0x3,%sil\nje     15f <func0+0x15f>\nmovslq %eax,%rdx\nmovss  0x0(%rip),%xmm3\n00\nmovss  (%rdi,%rdx,4),%xmm1\nlea    0x1(%rax),%edx\nsubss  %xmm2,%xmm1\nandps  %xmm3,%xmm1\naddss  %xmm1,%xmm0\ncmp    %esi,%edx\njge    15f <func0+0x15f>\nmovslq %edx,%rdx\nadd    $0x2,%eax\nmovss  (%rdi,%rdx,4),%xmm1\nsubss  %xmm2,%xmm1\nandps  %xmm3,%xmm1\naddss  %xmm1,%xmm0\ncmp    %esi,%eax\njge    15f <func0+0x15f>\ncltq\nmovss  (%rdi,%rax,4),%xmm1\nsubss  %xmm2,%xmm1\nandps  %xmm3,%xmm1\naddss  %xmm1,%xmm0\ndivss  %xmm5,%xmm0\nretq\nnopl   0x0(%rax)\ndivss  %xmm5,%xmm3\nmovaps %xmm3,%xmm2\njmpq   af <func0+0xaf>\nnopl   0x0(%rax)\npxor   %xmm0,%xmm0\ndivss  %xmm5,%xmm0\nretq\nxor    %eax,%eax\njmp    111 <func0+0x111>\npxor   %xmm0,%xmm0\nxor    %eax,%eax\nmovaps %xmm0,%xmm3\njmpq   7a <func0+0x7a>"
    },
    {
        "task_id": 5,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    %rcx,-0x28(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njle    2a <func0+0x2a>\nmov    -0x1c(%rbp),%eax\nadd    %eax,%eax\nlea    -0x1(%rax),%edx\njmp    2f <func0+0x2f>\nmov    $0x0,%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  49 <func0+0x49>\nmov    %rax,-0x8(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njle    5f <func0+0x5f>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x1,-0xc(%rbp)\njmp    c5 <func0+0xc5>\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     6f <func0+0x6f>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 5,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\ntest   %esi,%esi\njle    56 <func0+0x56>\nmov    %rdi,%rbx\nmov    %esi,%r12d\nmov    %edx,%ebp\nlea    -0x1(%rsi,%rsi,1),%edi\nmov    %edi,(%rcx)\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  26 <func0+0x26>\nmov    (%rbx),%edx\nmov    %edx,(%rax)\ncmp    $0x1,%r12d\njle    51 <func0+0x51>\nlea    -0x2(%r12),%esi\nadd    $0x2,%rsi\nmov    $0x1,%edx\nmov    %ebp,-0x4(%rax,%rdx,8)\nmov    (%rbx,%rdx,4),%ecx\nmov    %ecx,(%rax,%rdx,8)\nadd    $0x1,%rdx\ncmp    %rdx,%rsi\njne    3e <func0+0x3e>\npop    %rbx\npop    %rbp\npop    %r12\nretq\nmovl   $0x0,(%rcx)\nmov    $0x0,%edi\ncallq  66 <func0+0x66>\njmp    51 <func0+0x51>"
    },
    {
        "task_id": 5,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    60 <func0+0x60>\npush   %r12\nmov    %esi,%r12d\npush   %rbp\nmov    %edx,%ebp\npush   %rbx\nmov    %rdi,%rbx\nlea    -0x1(%rsi,%rsi,1),%edi\nmov    %edi,(%rcx)\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  26 <func0+0x26>\nmov    (%rbx),%edx\nmov    %edx,(%rax)\ncmp    $0x1,%r12d\nje     53 <func0+0x53>\nlea    -0x2(%r12),%edx\nmov    $0x1,%ecx\nadd    $0x2,%rdx\nxchg   %ax,%ax\nmov    (%rbx,%rcx,4),%esi\nmov    %ebp,-0x4(%rax,%rcx,8)\nmov    %esi,(%rax,%rcx,8)\nadd    $0x1,%rcx\ncmp    %rcx,%rdx\njne    40 <func0+0x40>\npop    %rbx\npop    %rbp\npop    %r12\nretq\nnopl   0x0(%rax,%rax,1)\n00\nmovl   $0x0,(%rcx)\nxor    %edi,%edi\njmpq   6d <func0+0x6d>"
    },
    {
        "task_id": 5,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    f0 <func0+0xf0>\npush   %r12\nmov    %edx,%r12d\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmov    %rdi,%rbx\nlea    -0x1(%rsi,%rsi,1),%edi\nmov    %edi,(%rcx)\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  2a <func0+0x2a>\nmov    (%rbx),%edx\nmov    %edx,(%rax)\ncmp    $0x1,%ebp\nje     e2 <func0+0xe2>\nlea    -0x2(%rbp),%edx\nlea    -0x1(%rbp),%edi\ncmp    $0x2,%edx\njbe    fd <func0+0xfd>\nmov    %edi,%esi\nmovd   %r12d,%xmm4\nxor    %ecx,%ecx\nshr    $0x2,%esi\npshufd $0x0,%xmm4,%xmm0\nshl    $0x4,%rsi\nnopl   0x0(%rax,%rax,1)\nmovdqu 0x4(%rbx,%rcx,1),%xmm2\nmovdqa %xmm0,%xmm1\npunpckldq %xmm2,%xmm1\nmovups %xmm1,0x4(%rax,%rcx,2)\nmovdqa %xmm0,%xmm1\npunpckhdq %xmm2,%xmm1\nmovups %xmm1,0x14(%rax,%rcx,2)\nadd    $0x10,%rcx\ncmp    %rcx,%rsi\njne    60 <func0+0x60>\nmov    %edi,%esi\nand    $0xfffffffc,%esi\nlea    0x1(%rsi),%ecx\nlea    0x1(%rsi,%rsi,1),%edx\ncmp    %esi,%edi\nje     e2 <func0+0xe2>\nmovslq %ecx,%r8\nmovslq %edx,%rsi\nlea    0x2(%rdx),%edi\nmov    (%rbx,%r8,4),%r8d\nmov    %r12d,(%rax,%rsi,4)\nmov    %r8d,0x4(%rax,%rsi,4)\nlea    0x1(%rcx),%esi\ncmp    %esi,%ebp\njle    e2 <func0+0xe2>\nmovslq %esi,%rsi\nmovslq %edi,%rdi\nadd    $0x2,%ecx\nadd    $0x4,%edx\nmov    (%rbx,%rsi,4),%esi\nmov    %r12d,(%rax,%rdi,4)\nmov    %esi,0x4(%rax,%rdi,4)\ncmp    %ecx,%ebp\njle    e2 <func0+0xe2>\nmovslq %ecx,%rcx\nmovslq %edx,%rdx\nmov    (%rbx,%rcx,4),%ecx\nmov    %r12d,(%rax,%rdx,4)\nmov    %ecx,0x4(%rax,%rdx,4)\npop    %rbx\npop    %rbp\npop    %r12\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\nmovl   $0x0,(%rcx)\nxor    %edi,%edi\njmpq   fd <func0+0xfd>\nmov    $0x1,%edx\nmov    $0x1,%ecx\njmp    99 <func0+0x99>"
    },
    {
        "task_id": 6,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovq   $0x0,-0x8(%rbp)\n00\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmpq   ce <func0+0xce>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x19(%rbp)\ncmpb   $0x28,-0x19(%rbp)\njne    71 <func0+0x71>\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njle    ca <func0+0xca>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x14(%rbp)\njmp    ca <func0+0xca>\ncmpb   $0x29,-0x19(%rbp)\njne    ca <func0+0xca>\nsubl   $0x1,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njne    ca <func0+0xca>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  a0 <func0+0xa0>\nmov    %rax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\nmovl   $0x0,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    44 <func0+0x44>\nmov    -0x30(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 6,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rsi,%r13\nmovzbl (%rdi),%edx\ntest   %dl,%dl\nje     7d <func0+0x7d>\nlea    0x1(%rdi),%rbx\nmov    $0x0,%r14d\nmov    $0x0,%r12d\nmov    $0x0,%ebp\nmov    $0x0,%eax\njmp    4e <func0+0x4e>\nadd    $0x1,%ebp\ncmp    %ebp,%r12d\ncmovl  %ebp,%r12d\nadd    $0x1,%rbx\nmovzbl -0x1(%rbx),%edx\ntest   %dl,%dl\nje     88 <func0+0x88>\ncmp    $0x28,%dl\nje     38 <func0+0x38>\ncmp    $0x29,%dl\njne    42 <func0+0x42>\nsub    $0x1,%ebp\njne    42 <func0+0x42>\nadd    $0x1,%r14d\nmovslq %r14d,%r15\nshl    $0x2,%r15\nmov    %r15,%rsi\nmov    %rax,%rdi\ncallq  73 <func0+0x73>\nmov    %r12d,-0x4(%rax,%r15,1)\nmov    %ebp,%r12d\njmp    42 <func0+0x42>\nmov    $0x0,%r14d\nmov    $0x0,%eax\nmov    %r14d,0x0(%r13)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 6,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%edx\ntest   %dl,%dl\nje     98 <func0+0x98>\nlea    0x1(%rdi),%rbx\nxor    %r14d,%r14d\nxor    %r12d,%r12d\nxor    %ebp,%ebp\nxor    %eax,%eax\njmp    40 <func0+0x40>\nnopl   0x0(%rax)\ncmp    $0x29,%dl\nje     70 <func0+0x70>\nmovzbl (%rbx),%edx\nadd    $0x1,%rbx\ntest   %dl,%dl\nje     5a <func0+0x5a>\ncmp    $0x28,%dl\njne    30 <func0+0x30>\nadd    $0x1,%ebp\ncmp    %ebp,%r12d\ncmovl  %ebp,%r12d\nmovzbl (%rbx),%edx\nadd    $0x1,%rbx\ntest   %dl,%dl\njne    40 <func0+0x40>\nmov    %r14d,0x0(%r13)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   (%rax)\nsub    $0x1,%ebp\njne    35 <func0+0x35>\nadd    $0x1,%r14d\nmov    %rax,%rdi\nmovslq %r14d,%r15\nshl    $0x2,%r15\nmov    %r15,%rsi\ncallq  8b <func0+0x8b>\nmov    %r12d,-0x4(%rax,%r15,1)\nxor    %r12d,%r12d\njmp    35 <func0+0x35>\nnopl   (%rax)\nxor    %r14d,%r14d\nxor    %eax,%eax\njmp    5a <func0+0x5a>"
    },
    {
        "task_id": 6,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%edx\ntest   %dl,%dl\nje     98 <func0+0x98>\nlea    0x1(%rdi),%rbx\nxor    %r14d,%r14d\nxor    %r12d,%r12d\nxor    %ebp,%ebp\nxor    %eax,%eax\njmp    40 <func0+0x40>\nnopl   0x0(%rax)\ncmp    $0x29,%dl\nje     70 <func0+0x70>\nmovzbl (%rbx),%edx\nadd    $0x1,%rbx\ntest   %dl,%dl\nje     5a <func0+0x5a>\ncmp    $0x28,%dl\njne    30 <func0+0x30>\nadd    $0x1,%ebp\ncmp    %ebp,%r12d\ncmovl  %ebp,%r12d\nmovzbl (%rbx),%edx\nadd    $0x1,%rbx\ntest   %dl,%dl\njne    40 <func0+0x40>\nmov    %r14d,0x0(%r13)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   (%rax)\nsub    $0x1,%ebp\njne    35 <func0+0x35>\nadd    $0x1,%r14d\nmov    %rax,%rdi\nmovslq %r14d,%r15\nshl    $0x2,%r15\nmov    %r15,%rsi\ncallq  8b <func0+0x8b>\nmov    %r12d,-0x4(%rax,%r15,1)\nxor    %r12d,%r12d\njmp    35 <func0+0x35>\nnopl   (%rax)\nxor    %r14d,%r14d\nxor    %eax,%eax\njmp    5a <func0+0x5a>"
    },
    {
        "task_id": 7,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmovq   $0x0,-0x8(%rbp)\n00\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmpq   bb <func0+0xbb>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  5c <func0+0x5c>\ntest   %rax,%rax\nje     b7 <func0+0xb7>\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  80 <func0+0x80>\nmov    %rax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     36 <func0+0x36>\nmov    -0x30(%rbp),%rax\nmov    -0x10(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 7,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdx,(%rsp)\nmov    %rcx,0x8(%rsp)\ntest   %esi,%esi\njle    74 <func0+0x74>\nmov    %rdi,%rbx\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%r15\nmov    $0x0,%r14d\nmov    $0x0,%ebp\njmp    5e <func0+0x5e>\nadd    $0x1,%r14d\nmovslq %r14d,%r12\nshl    $0x3,%r12\nmov    %r12,%rsi\nmov    %rbp,%rdi\ncallq  4d <func0+0x4d>\nmov    %rax,%rbp\nmov    %r13,-0x8(%rax,%r12,1)\nadd    $0x8,%rbx\ncmp    %r15,%rbx\nje     7f <func0+0x7f>\nmov    (%rbx),%r13\nmov    (%rsp),%rsi\nmov    %r13,%rdi\ncallq  6d <func0+0x6d>\ntest   %rax,%rax\njne    37 <func0+0x37>\njmp    55 <func0+0x55>\nmov    $0x0,%r14d\nmov    $0x0,%ebp\nmov    0x8(%rsp),%rax\nmov    %r14d,(%rax)\nmov    %rbp,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 7,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rcx,0x8(%rsp)\ntest   %esi,%esi\njle    98 <func0+0x98>\nlea    -0x1(%rsi),%eax\nmov    %rdx,%r13\nmov    %rdi,%rbx\nxor    %r12d,%r12d\nlea    0x8(%rdi,%rax,8),%rax\nxor    %ebp,%ebp\nmov    %rax,(%rsp)\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%r14\nmov    %r13,%rsi\nmov    %r14,%rdi\ncallq  46 <func0+0x46>\ntest   %rax,%rax\nje     6d <func0+0x6d>\nadd    $0x1,%r12d\nmov    %rbp,%rdi\nmovslq %r12d,%rdx\nlea    0x0(,%rdx,8),%r15\n00\nmov    %r15,%rsi\ncallq  65 <func0+0x65>\nmov    %r14,-0x8(%rax,%r15,1)\nmov    %rax,%rbp\nadd    $0x8,%rbx\ncmp    (%rsp),%rbx\njne    38 <func0+0x38>\nmov    0x8(%rsp),%rax\nmov    %r12d,(%rax)\nadd    $0x18,%rsp\nmov    %rbp,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\nxor    %r12d,%r12d\nxor    %ebp,%ebp\njmp    77 <func0+0x77>"
    },
    {
        "task_id": 7,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rcx,0x8(%rsp)\ntest   %esi,%esi\njle    98 <func0+0x98>\nlea    -0x1(%rsi),%eax\nmov    %rdx,%r13\nmov    %rdi,%rbx\nxor    %r12d,%r12d\nlea    0x8(%rdi,%rax,8),%rax\nxor    %ebp,%ebp\nmov    %rax,(%rsp)\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%r14\nmov    %r13,%rsi\nmov    %r14,%rdi\ncallq  46 <func0+0x46>\ntest   %rax,%rax\nje     6d <func0+0x6d>\nadd    $0x1,%r12d\nmov    %rbp,%rdi\nmovslq %r12d,%rdx\nlea    0x0(,%rdx,8),%r15\n00\nmov    %r15,%rsi\ncallq  65 <func0+0x65>\nmov    %r14,-0x8(%rax,%r15,1)\nmov    %rax,%rbp\nadd    $0x8,%rbx\ncmp    (%rsp),%rbx\njne    38 <func0+0x38>\nmov    0x8(%rsp),%rax\nmov    %r12d,(%rax)\nadd    $0x18,%rsp\nmov    %rbp,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\nxor    %r12d,%r12d\nxor    %ebp,%ebp\njmp    77 <func0+0x77>"
    },
    {
        "task_id": 8,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    66 <func0+0x66>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x8(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     2a <func0+0x2a>\nmov    -0x28(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x28(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 8,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    33 <func0+0x33>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%ecx\nlea    0x4(%rdi,%rcx,4),%r8\nmov    $0x1,%esi\nmov    $0x0,%edi\nmov    (%rax),%ecx\nadd    %ecx,%edi\nimul   %ecx,%esi\nadd    $0x4,%rax\ncmp    %r8,%rax\njne    1d <func0+0x1d>\nmov    %edi,(%rdx)\nmov    %esi,0x4(%rdx)\nretq\nmov    $0x1,%esi\nmov    $0x0,%edi\njmp    2d <func0+0x2d>"
    },
    {
        "task_id": 8,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    40 <func0+0x40>\nlea    -0x1(%rsi),%eax\nmov    $0x1,%ecx\nxor    %esi,%esi\nlea    0x4(%rdi,%rax,4),%r8\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    (%rdi),%eax\nadd    $0x4,%rdi\nimul   %eax,%ecx\nadd    %eax,%esi\ncmp    %r8,%rdi\njne    20 <func0+0x20>\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nretq\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    $0x1,%ecx\nxor    %esi,%esi\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nretq"
    },
    {
        "task_id": 8,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    100 <func0+0x100>\nlea    -0x1(%rsi),%eax\ncmp    $0x16,%eax\njbe    10f <func0+0x10f>\nmov    %esi,%ecx\nmovdqa 0x0(%rip),%xmm0\n00\nmov    %rdi,%rax\npxor   %xmm2,%xmm2\nshr    $0x2,%ecx\nshl    $0x4,%rcx\nadd    %rdi,%rcx\nnopl   0x0(%rax,%rax,1)\nmovdqu (%rax),%xmm1\nmovdqa %xmm0,%xmm3\npsrlq  $0x20,%xmm0\nadd    $0x10,%rax\npmuludq %xmm1,%xmm3\npaddd  %xmm1,%xmm2\npsrlq  $0x20,%xmm1\npmuludq %xmm0,%xmm1\npshufd $0x8,%xmm3,%xmm0\npshufd $0x8,%xmm1,%xmm1\npunpckldq %xmm1,%xmm0\ncmp    %rcx,%rax\njne    38 <func0+0x38>\nmovdqa %xmm0,%xmm3\nmovdqa %xmm0,%xmm1\nmov    %esi,%ecx\npsrldq $0x8,%xmm3\npsrlq  $0x20,%xmm0\nand    $0xfffffffc,%ecx\npmuludq %xmm3,%xmm1\npsrlq  $0x20,%xmm3\npmuludq %xmm3,%xmm0\npshufd $0x8,%xmm1,%xmm1\npshufd $0x8,%xmm0,%xmm0\npunpckldq %xmm0,%xmm1\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm1\npmuludq %xmm1,%xmm0\nmovd   %xmm0,%r8d\nmovdqa %xmm2,%xmm0\npsrldq $0x8,%xmm0\npaddd  %xmm0,%xmm2\nmovdqa %xmm2,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm2\nmovd   %xmm2,%eax\ntest   $0x3,%sil\nje     f3 <func0+0xf3>\nmovslq %ecx,%rcx\nnopl   0x0(%rax,%rax,1)\n00\nmov    (%rdi,%rcx,4),%r9d\nadd    $0x1,%rcx\nimul   %r9d,%r8d\nadd    %r9d,%eax\ncmp    %ecx,%esi\njg     e0 <func0+0xe0>\nmov    %eax,(%rdx)\nmov    %r8d,0x4(%rdx)\nretq\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%r8d\nxor    %eax,%eax\nmov    %eax,(%rdx)\nmov    %r8d,0x4(%rdx)\nretq\nxor    %ecx,%ecx\nmov    $0x1,%r8d\nxor    %eax,%eax\njmp    d5 <func0+0xd5>"
    },
    {
        "task_id": 9,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njg     23 <func0+0x23>\nmov    $0x0,%eax\njmpq   b5 <func0+0xb5>\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  34 <func0+0x34>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    46 <func0+0x46>\nmov    $0x0,%eax\njmp    b5 <func0+0xb5>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    a9 <func0+0xa9>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    8c <func0+0x8c>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     58 <func0+0x58>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 9,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x0,%eax\ntest   %esi,%esi\njle    51 <func0+0x51>\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nmov    %esi,%ebp\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncallq  24 <func0+0x24>\ntest   %rax,%rax\nje     4a <func0+0x4a>\nmov    (%rbx),%ecx\nlea    -0x1(%rbp),%edi\nmov    $0x0,%edx\nmov    (%rbx,%rdx,4),%esi\ncmp    %esi,%ecx\ncmovl  %esi,%ecx\nmov    %ecx,(%rax,%rdx,4)\nmov    %rdx,%rsi\nadd    $0x1,%rdx\ncmp    %rdi,%rsi\njne    33 <func0+0x33>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq\nretq"
    },
    {
        "task_id": 9,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    60 <func0+0x60>\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nshl    $0x2,%rdi\nsub    $0x8,%rsp\ncallq  1f <func0+0x1f>\ntest   %rax,%rax\nje     54 <func0+0x54>\nmov    (%rbx),%ecx\nlea    -0x1(%rbp),%edi\nxor    %edx,%edx\nshl    $0x2,%rdi\nmov    %ecx,%esi\njmp    40 <func0+0x40>\nnopl   0x0(%rax,%rax,1)\nmov    0x4(%rbx,%rdx,1),%esi\nadd    $0x4,%rdx\ncmp    %esi,%ecx\ncmovl  %esi,%ecx\nmov    %ecx,(%rax,%rdx,1)\ncmp    %rdi,%rdx\njne    38 <func0+0x38>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nretq\nnopl   (%rax)\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 9,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    60 <func0+0x60>\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nshl    $0x2,%rdi\nsub    $0x8,%rsp\ncallq  1f <func0+0x1f>\ntest   %rax,%rax\nje     4e <func0+0x4e>\nmov    (%rbx),%ecx\nlea    -0x1(%rbp),%edi\nxor    %edx,%edx\nnopl   0x0(%rax,%rax,1)\nmov    (%rbx,%rdx,4),%esi\ncmp    %esi,%ecx\ncmovl  %esi,%ecx\nmov    %rdx,%rsi\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rsi,%rdi\njne    30 <func0+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 10,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  1c <func0+0x1c>\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncallq  31 <func0+0x31>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    46 <func0+0x46>\nmov    $0x0,%eax\njmpq   1a9 <func0+0x1a9>\nmovl   $0x0,-0x18(%rbp)\njmpq   12f <func0+0x12f>\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    9e <func0+0x9e>\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xc(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x14(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     9a <func0+0x9a>\nmovl   $0x0,-0x10(%rbp)\njmp    b2 <func0+0xb2>\naddl   $0x1,-0x14(%rbp)\nmov    -0xc(%rbp),%eax\nsub    -0x18(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x14(%rbp)\njl     62 <func0+0x62>\ncmpl   $0x0,-0x10(%rbp)\nje     12b <func0+0x12b>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncallq  d1 <func0+0xd1>\nmovl   $0x0,-0x14(%rbp)\njmp    108 <func0+0x108>\nmov    -0x18(%rbp),%eax\nsub    -0x14(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0xc(%rbp),%ecx\nmov    -0x14(%rbp),%edx\nadd    %ecx,%edx\nmovslq %edx,%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     da <func0+0xda>\nmov    -0xc(%rbp),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\njmp    1a9 <func0+0x1a9>\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     52 <func0+0x52>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncallq  154 <func0+0x154>\nmovl   $0x0,-0x14(%rbp)\njmp    18b <func0+0x18b>\nmov    -0xc(%rbp),%eax\nsub    -0x14(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0xc(%rbp),%ecx\nmov    -0x14(%rbp),%edx\nadd    %ecx,%edx\nmovslq %edx,%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     15d <func0+0x15d>\nmov    -0xc(%rbp),%eax\nadd    %eax,%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 10,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%rbp\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nmov    %rcx,%rax\nnot    %rax\nlea    -0x1(%rax),%r12\nlea    (%r12,%r12,1),%r15d\nlea    0x1(%r15),%edi\nmovslq %edi,%rdi\ncallq  3d <func0+0x3d>\nmov    %rax,%r14\ntest   %rax,%rax\nje     ca <func0+0xca>\nmov    %r12d,%r13d\ntest   %r12d,%r12d\njle    7a <func0+0x7a>\nmov    %r12d,%r9d\nlea    -0x1(%r12),%eax\nmov    %eax,0xc(%rsp)\nmov    %eax,%r8d\nmov    %rbp,%rsi\nmov    $0x0,%ebx\nmovslq %r12d,%rdi\nsub    $0x1,%rdi\njmp    e8 <func0+0xe8>\nmov    0xc(%rsp),%ebx\njmpq   11f <func0+0x11f>\nmovslq %r12d,%rdx\nmov    %rbp,%rsi\nmov    %rax,%rdi\ncallq  88 <func0+0x88>\njmp    c2 <func0+0xc2>\nmovslq %ebx,%rbx\nmov    %rbx,%rdx\nmov    %rbp,%rsi\nmov    %r14,%rdi\ncallq  9b <func0+0x9b>\nlea    -0x1(%rbp,%rbx,1),%rax\nlea    (%r14,%rbx,1),%rdx\nlea    -0x2(%rbp,%rbx,1),%rsi\nmov    0xc(%rsp),%ecx\nsub    %rcx,%rsi\nmovzbl (%rax),%ecx\nmov    %cl,(%rdx)\nsub    $0x1,%rax\nadd    $0x1,%rdx\ncmp    %rsi,%rax\njne    b0 <func0+0xb0>\nmovslq %r15d,%r15\nmovb   $0x0,(%r14,%r15,1)\nmov    %r14,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nadd    $0x1,%ebx\nadd    $0x1,%rsi\ncmp    %ebx,%r13d\nje     8a <func0+0x8a>\nmov    %r9d,%eax\nsub    %ebx,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\ncmp    %r8d,%ebx\nje     71 <func0+0x71>\nlea    0x0(%rbp,%rdi,1),%rdx\nmov    $0x0,%eax\nmovzbl (%rdx),%r10d\ncmp    %r10b,(%rsi,%rax,1)\njne    dc <func0+0xdc>\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %eax,%ecx\njg     109 <func0+0x109>\nmovslq %r12d,%r13\nmov    %r13,%rdx\nmov    %rbp,%rsi\nmov    %r14,%rdi\ncallq  130 <func0+0x130>\ntest   %ebx,%ebx\njle    15d <func0+0x15d>\nmovslq %ebx,%rcx\nlea    -0x1(%rbp,%rcx,1),%rax\nlea    (%r14,%r13,1),%rdx\nlea    -0x2(%rbp,%rcx,1),%rsi\nlea    -0x1(%rbx),%ecx\nsub    %rcx,%rsi\nmovzbl (%rax),%ecx\nmov    %cl,(%rdx)\nsub    $0x1,%rax\nadd    $0x1,%rdx\ncmp    %rsi,%rax\njne    14b <func0+0x14b>\nlea    (%rbx,%r12,1),%eax\ncltq\nmovb   $0x0,(%r14,%rax,1)\njmpq   ca <func0+0xca>"
    },
    {
        "task_id": 10,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rdi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncallq  1a <func0+0x1a>\nlea    (%rax,%rax,1),%ebx\nmov    %rax,%r12\nmov    %eax,%r15d\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\ncallq  2e <func0+0x2e>\nmov    %rax,%r8\ntest   %rax,%rax\nje     100 <func0+0x100>\nmovslq %r12d,%r14\ntest   %r12d,%r12d\njle    165 <func0+0x165>\nxor    %ebp,%ebp\nmov    %r12d,%edx\nlea    -0x1(%r12),%edi\nmov    %r13,%rax\nsub    %ebp,%edx\nmov    %r12d,%r10d\nmovslq %edi,%rdi\nmov    %edx,%ecx\nsar    %ecx\nje     b0 <func0+0xb0>\nnopl   0x0(%rax)\nlea    0x1(%rax),%r9\nsub    $0x1,%ecx\nlea    0x0(%r13,%rdi,1),%rdx\nadd    %r9,%rcx\njmp    8d <func0+0x8d>\nnopl   0x0(%rax)\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %rcx,%rax\nje     b0 <func0+0xb0>\nmovzbl (%rdx),%esi\ncmp    %sil,(%rax)\nje     80 <func0+0x80>\nadd    $0x1,%ebp\ncmp    %ebp,%r15d\nje     112 <func0+0x112>\nmov    %r12d,%edx\nmov    %r9,%rax\nsub    %ebp,%edx\nmov    %edx,%ecx\nsar    %ecx\njne    68 <func0+0x68>\nnopl   0x0(%rax,%rax,1)\nmov    %r8,%rdi\nmov    %r14,%rdx\nmov    %r13,%rsi\ncallq  be <func0+0xbe>\nmov    %rax,%r8\ntest   %ebp,%ebp\nje     f4 <func0+0xf4>\nmovslq %ebp,%rdx\nadd    %r8,%r14\nlea    -0x2(%r13,%rdx,1),%rcx\nlea    -0x1(%r13,%rdx,1),%rax\nlea    -0x1(%rbp),%edx\nsub    %rdx,%rcx\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rax),%edx\nsub    $0x1,%rax\nadd    $0x1,%r14\nmov    %dl,-0x1(%r14)\ncmp    %rcx,%rax\njne    e0 <func0+0xe0>\nlea    0x0(%rbp,%r12,1),%eax\ncltq\nmovb   $0x0,(%r8,%rax,1)\nadd    $0x18,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    %r14,%rdx\nmov    %r13,%rsi\nmov    %r8,%rdi\nmov    %r10d,0xc(%rsp)\ncallq  125 <func0+0x125>\nmov    0xc(%rsp),%r10d\nlea    -0x2(%r13,%r14,1),%rsi\nmov    %rax,%r8\nlea    -0x1(%r13,%r14,1),%rax\nlea    -0x1(%r10),%ecx\nlea    (%r8,%r14,1),%rdx\nsub    %rcx,%rsi\nnopw   0x0(%rax,%rax,1)\nmovzbl (%rax),%ecx\nsub    $0x1,%rax\nadd    $0x1,%rdx\nmov    %cl,-0x1(%rdx)\ncmp    %rax,%rsi\njne    148 <func0+0x148>\nmovslq %ebx,%rbx\nmovb   $0x0,(%r8,%rbx,1)\njmp    100 <func0+0x100>\nmov    %r14,%rdx\nmov    %r13,%rsi\nmov    %rax,%rdi\ncallq  173 <func0+0x173>\nmov    %rax,%r8\njmp    15b <func0+0x15b>"
    },
    {
        "task_id": 10,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rdi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncallq  1a <func0+0x1a>\nlea    (%rax,%rax,1),%ebx\nmov    %rax,%r12\nmov    %eax,%r15d\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\ncallq  2e <func0+0x2e>\nmov    %rax,%r8\ntest   %rax,%rax\nje     100 <func0+0x100>\nmovslq %r12d,%r14\ntest   %r12d,%r12d\njle    165 <func0+0x165>\nxor    %ebp,%ebp\nmov    %r12d,%edx\nlea    -0x1(%r12),%edi\nmov    %r13,%rax\nsub    %ebp,%edx\nmov    %r12d,%r10d\nmovslq %edi,%rdi\nmov    %edx,%ecx\nsar    %ecx\nje     b0 <func0+0xb0>\nnopl   0x0(%rax)\nlea    0x1(%rax),%r9\nsub    $0x1,%ecx\nlea    0x0(%r13,%rdi,1),%rdx\nadd    %r9,%rcx\njmp    8d <func0+0x8d>\nnopl   0x0(%rax)\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %rcx,%rax\nje     b0 <func0+0xb0>\nmovzbl (%rdx),%esi\ncmp    %sil,(%rax)\nje     80 <func0+0x80>\nadd    $0x1,%ebp\ncmp    %ebp,%r15d\nje     112 <func0+0x112>\nmov    %r12d,%edx\nmov    %r9,%rax\nsub    %ebp,%edx\nmov    %edx,%ecx\nsar    %ecx\njne    68 <func0+0x68>\nnopl   0x0(%rax,%rax,1)\nmov    %r8,%rdi\nmov    %r14,%rdx\nmov    %r13,%rsi\ncallq  be <func0+0xbe>\nmov    %rax,%r8\ntest   %ebp,%ebp\nje     f4 <func0+0xf4>\nmovslq %ebp,%rdx\nadd    %r8,%r14\nlea    -0x2(%r13,%rdx,1),%rcx\nlea    -0x1(%r13,%rdx,1),%rax\nlea    -0x1(%rbp),%edx\nsub    %rdx,%rcx\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rax),%edx\nsub    $0x1,%rax\nadd    $0x1,%r14\nmov    %dl,-0x1(%r14)\ncmp    %rcx,%rax\njne    e0 <func0+0xe0>\nlea    0x0(%rbp,%r12,1),%eax\ncltq\nmovb   $0x0,(%r8,%rax,1)\nadd    $0x18,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    %r14,%rdx\nmov    %r13,%rsi\nmov    %r8,%rdi\nmov    %r10d,0xc(%rsp)\ncallq  125 <func0+0x125>\nmov    0xc(%rsp),%r10d\nlea    -0x2(%r13,%r14,1),%rsi\nmov    %rax,%r8\nlea    -0x1(%r13,%r14,1),%rax\nlea    -0x1(%r10),%ecx\nlea    (%r8,%r14,1),%rdx\nsub    %rcx,%rsi\nnopw   0x0(%rax,%rax,1)\nmovzbl (%rax),%ecx\nsub    $0x1,%rax\nadd    $0x1,%rdx\nmov    %cl,-0x1(%rdx)\ncmp    %rax,%rsi\njne    148 <func0+0x148>\nmovslq %ebx,%rbx\nmovb   $0x0,(%r8,%rbx,1)\njmp    100 <func0+0x100>\nmov    %r14,%rdx\nmov    %r13,%rsi\nmov    %rax,%rdi\ncallq  173 <func0+0x173>\nmov    %rax,%r8\njmp    15b <func0+0x15b>"
    },
    {
        "task_id": 11,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  20 <func0+0x20>\nmov    %eax,-0x14(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncallq  2f <func0+0x2f>\nmov    %eax,-0x10(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    %eax,-0x10(%rbp)\ncmovle -0x10(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncallq  4f <func0+0x4f>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    61 <func0+0x61>\nmov    $0x0,%eax\njmp    c9 <func0+0xc9>\nmovl   $0x0,-0x18(%rbp)\njmp    ad <func0+0xad>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x30(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    95 <func0+0x95>\nmov    $0x30,%ecx\njmp    9a <func0+0x9a>\nmov    $0x31,%ecx\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    %cl,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     6a <func0+0x6a>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 11,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbp\nmov    %rsi,%r12\nmov    $0xffffffffffffffff,%rbx\nmov    $0x0,%eax\nmov    %rbx,%rcx\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%rdx\nmov    %rbx,%rcx\nmov    %rsi,%rdi\nrepnz scas %es:(%rdi),%al\nmov    %rcx,%rax\nnot    %rax\nlea    -0x1(%rax),%rbx\ncmp    %edx,%ebx\ncmovge %edx,%ebx\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\ncallq  48 <func0+0x48>\ntest   %rax,%rax\nje     81 <func0+0x81>\ntest   %ebx,%ebx\njle    7a <func0+0x7a>\nlea    -0x1(%rbx),%esi\nmov    $0x0,%edx\njmp    5e <func0+0x5e>\nmov    %rcx,%rdx\nmovzbl (%r12,%rdx,1),%edi\ncmp    %dil,0x0(%rbp,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%rax,%rdx,1)\nlea    0x1(%rdx),%rcx\ncmp    %rsi,%rdx\njne    5b <func0+0x5b>\nmovslq %ebx,%rbx\nmovb   $0x0,(%rax,%rbx,1)\npop    %rbx\npop    %rbp\npop    %r12\nretq"
    },
    {
        "task_id": 11,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmov    %rdi,%rbx\ncallq  13 <func0+0x13>\nmov    %rbp,%rdi\nmov    %rax,%r12\ncallq  1e <func0+0x1e>\ncmp    %r12d,%eax\ncmovl  %eax,%r12d\nlea    0x1(%r12),%edi\nmovslq %edi,%rdi\ncallq  32 <func0+0x32>\ntest   %rax,%rax\nje     6e <func0+0x6e>\ntest   %r12d,%r12d\njle    66 <func0+0x66>\nlea    -0x1(%r12),%esi\nxor    %edx,%edx\njmp    4b <func0+0x4b>\nnopl   (%rax)\nmov    %rcx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%edi\ncmp    %dil,(%rbx,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%rax,%rdx,1)\nlea    0x1(%rdx),%rcx\ncmp    %rsi,%rdx\njne    48 <func0+0x48>\nmovslq %r12d,%r12\nmovb   $0x0,(%rax,%r12,1)\npop    %rbx\npop    %rbp\npop    %r12\nretq"
    },
    {
        "task_id": 11,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\ncallq  13 <func0+0x13>\nmov    %rbp,%rdi\nmov    %rax,%rbx\ncallq  1e <func0+0x1e>\ncmp    %ebx,%eax\ncmovl  %eax,%ebx\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\ncallq  2e <func0+0x2e>\ntest   %rax,%rax\nje     297 <func0+0x297>\ntest   %ebx,%ebx\njle    290 <func0+0x290>\nlea    -0x1(%rbx),%edx\ncmp    $0xe,%edx\njbe    29c <func0+0x29c>\nmov    %ebx,%ecx\nmovdqa 0x0(%rip),%xmm3\n00\nmovdqa 0x0(%rip),%xmm2\n00\nxor    %edx,%edx\nshr    $0x4,%ecx\nshl    $0x4,%rcx\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmovdqu (%r12,%rdx,1),%xmm0\nmovdqu 0x0(%rbp,%rdx,1),%xmm4\nmovdqa %xmm3,%xmm1\npcmpeqb %xmm4,%xmm0\npand   %xmm0,%xmm1\npandn  %xmm2,%xmm0\npor    %xmm1,%xmm0\nmovups %xmm0,(%rax,%rdx,1)\nadd    $0x10,%rdx\ncmp    %rcx,%rdx\njne    70 <func0+0x70>\nmov    %ebx,%edx\nand    $0xfffffff0,%edx\ntest   $0xf,%bl\nje     290 <func0+0x290>\nmovslq %edx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0x1(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl (%r12,%rcx,1),%edi\ncmp    %dil,0x0(%rbp,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0x2(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0x3(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0x4(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0x5(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0x6(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0x7(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0x8(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0x9(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0xa(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0xb(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0xc(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\nlea    0xd(%rdx),%ecx\ncmp    %ecx,%ebx\njle    290 <func0+0x290>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edi\ncmp    %dil,(%r12,%rcx,1)\nsetne  %sil\nadd    $0xe,%edx\nadd    $0x30,%esi\nmov    %sil,(%rax,%rcx,1)\ncmp    %edx,%ebx\njle    290 <func0+0x290>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%edi\ncmp    %dil,(%r12,%rdx,1)\nsetne  %cl\nadd    $0x30,%ecx\nmov    %cl,(%rax,%rdx,1)\nnopl   (%rax)\nmovslq %ebx,%rbx\nmovb   $0x0,(%rax,%rbx,1)\npop    %rbx\npop    %rbp\npop    %r12\nretq\nxor    %edx,%edx\njmpq   ab <func0+0xab>"
    },
    {
        "task_id": 12,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    7d <func0+0x7d>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncallq  4d <func0+0x4d>\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njle    79 <func0+0x79>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     2e <func0+0x2e>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 12,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    0x0(%rip),%r11\ntest   %esi,%esi\njle    56 <func0+0x56>\nmov    %rdi,%rdx\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%r10\nmov    $0x0,%r8d\nmov    $0xffffffffffffffff,%r9\nmov    $0x0,%eax\njmp    37 <func0+0x37>\nadd    $0x8,%rdx\ncmp    %r10,%rdx\nje     56 <func0+0x56>\nmov    (%rdx),%rsi\nmov    %r9,%rcx\nmov    %rsi,%rdi\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nsub    $0x1,%rcx\ncmp    %r8d,%ecx\njle    2e <func0+0x2e>\nmov    %ecx,%r8d\nmov    %rsi,%r11\njmp    2e <func0+0x2e>\nmov    %r11,%rax\nretq"
    },
    {
        "task_id": 12,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\nlea    0x0(%rip),%r12\npush   %rbp\npush   %rbx\ntest   %esi,%esi\njle    45 <func0+0x45>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %ebp,%ebp\nlea    0x8(%rdi,%rax,8),%r13\nnopl   0x0(%rax)\nmov    (%rbx),%r14\nmov    %r14,%rdi\ncallq  33 <func0+0x33>\ncmp    %ebp,%eax\njle    3c <func0+0x3c>\nmov    %eax,%ebp\nmov    %r14,%r12\nadd    $0x8,%rbx\ncmp    %r13,%rbx\njne    28 <func0+0x28>\npop    %rbx\nmov    %r12,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq"
    },
    {
        "task_id": 12,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\nlea    0x0(%rip),%r12\npush   %rbp\npush   %rbx\ntest   %esi,%esi\njle    45 <func0+0x45>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %ebp,%ebp\nlea    0x8(%rdi,%rax,8),%r13\nnopl   0x0(%rax)\nmov    (%rbx),%r14\nmov    %r14,%rdi\ncallq  33 <func0+0x33>\ncmp    %ebp,%eax\njle    3c <func0+0x3c>\nmov    %eax,%ebp\nmov    %r14,%r12\nadd    $0x8,%rbx\ncmp    %r13,%rbx\njne    28 <func0+0x28>\npop    %rbx\nmov    %r12,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq"
    },
    {
        "task_id": 13,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\njmp    26 <func0+0x26>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x18(%rbp)\nmov    %edx,-0x4(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njne    10 <func0+0x10>\nmov    -0x14(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 13,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\ntest   %esi,%esi\nje     1a <func0+0x1a>\nmov    %esi,%ecx\ncltd\nidiv   %esi\nmov    %edx,%esi\nmov    %ecx,%eax\ntest   %edx,%edx\njne    a <func0+0xa>\nmov    %ecx,%eax\nretq\nmov    %edi,%ecx\njmp    17 <func0+0x17>"
    },
    {
        "task_id": 13,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nmov    %esi,%edx\ntest   %esi,%esi\nje     28 <func0+0x28>\nnopl   0x0(%rax)\nmov    %edx,%r8d\ncltd\nidiv   %r8d\nmov    %r8d,%eax\ntest   %edx,%edx\njne    10 <func0+0x10>\nmov    %r8d,%eax\nretq\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 13,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nmov    %esi,%edx\ntest   %esi,%esi\nje     28 <func0+0x28>\nnopl   0x0(%rax)\nmov    %edx,%r8d\ncltd\nidiv   %r8d\nmov    %r8d,%eax\ntest   %edx,%edx\njne    10 <func0+0x10>\nmov    %r8d,%eax\nretq\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 14,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncallq  21 <func0+0x21>\nmov    %eax,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncallq  35 <func0+0x35>\nmov    %rax,-0x20(%rbp)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncallq  49 <func0+0x49>\nmov    %rax,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0x30(%rbp)\njmpq   115 <func0+0x115>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  6c <func0+0x6c>\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nlea    0x2(%rax),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  87 <func0+0x87>\nmov    %rax,-0x28(%rbp)\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x28(%rbp),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\nmov    -0x18(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  c6 <func0+0xc6>\nadd    $0x1,%rax\nmov    -0x30(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x20(%rbp),%rdx\nlea    (%rcx,%rdx,1),%rbx\nmov    %rax,%rdi\ncallq  e8 <func0+0xe8>\nmov    %rax,(%rbx)\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  111 <func0+0x111>\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     60 <func0+0x60>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  12d <func0+0x12d>\nmov    -0x40(%rbp),%rax\nmov    -0x2c(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 14,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,%r15\nmov    %rsi,0x18(%rsp)\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%r14\nmov    %r14,0x10(%rsp)\nmovslq %r14d,%rdi\nshl    $0x3,%rdi\ncallq  40 <func0+0x40>\nmov    %rax,(%rsp)\nlea    0x1(%r14),%edi\nmovslq %edi,%rdi\ncallq  50 <func0+0x50>\nmov    %rax,%rbx\nmovb   $0x0,(%rax)\ntest   %r14d,%r14d\njle    df <func0+0xdf>\nlea    -0x1(%r14),%eax\nmov    %rax,0x8(%rsp)\nmov    $0x0,%r13d\nmov    $0x0,%ebp\nmov    $0xffffffffffffffff,%rcx\nmov    %rbx,%rdi\nmov    %ebp,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nmov    %rcx,%r12\nlea    0x1(%rcx),%rsi\nmov    %rbx,%rdi\ncallq  93 <func0+0x93>\nmov    %rax,%rbx\nmovzbl (%r15,%r13,1),%eax\nmov    %al,-0x1(%rbx,%r12,1)\nmovb   $0x0,(%rbx,%r12,1)\nmov    $0xffffffffffffffff,%rcx\nmov    %rbx,%rdi\nmov    %ebp,%eax\nrepnz scas %es:(%rdi),%al\nmov    %rcx,%rdi\nnot    %rdi\ncallq  be <func0+0xbe>\nmov    %rax,%rdi\nmov    (%rsp),%rax\nmov    %rdi,(%rax,%r13,8)\nmov    %rbx,%rsi\ncallq  d1 <func0+0xd1>\nmov    %r13,%rax\nadd    $0x1,%r13\ncmp    0x8(%rsp),%rax\njne    6e <func0+0x6e>\nmov    %rbx,%rdi\ncallq  e7 <func0+0xe7>\nmov    0x18(%rsp),%rax\nmov    0x10(%rsp),%edx\nmov    %edx,(%rax)\nmov    (%rsp),%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 14,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,(%rsp)\ncallq  1e <func0+0x1e>\nmovslq %eax,%rdi\nmov    %rax,%rbx\nmov    %rax,0x8(%rsp)\nshl    $0x3,%rdi\ncallq  32 <func0+0x32>\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\nmov    %rax,%r12\ncallq  40 <func0+0x40>\nmovb   $0x0,(%rax)\nmov    %rax,%r15\ntest   %ebx,%ebx\njle    11c <func0+0x11c>\nlea    -0x1(%rbx),%r13d\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nmov    %r15,%r14\nmov    (%r14),%ecx\nadd    $0x4,%r14\nlea    -0x1010101(%rcx),%eax\nnot    %ecx\nand    %ecx,%eax\nand    $0x80808080,%eax\nje     5b <func0+0x5b>\nmov    %eax,%ecx\nmov    %r15,%rdi\nshr    $0x10,%ecx\ntest   $0x8080,%eax\ncmove  %ecx,%eax\nlea    0x2(%r14),%rcx\ncmove  %rcx,%r14\nmov    %eax,%esi\nadd    %al,%sil\nsbb    $0x3,%r14\nsub    %r15,%r14\nlea    0x2(%r14),%rsi\ncallq  a0 <func0+0xa0>\nmov    %rax,%r15\nmovzbl 0x0(%rbp,%rbx,1),%eax\nmovb   $0x0,0x1(%r15,%r14,1)\nmov    %r15,%rdx\nmov    %al,(%r15,%r14,1)\nmov    (%rdx),%eax\nadd    $0x4,%rdx\nlea    -0x1010101(%rax),%ecx\nnot    %eax\nand    %eax,%ecx\nand    $0x80808080,%ecx\nje     b5 <func0+0xb5>\nmov    %ecx,%eax\nshr    $0x10,%eax\ntest   $0x8080,%ecx\ncmove  %eax,%ecx\nlea    0x2(%rdx),%rax\ncmove  %rax,%rdx\nmov    %ecx,%eax\nadd    %cl,%al\nsbb    $0x3,%rdx\nsub    %r15,%rdx\nlea    0x1(%rdx),%r14\nmov    %r14,%rdi\ncallq  fa <func0+0xfa>\nmov    %r14,%rdx\nmov    %r15,%rsi\nmov    %rax,%rdi\nmov    %rax,(%r12,%rbx,8)\ncallq  10c <func0+0x10c>\nmov    %rbx,%rax\nadd    $0x1,%rbx\ncmp    %r13,%rax\njne    58 <func0+0x58>\nmov    %r15,%rdi\ncallq  124 <func0+0x124>\nmov    (%rsp),%rax\nmov    0x8(%rsp),%ebx\nmov    %ebx,(%rax)\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 14,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,(%rsp)\ncallq  1e <func0+0x1e>\nmovslq %eax,%rdi\nmov    %rax,%rbx\nmov    %rax,0x8(%rsp)\nshl    $0x3,%rdi\ncallq  32 <func0+0x32>\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\nmov    %rax,%r12\ncallq  40 <func0+0x40>\nmovb   $0x0,(%rax)\nmov    %rax,%r15\ntest   %ebx,%ebx\njle    11c <func0+0x11c>\nlea    -0x1(%rbx),%r13d\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nmov    %r15,%r14\nmov    (%r14),%ecx\nadd    $0x4,%r14\nlea    -0x1010101(%rcx),%eax\nnot    %ecx\nand    %ecx,%eax\nand    $0x80808080,%eax\nje     5b <func0+0x5b>\nmov    %eax,%ecx\nmov    %r15,%rdi\nshr    $0x10,%ecx\ntest   $0x8080,%eax\ncmove  %ecx,%eax\nlea    0x2(%r14),%rcx\ncmove  %rcx,%r14\nmov    %eax,%esi\nadd    %al,%sil\nsbb    $0x3,%r14\nsub    %r15,%r14\nlea    0x2(%r14),%rsi\ncallq  a0 <func0+0xa0>\nmov    %rax,%r15\nmovzbl 0x0(%rbp,%rbx,1),%eax\nmovb   $0x0,0x1(%r15,%r14,1)\nmov    %r15,%rdx\nmov    %al,(%r15,%r14,1)\nmov    (%rdx),%eax\nadd    $0x4,%rdx\nlea    -0x1010101(%rax),%ecx\nnot    %eax\nand    %eax,%ecx\nand    $0x80808080,%ecx\nje     b5 <func0+0xb5>\nmov    %ecx,%eax\nshr    $0x10,%eax\ntest   $0x8080,%ecx\ncmove  %eax,%ecx\nlea    0x2(%rdx),%rax\ncmove  %rax,%rdx\nmov    %ecx,%eax\nadd    %cl,%al\nsbb    $0x3,%rdx\nsub    %r15,%rdx\nlea    0x1(%rdx),%r14\nmov    %r14,%rdi\ncallq  fa <func0+0xfa>\nmov    %r14,%rdx\nmov    %r15,%rsi\nmov    %rax,%rdi\nmov    %rax,(%r12,%rbx,8)\ncallq  10c <func0+0x10c>\nmov    %rbx,%rax\nadd    $0x1,%rbx\ncmp    %r13,%rax\njne    58 <func0+0x58>\nmov    %r15,%rdi\ncallq  124 <func0+0x124>\nmov    (%rsp),%rax\nmov    0x8(%rsp),%ebx\nmov    %ebx,(%rax)\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 15,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmovl   $0x2,-0x1c(%rbp)\nmovl   $0x1,-0x18(%rbp)\njmp    46 <func0+0x46>\nmov    -0x18(%rbp),%eax\nmov    %eax,%ecx\nlea    0x0(%rip),%rdx\nmov    $0x0,%esi\nmov    $0x0,%edi\nmov    $0x0,%eax\ncallq  3f <func0+0x3f>\nadd    %eax,-0x1c(%rbp)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    1f <func0+0x1f>\nmov    -0x1c(%rbp),%eax\ncltq\nmov    %rax,%rdi\ncallq  5b <func0+0x5b>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    6d <func0+0x6d>\nmov    $0x0,%eax\njmp    cd <func0+0xcd>\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncallq  8d <func0+0x8d>\ncltq\nadd    %rax,-0x10(%rbp)\nmovl   $0x1,-0x14(%rbp)\njmp    c1 <func0+0xc1>\nmov    -0x14(%rbp),%edx\nmov    -0x10(%rbp),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncallq  b7 <func0+0xb7>\ncltq\nadd    %rax,-0x10(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    9c <func0+0x9c>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 15,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ntest   %edi,%edi\njle    ba <func0+0xba>\nmov    %edi,%r12d\nlea    0x1(%rdi),%r14d\nmov    $0x1,%ebx\nmov    $0x2,%ebp\nlea    0x0(%rip),%r13\nmov    %ebx,%r9d\nmov    %r13,%r8\nmov    $0xffffffffffffffff,%rcx\nmov    $0x1,%edx\nmov    $0x0,%esi\nmov    $0x0,%edi\nmov    $0x0,%eax\ncallq  52 <func0+0x52>\nadd    %eax,%ebp\nadd    $0x1,%ebx\ncmp    %r14d,%ebx\njne    2c <func0+0x2c>\nmovslq %ebp,%rdi\ncallq  64 <func0+0x64>\nmov    %rax,%r14\ntest   %rax,%rax\nje     ae <func0+0xae>\nmovw   $0x30,(%r14)\nlea    0x1(%r14),%rbp\nmov    $0x1,%ebx\nlea    0x0(%rip),%r13\nmov    %ebx,%r8d\nmov    %r13,%rcx\nmov    $0xffffffffffffffff,%rdx\nmov    $0x1,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncallq  a1 <func0+0xa1>\ncltq\nadd    %rax,%rbp\nadd    $0x1,%ebx\ncmp    %ebx,%r12d\njge    82 <func0+0x82>\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nmov    $0x2,%edi\ncallq  c4 <func0+0xc4>\nmov    %rax,%r14\ntest   %rax,%rax\nje     ae <func0+0xae>\nmovw   $0x30,(%rax)\njmp    ae <func0+0xae>"
    },
    {
        "task_id": 15,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ntest   %edi,%edi\njle    c0 <func0+0xc0>\nlea    0x1(%rdi),%r12d\nmov    $0x1,%ebx\nmov    $0x2,%ebp\nlea    0x0(%rip),%r13\nnopl   0x0(%rax)\nmov    %ebx,%r9d\nmov    %r13,%r8\nmov    $0xffffffffffffffff,%rcx\nxor    %esi,%esi\nmov    $0x1,%edx\nxor    %edi,%edi\nxor    %eax,%eax\nmov    %ebx,%r14d\ncallq  50 <func0+0x50>\nlea    0x1(%rbx),%ebx\nadd    %eax,%ebp\ncmp    %r12d,%ebx\njne    30 <func0+0x30>\nmovslq %ebp,%rdi\ncallq  62 <func0+0x62>\nmov    %rax,%r13\ntest   %rax,%rax\nje     e6 <func0+0xe6>\nmov    $0x30,%eax\nlea    0x1(%r13),%rbp\nmov    $0x1,%ebx\nmov    %ax,0x0(%r13)\nlea    0x0(%rip),%r12\nnopl   0x0(%rax)\nmov    %ebx,%r8d\nmov    %rbp,%rdi\nmov    %r12,%rcx\nmov    $0xffffffffffffffff,%rdx\nmov    $0x1,%esi\nxor    %eax,%eax\ncallq  a4 <func0+0xa4>\ncltq\nadd    %rax,%rbp\nmov    %ebx,%eax\nadd    $0x1,%ebx\ncmp    %eax,%r14d\njne    88 <func0+0x88>\npop    %rbx\nmov    %r13,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nnop\nmov    $0x2,%edi\ncallq  ca <func0+0xca>\nmov    %rax,%r13\ntest   %rax,%rax\nje     e6 <func0+0xe6>\nmov    $0x30,%edx\nmov    %dx,(%rax)\nmov    %r13,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nxor    %r13d,%r13d\njmp    b3 <func0+0xb3>"
    },
    {
        "task_id": 15,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ntest   %edi,%edi\njle    c0 <func0+0xc0>\nlea    0x1(%rdi),%r12d\nmov    $0x1,%ebx\nmov    $0x2,%ebp\nlea    0x0(%rip),%r13\nnopl   0x0(%rax)\nmov    %ebx,%r9d\nmov    %r13,%r8\nmov    $0xffffffffffffffff,%rcx\nxor    %esi,%esi\nmov    $0x1,%edx\nxor    %edi,%edi\nxor    %eax,%eax\nmov    %ebx,%r14d\ncallq  50 <func0+0x50>\nlea    0x1(%rbx),%ebx\nadd    %eax,%ebp\ncmp    %r12d,%ebx\njne    30 <func0+0x30>\nmovslq %ebp,%rdi\ncallq  62 <func0+0x62>\nmov    %rax,%r13\ntest   %rax,%rax\nje     e6 <func0+0xe6>\nmov    $0x30,%eax\nlea    0x1(%r13),%rbp\nmov    $0x1,%ebx\nmov    %ax,0x0(%r13)\nlea    0x0(%rip),%r12\nnopl   0x0(%rax)\nmov    %ebx,%r8d\nmov    %rbp,%rdi\nmov    %r12,%rcx\nmov    $0xffffffffffffffff,%rdx\nmov    $0x1,%esi\nxor    %eax,%eax\ncallq  a4 <func0+0xa4>\ncltq\nadd    %rax,%rbp\nmov    %ebx,%eax\nadd    $0x1,%ebx\ncmp    %eax,%r14d\njne    88 <func0+0x88>\npop    %rbx\nmov    %r13,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nnop\nmov    $0x2,%edi\ncallq  ca <func0+0xca>\nmov    %rax,%r13\ntest   %rax,%rax\nje     e6 <func0+0xe6>\nmov    $0x30,%edx\nmov    %dx,(%rax)\nmov    %r13,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nxor    %r13d,%r13d\njmp    b3 <func0+0xb3>"
    },
    {
        "task_id": 16,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x430,%rsp\nmov    %rdi,-0x428(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x418(%rbp)\n00 00 00\nlea    -0x410(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x80,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x0,-0x414(%rbp)\n00 00 00\njmpq   d8 <func0+0xd8>\nmov    -0x414(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x428(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncallq  75 <func0+0x75>\nmov    %al,-0x419(%rbp)\nmovsbl -0x419(%rbp),%eax\ncltq\nmov    -0x410(%rbp,%rax,4),%eax\ntest   %eax,%eax\njne    d1 <func0+0xd1>\ncallq  94 <func0+0x94>\nmov    (%rax),%rax\nmovzbl -0x419(%rbp),%edx\nmovzbl %dl,%edx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\nje     d1 <func0+0xd1>\nmovsbl -0x419(%rbp),%eax\ncltq\nmovl   $0x1,-0x410(%rbp,%rax,4)\n01 00 00 00\naddl   $0x1,-0x418(%rbp)\naddl   $0x1,-0x414(%rbp)\nmov    -0x414(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x428(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    55 <func0+0x55>\nmov    -0x418(%rbp),%eax\nmov    -0x8(%rbp),%rsi\nxor    %fs:0x28,%rsi\n00 00\nje     110 <func0+0x110>\ncallq  110 <func0+0x110>\nleaveq\nretq"
    },
    {
        "task_id": 16,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x410,%rsp\nmov    %rdi,%rbp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x408(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nmov    $0x80,%ecx\nrep stos %rax,%es:(%rdi)\nmovzbl 0x0(%rbp),%ebx\ntest   %bl,%bl\nje     94 <func0+0x94>\ncallq  41 <func0+0x41>\nmov    (%rax),%r12\nadd    $0x1,%rbp\nmov    $0x0,%r13d\njmp    5c <func0+0x5c>\nadd    $0x1,%rbp\nmovzbl -0x1(%rbp),%ebx\ntest   %bl,%bl\nje     9a <func0+0x9a>\nmovzbl %bl,%ebx\nmov    (%r12,%rbx,4),%ebx\nmovsbl %bl,%r14d\nmovsbq %bl,%rax\ncmpl   $0x0,(%rsp,%rax,4)\njne    50 <func0+0x50>\ncallq  76 <func0+0x76>\nmovzbl %bl,%ebx\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%rbx,2)\nje     50 <func0+0x50>\nmovslq %r14d,%r14\nmovl   $0x1,(%rsp,%r14,4)\n00\nadd    $0x1,%r13d\njmp    50 <func0+0x50>\nmov    $0x0,%r13d\nmov    0x408(%rsp),%rax\n00\nxor    %fs:0x28,%rax\n00 00\njne    c0 <func0+0xc0>\nmov    %r13d,%eax\nadd    $0x410,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\ncallq  c5 <func0+0xc5>"
    },
    {
        "task_id": 16,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\nmov    $0x80,%ecx\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x410,%rsp\nmovzbl 0x0(%rbp),%ebx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x408(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nrep stos %rax,%es:(%rdi)\ntest   %bl,%bl\nje     b0 <func0+0xb0>\ncallq  41 <func0+0x41>\nadd    $0x1,%rbp\nxor    %r12d,%r12d\nmov    (%rax),%r14\nnopl   0x0(%rax,%rax,1)\nmov    (%r14,%rbx,4),%ebx\nmovsbq %bl,%r13\nmov    (%rsp,%r13,4),%eax\ntest   %eax,%eax\njne    7e <func0+0x7e>\ncallq  65 <func0+0x65>\nmovzbl %bl,%ebx\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%rbx,2)\nje     7e <func0+0x7e>\nmovl   $0x1,(%rsp,%r13,4)\n00\nadd    $0x1,%r12d\nmovzbl 0x0(%rbp),%ebx\nadd    $0x1,%rbp\ntest   %bl,%bl\njne    50 <func0+0x50>\nmov    0x408(%rsp),%rax\n00\nxor    %fs:0x28,%rax\n00 00\njne    b5 <func0+0xb5>\nadd    $0x410,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nxor    %r12d,%r12d\njmp    8a <func0+0x8a>\ncallq  ba <func0+0xba>"
    },
    {
        "task_id": 16,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\nmov    $0x80,%ecx\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x410,%rsp\nmovzbl 0x0(%rbp),%ebx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x408(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nrep stos %rax,%es:(%rdi)\ntest   %bl,%bl\nje     b0 <func0+0xb0>\ncallq  41 <func0+0x41>\nadd    $0x1,%rbp\nxor    %r12d,%r12d\nmov    (%rax),%r14\nnopl   0x0(%rax,%rax,1)\nmov    (%r14,%rbx,4),%ebx\nmovsbq %bl,%r13\nmov    (%rsp,%r13,4),%eax\ntest   %eax,%eax\njne    7e <func0+0x7e>\ncallq  65 <func0+0x65>\nmovzbl %bl,%ebx\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%rbx,2)\nje     7e <func0+0x7e>\nmovl   $0x1,(%rsp,%r13,4)\n00\nadd    $0x1,%r12d\nmovzbl 0x0(%rbp),%ebx\nadd    $0x1,%rbp\ntest   %bl,%bl\njne    50 <func0+0x50>\nmov    0x408(%rsp),%rax\n00\nxor    %fs:0x28,%rax\n00 00\njne    b5 <func0+0xb5>\nadd    $0x410,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nxor    %r12d,%r12d\njmp    8a <func0+0x8a>\ncallq  ba <func0+0xba>"
    },
    {
        "task_id": 17,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x28(%rbp)\n00\nmovl   $0x0,-0x38(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmovw   $0x0,-0xb(%rbp)\nmovb   $0x0,-0x9(%rbp)\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncallq  4f <func0+0x4f>\nadd    $0x1,%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncallq  65 <func0+0x65>\nmov    %rax,-0x20(%rbp)\nmov    -0x48(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  7c <func0+0x7c>\nmov    -0x20(%rbp),%rax\nmov    $0xffffffffffffffff,%rcx\nmov    %rax,%rdx\nmov    $0x0,%eax\nmov    %rdx,%rdi\nrepnz scas %es:(%rdi),%al\nmov    %rcx,%rax\nnot    %rax\nlea    -0x1(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovw   $0x20,(%rax)\nmovl   $0x0,-0x30(%rbp)\njmpq   275 <func0+0x275>\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\njne    230 <func0+0x230>\nlea    -0xb(%rbp),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  e1 <func0+0xe1>\ntest   %eax,%eax\njne    142 <func0+0x142>\nmov    -0x38(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njne    122 <func0+0x122>\ncmpl   $0x0,-0x34(%rbp)\njle    fa <func0+0xfa>\nmov    -0x34(%rbp),%eax\nadd    %eax,%eax\njmp    ff <func0+0xff>\nmov    $0x4,%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  11e <func0+0x11e>\nmov    %rax,-0x28(%rbp)\nmov    -0x38(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x38(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x4,(%rax)\nlea    -0xb(%rbp),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  155 <func0+0x155>\ntest   %eax,%eax\njne    1b6 <func0+0x1b6>\nmov    -0x38(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njne    196 <func0+0x196>\ncmpl   $0x0,-0x34(%rbp)\njle    16e <func0+0x16e>\nmov    -0x34(%rbp),%eax\nadd    %eax,%eax\njmp    173 <func0+0x173>\nmov    $0x4,%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  192 <func0+0x192>\nmov    %rax,-0x28(%rbp)\nmov    -0x38(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x38(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x2,(%rax)\nlea    -0xb(%rbp),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  1c9 <func0+0x1c9>\ntest   %eax,%eax\njne    22a <func0+0x22a>\nmov    -0x38(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njne    20a <func0+0x20a>\ncmpl   $0x0,-0x34(%rbp)\njle    1e2 <func0+0x1e2>\nmov    -0x34(%rbp),%eax\nadd    %eax,%eax\njmp    1e7 <func0+0x1e7>\nmov    $0x4,%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  206 <func0+0x206>\nmov    %rax,-0x28(%rbp)\nmov    -0x38(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x38(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\nmovb   $0x0,-0xb(%rbp)\njmp    271 <func0+0x271>\nlea    -0xb(%rbp),%rax\nmov    %rax,%rdi\ncallq  23c <func0+0x23c>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x1,-0x18(%rbp)\nja     271 <func0+0x271>\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nlea    -0xb(%rbp),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    %al,(%rdx)\nmov    -0x18(%rbp),%rax\nadd    $0x1,%rax\nmovb   $0x0,-0xb(%rbp,%rax,1)\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     b6 <func0+0xb6>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncallq  28d <func0+0x28d>\nmov    -0x50(%rbp),%rax\nmov    -0x38(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rcx\nxor    %fs:0x28,%rcx\n00 00\nje     2ae <func0+0x2ae>\ncallq  2ae <func0+0x2ae>\nleaveq\nretq"
    },
    {
        "task_id": 17,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,%r12\nmov    %rsi,0x8(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmovw   $0x0,0x15(%rsp)\nmovb   $0x0,0x17(%rsp)\nmov    $0xffffffffffffffff,%r13\nmov    $0x0,%ebx\nmov    %r13,%rcx\nmov    %ebx,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%rbp\nlea    0x1(%rcx),%edi\nmovslq %edi,%rdi\ncallq  5b <func0+0x5b>\nmov    %rax,%r14\nmov    %r12,%rsi\nmov    %rax,%rdi\ncallq  69 <func0+0x69>\nmov    %r13,%rcx\nmov    %r14,(%rsp)\nmov    %r14,%rdi\nmov    %ebx,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nmovw   $0x20,-0x1(%r14,%rcx,1)\n00\nlea    0x1(%rbp),%eax\ntest   %eax,%eax\njle    207 <func0+0x207>\nmov    %r14,%rbx\nmov    %ebp,%ebp\nlea    0x1(%r14,%rbp,1),%r15\nmov    $0x0,%r13d\nmov    $0x0,%ebp\nmov    $0x0,%r14d\nlea    0x15(%rsp),%r12\njmpq   157 <func0+0x157>\nmov    $0x2,%ecx\nmov    %r12,%rsi\nlea    0x0(%rip),%rdi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %al\nsbb    $0x0,%al\ntest   %al,%al\njne    e3 <func0+0xe3>\ncmp    %r13d,%ebp\nje     18c <func0+0x18c>\nmovslq %ebp,%rax\nmovl   $0x4,(%r14,%rax,4)\n00\nlea    0x1(%rbp),%ebp\nmov    $0x3,%ecx\nmov    %r12,%rsi\nlea    0x0(%rip),%rdi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %al\nsbb    $0x0,%al\ntest   %al,%al\njne    114 <func0+0x114>\ncmp    %r13d,%ebp\nje     1b5 <func0+0x1b5>\nmovslq %ebp,%rax\nmovl   $0x2,(%r14,%rax,4)\n00\nlea    0x1(%rbp),%ebp\nmov    $0x3,%ecx\nmov    %r12,%rsi\nlea    0x0(%rip),%rdi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %al\nsbb    $0x0,%al\ntest   %al,%al\njne    145 <func0+0x145>\ncmp    %r13d,%ebp\nje     1de <func0+0x1de>\nmovslq %ebp,%rax\nmovl   $0x1,(%r14,%rax,4)\n00\nlea    0x1(%rbp),%ebp\nmovb   $0x0,0x15(%rsp)\nadd    $0x1,%rbx\ncmp    %r15,%rbx\nje     212 <func0+0x212>\nmovzbl (%rbx),%edx\ncmp    $0x20,%dl\nje     b2 <func0+0xb2>\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nmov    %r12,%rdi\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nsub    $0x1,%rcx\ncmp    $0x1,%rcx\nja     14a <func0+0x14a>\nmov    %dl,0x15(%rsp,%rcx,1)\nmovb   $0x0,0x16(%rsp,%rcx,1)\njmp    14a <func0+0x14a>\nlea    0x0(%r13,%r13,1),%eax\ntest   %r13d,%r13d\nmov    $0x4,%r13d\ncmovg  %eax,%r13d\nmovslq %r13d,%rsi\nshl    $0x2,%rsi\nmov    %r14,%rdi\ncallq  1ad <func0+0x1ad>\nmov    %rax,%r14\njmpq   d5 <func0+0xd5>\nlea    0x0(%r13,%r13,1),%eax\ntest   %r13d,%r13d\nmov    $0x4,%r13d\ncmovg  %eax,%r13d\nmovslq %r13d,%rsi\nshl    $0x2,%rsi\nmov    %r14,%rdi\ncallq  1d6 <func0+0x1d6>\nmov    %rax,%r14\njmpq   106 <func0+0x106>\nlea    0x0(%r13,%r13,1),%eax\ntest   %r13d,%r13d\nmov    $0x4,%r13d\ncmovg  %eax,%r13d\nmovslq %r13d,%rsi\nshl    $0x2,%rsi\nmov    %r14,%rdi\ncallq  1ff <func0+0x1ff>\nmov    %rax,%r14\njmpq   137 <func0+0x137>\nmov    $0x0,%ebp\nmov    $0x0,%r14d\nmov    (%rsp),%rdi\ncallq  21b <func0+0x21b>\nmov    0x8(%rsp),%rax\nmov    %ebp,(%rax)\nmov    0x18(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    244 <func0+0x244>\nmov    %r14,%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\ncallq  249 <.LC2+0x244>"
    },
    {
        "task_id": 17,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rsi,0x18(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nxor    %eax,%eax\nmovb   $0x0,0x27(%rsp)\nmov    %ax,0x25(%rsp)\ncallq  3b <func0+0x3b>\nlea    0x2(%rax),%edi\nmov    %rax,%rbp\nmovslq %edi,%rdi\ncallq  49 <func0+0x49>\nmov    %rbp,%rdx\nmov    %r12,%rsi\nmov    %rax,%rdi\nmov    %rax,%rbx\nmov    %rax,0x10(%rsp)\ncallq  5f <func0+0x5f>\nmov    $0x20,%edx\nlea    0x1(%rbp),%eax\nmov    %dx,(%rbx,%rbp,1)\ntest   %eax,%eax\njle    240 <func0+0x240>\nmov    %ebp,%ebp\nmovl   $0x0,0xc(%rsp)\n00\nxor    %r15d,%r15d\nlea    0x25(%rsp),%r14\nlea    0x1(%rbx,%rbp,1),%r12\nxor    %ebp,%ebp\njmp    b5 <func0+0xb5>\nxchg   %ax,%ax\nmov    %r14,%rdi\ncallq  98 <func0+0x98>\ncmp    $0x2,%rax\nje     a8 <func0+0xa8>\nmov    %r13b,0x25(%rsp,%rax,1)\nmovb   $0x0,0x26(%rsp,%rax,1)\nadd    $0x1,%rbx\ncmp    %r12,%rbx\nje     154 <func0+0x154>\nmovzbl (%rbx),%r13d\ncmp    $0x20,%r13b\njne    90 <func0+0x90>\ncmpb   $0x6f,(%r14)\njne    e6 <func0+0xe6>\ncmpb   $0x0,0x1(%r14)\njne    e6 <func0+0xe6>\ncmp    %r15d,0xc(%rsp)\nje     190 <func0+0x190>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovl   $0x4,0x0(%rbp,%rax,4)\n00\ncmpb   $0x6f,(%r14)\njne    114 <func0+0x114>\ncmpb   $0x7c,0x1(%r14)\njne    114 <func0+0x114>\ncmpb   $0x0,0x2(%r14)\njne    114 <func0+0x114>\ncmp    0xc(%rsp),%r15d\nje     1e0 <func0+0x1e0>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovl   $0x2,0x0(%rbp,%rax,4)\n00\ncmpb   $0x2e,(%r14)\njne    142 <func0+0x142>\ncmpb   $0x7c,0x1(%r14)\njne    142 <func0+0x142>\ncmpb   $0x0,0x2(%r14)\njne    142 <func0+0x142>\ncmp    0xc(%rsp),%r15d\nje     1b8 <func0+0x1b8>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovl   $0x1,0x0(%rbp,%rax,4)\n00\nadd    $0x1,%rbx\nmovb   $0x0,0x25(%rsp)\ncmp    %r12,%rbx\njne    b5 <func0+0xb5>\nmov    0x10(%rsp),%rdi\ncallq  15e <func0+0x15e>\nmov    0x18(%rsp),%rax\nmov    %r15d,(%rax)\nmov    0x28(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    24a <func0+0x24a>\nadd    $0x38,%rsp\nmov    %rbp,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\nmov    0xc(%rsp),%eax\ntest   %eax,%eax\nje     208 <func0+0x208>\nadd    %eax,%eax\nmov    %eax,0xc(%rsp)\nmovslq %eax,%rsi\nshl    $0x2,%rsi\nmov    %rbp,%rdi\ncallq  1ad <func0+0x1ad>\nmov    %rax,%rbp\njmpq   d7 <func0+0xd7>\nnopl   (%rax)\ntest   %r15d,%r15d\nje     230 <func0+0x230>\nlea    (%r15,%r15,1),%eax\nmov    %eax,0xc(%rsp)\nmovslq %eax,%rsi\nshl    $0x2,%rsi\nmov    %rbp,%rdi\ncallq  1d4 <func0+0x1d4>\nmov    %rax,%rbp\njmpq   133 <func0+0x133>\nnopl   0x0(%rax)\ntest   %r15d,%r15d\nje     220 <func0+0x220>\nlea    (%r15,%r15,1),%eax\nmov    %eax,0xc(%rsp)\nmovslq %eax,%rsi\nshl    $0x2,%rsi\nmov    %rbp,%rdi\ncallq  1fc <func0+0x1fc>\nmov    %rax,%rbp\njmpq   105 <func0+0x105>\nnopl   0x0(%rax)\nmovl   $0x4,0xc(%rsp)\n00\nmov    $0x10,%esi\njmp    1a5 <func0+0x1a5>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovl   $0x4,0xc(%rsp)\n00\nmov    $0x10,%esi\njmp    1f4 <func0+0x1f4>\nnop\nmovl   $0x4,0xc(%rsp)\n00\nmov    $0x10,%esi\njmp    1cc <func0+0x1cc>\nnop\nxor    %r15d,%r15d\nxor    %ebp,%ebp\njmpq   154 <func0+0x154>\ncallq  24f <func0+0x24f>"
    },
    {
        "task_id": 17,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rsi,0x18(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nxor    %eax,%eax\nmovb   $0x0,0x27(%rsp)\nmov    %ax,0x25(%rsp)\ncallq  3b <func0+0x3b>\nlea    0x2(%rax),%edi\nmov    %rax,%rbp\nmovslq %edi,%rdi\ncallq  49 <func0+0x49>\nmov    %rbp,%rdx\nmov    %r12,%rsi\nmov    %rax,%rdi\nmov    %rax,%rbx\nmov    %rax,0x10(%rsp)\ncallq  5f <func0+0x5f>\nmov    $0x20,%edx\nlea    0x1(%rbp),%eax\nmov    %dx,(%rbx,%rbp,1)\ntest   %eax,%eax\njle    240 <func0+0x240>\nmov    %ebp,%ebp\nmovl   $0x0,0xc(%rsp)\n00\nxor    %r15d,%r15d\nlea    0x25(%rsp),%r14\nlea    0x1(%rbx,%rbp,1),%r12\nxor    %ebp,%ebp\njmp    b5 <func0+0xb5>\nxchg   %ax,%ax\nmov    %r14,%rdi\ncallq  98 <func0+0x98>\ncmp    $0x2,%rax\nje     a8 <func0+0xa8>\nmov    %r13b,0x25(%rsp,%rax,1)\nmovb   $0x0,0x26(%rsp,%rax,1)\nadd    $0x1,%rbx\ncmp    %rbx,%r12\nje     154 <func0+0x154>\nmovzbl (%rbx),%r13d\ncmp    $0x20,%r13b\njne    90 <func0+0x90>\ncmpb   $0x6f,(%r14)\njne    e6 <func0+0xe6>\ncmpb   $0x0,0x1(%r14)\njne    e6 <func0+0xe6>\ncmp    %r15d,0xc(%rsp)\nje     190 <func0+0x190>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovl   $0x4,0x0(%rbp,%rax,4)\n00\ncmpb   $0x6f,(%r14)\njne    114 <func0+0x114>\ncmpb   $0x7c,0x1(%r14)\njne    114 <func0+0x114>\ncmpb   $0x0,0x2(%r14)\njne    114 <func0+0x114>\ncmp    0xc(%rsp),%r15d\nje     1e0 <func0+0x1e0>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovl   $0x2,0x0(%rbp,%rax,4)\n00\ncmpb   $0x2e,(%r14)\njne    142 <func0+0x142>\ncmpb   $0x7c,0x1(%r14)\njne    142 <func0+0x142>\ncmpb   $0x0,0x2(%r14)\njne    142 <func0+0x142>\ncmp    0xc(%rsp),%r15d\nje     1b8 <func0+0x1b8>\nmovslq %r15d,%rax\nadd    $0x1,%r15d\nmovl   $0x1,0x0(%rbp,%rax,4)\n00\nadd    $0x1,%rbx\nmovb   $0x0,0x25(%rsp)\ncmp    %rbx,%r12\njne    b5 <func0+0xb5>\nmov    0x10(%rsp),%rdi\ncallq  15e <func0+0x15e>\nmov    0x18(%rsp),%rax\nmov    %r15d,(%rax)\nmov    0x28(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    24a <func0+0x24a>\nadd    $0x38,%rsp\nmov    %rbp,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\nmov    0xc(%rsp),%eax\ntest   %eax,%eax\nje     208 <func0+0x208>\nadd    %eax,%eax\nmov    %eax,0xc(%rsp)\nmovslq %eax,%rsi\nshl    $0x2,%rsi\nmov    %rbp,%rdi\ncallq  1ad <func0+0x1ad>\nmov    %rax,%rbp\njmpq   d7 <func0+0xd7>\nnopl   (%rax)\ntest   %r15d,%r15d\nje     230 <func0+0x230>\nlea    (%r15,%r15,1),%eax\nmov    %eax,0xc(%rsp)\nmovslq %eax,%rsi\nshl    $0x2,%rsi\nmov    %rbp,%rdi\ncallq  1d4 <func0+0x1d4>\nmov    %rax,%rbp\njmpq   133 <func0+0x133>\nnopl   0x0(%rax)\ntest   %r15d,%r15d\nje     220 <func0+0x220>\nlea    (%r15,%r15,1),%eax\nmov    %eax,0xc(%rsp)\nmovslq %eax,%rsi\nshl    $0x2,%rsi\nmov    %rbp,%rdi\ncallq  1fc <func0+0x1fc>\nmov    %rax,%rbp\njmpq   105 <func0+0x105>\nnopl   0x0(%rax)\nmovl   $0x4,0xc(%rsp)\n00\nmov    $0x10,%esi\njmp    1a5 <func0+0x1a5>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovl   $0x4,0xc(%rsp)\n00\nmov    $0x10,%esi\njmp    1f4 <func0+0x1f4>\nnop\nmovl   $0x4,0xc(%rsp)\n00\nmov    $0x10,%esi\njmp    1cc <func0+0x1cc>\nnop\nxor    %r15d,%r15d\nxor    %ebp,%ebp\njmpq   154 <func0+0x154>\ncallq  24f <func0+0x24f>"
    },
    {
        "task_id": 18,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  27 <func0+0x27>\nmov    %eax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncallq  36 <func0+0x36>\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njne    46 <func0+0x46>\nmov    $0x0,%eax\njmp    8b <func0+0x8b>\nmovl   $0x0,-0xc(%rbp)\njmp    7d <func0+0x7d>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncallq  71 <func0+0x71>\ntest   %eax,%eax\njne    79 <func0+0x79>\naddl   $0x1,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0x8(%rbp),%eax\nsub    -0x4(%rbp),%eax\ncmp    %eax,-0xc(%rbp)\njle    4f <func0+0x4f>\nmov    -0x10(%rbp),%eax\nleaveq\nretq"
    },
    {
        "task_id": 18,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r8\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%rdx\nmov    %edx,%ebp\ntest   %edx,%edx\nje     73 <func0+0x73>\nmov    %rsi,%r12\nmov    $0xffffffffffffffff,%rcx\nmov    %rsi,%rdi\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nsub    $0x1,%rcx\nsub    %ecx,%edx\njs     7e <func0+0x7e>\nmov    %r8,%rbx\nmov    %edx,%edx\nlea    0x1(%r8,%rdx,1),%r14\nmov    $0x0,%ebp\nmovslq %ecx,%r13\nmov    %r13,%rdx\nmov    %r12,%rsi\nmov    %rbx,%rdi\ncallq  64 <func0+0x64>\ncmp    $0x1,%eax\nadc    $0x0,%ebp\nadd    $0x1,%rbx\ncmp    %r14,%rbx\njne    56 <func0+0x56>\nmov    %ebp,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nmov    $0x0,%ebp\njmp    73 <func0+0x73>"
    },
    {
        "task_id": 18,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\ncallq  17 <func0+0x17>\nmov    %eax,%r14d\ntest   %eax,%eax\nje     5e <func0+0x5e>\nmov    %r12,%rdi\nmov    %rax,%r13\ncallq  29 <func0+0x29>\nsub    %eax,%r13d\njs     70 <func0+0x70>\nmovslq %r13d,%r13\nmovslq %eax,%rbp\nxor    %r14d,%r14d\nlea    0x1(%rbx,%r13,1),%r13\nnopl   0x0(%rax)\nmov    %rbx,%rdi\nmov    %rbp,%rdx\nmov    %r12,%rsi\ncallq  4e <func0+0x4e>\ncmp    $0x1,%eax\nadc    $0x0,%r14d\nadd    $0x1,%rbx\ncmp    %r13,%rbx\njne    40 <func0+0x40>\npop    %rbx\nmov    %r14d,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nnopw   0x0(%rax,%rax,1)\nxor    %r14d,%r14d\njmp    5e <func0+0x5e>"
    },
    {
        "task_id": 18,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\ncallq  17 <func0+0x17>\nmov    %eax,%r14d\ntest   %eax,%eax\nje     5e <func0+0x5e>\nmov    %r12,%rdi\nmov    %rax,%r13\ncallq  29 <func0+0x29>\nsub    %eax,%r13d\njs     70 <func0+0x70>\nmovslq %r13d,%r13\nmovslq %eax,%rbp\nxor    %r14d,%r14d\nlea    0x1(%rbx,%r13,1),%r13\nnopl   0x0(%rax)\nmov    %rbx,%rdi\nmov    %rbp,%rdx\nmov    %r12,%rsi\ncallq  4e <func0+0x4e>\ncmp    $0x1,%eax\nadc    $0x0,%r14d\nadd    $0x1,%rbx\ncmp    %r13,%rbx\njne    40 <func0+0x40>\npop    %rbx\nmov    %r14d,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nnopw   0x0(%rax,%rax,1)\nxor    %r14d,%r14d\njmp    5e <func0+0x5e>"
    },
    {
        "task_id": 19,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb0,%rsp\nmov    %rdi,-0xa8(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x90(%rbp)\n00 00 00 00\nmovq   $0x0,-0x88(%rbp)\n00 00 00 00\nmovq   $0x0,-0x80(%rbp)\n00\nmovq   $0x0,-0x78(%rbp)\n00\nmovq   $0x0,-0x70(%rbp)\n00\nlea    0x0(%rip),%rax\nmov    %rax,-0x60(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x58(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x50(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x48(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0xa0(%rbp)\n00 00 00\nmov    -0xa8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     1db <func0+0x1db>\nmovl   $0x0,-0x9c(%rbp)\n00 00 00\njmp    112 <func0+0x112>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x9c(%rbp),%eax\ncltq\nmov    %dl,-0xe(%rbp,%rax,1)\naddl   $0x1,-0x9c(%rbp)\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     146 <func0+0x146>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    e9 <func0+0xe9>\nmov    -0x9c(%rbp),%eax\ncltq\nmovb   $0x0,-0xe(%rbp,%rax,1)\nmovl   $0x0,-0x98(%rbp)\n00 00 00\njmp    1a9 <func0+0x1a9>\nmov    -0x98(%rbp),%eax\ncltq\nmov    -0x60(%rbp,%rax,8),%rdx\nlea    -0xe(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  17b <func0+0x17b>\ntest   %eax,%eax\njne    1a2 <func0+0x1a2>\nmov    -0x98(%rbp),%eax\ncltq\nmov    -0x90(%rbp,%rax,4),%eax\nlea    0x1(%rax),%edx\nmov    -0x98(%rbp),%eax\ncltq\nmov    %edx,-0x90(%rbp,%rax,4)\njmp    1b2 <func0+0x1b2>\naddl   $0x1,-0x98(%rbp)\ncmpl   $0x9,-0x98(%rbp)\njle    15f <func0+0x15f>\nmov    -0x9c(%rbp),%eax\ncltq\nadd    $0x1,%rax\nadd    %rax,-0xa8(%rbp)\nmov    -0xa8(%rbp),%rax\nsub    $0x1,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    dd <func0+0xdd>\nmovl   $0x0,-0x9c(%rbp)\n00 00 00\njmpq   2a4 <func0+0x2a4>\nmovl   $0x0,-0x98(%rbp)\n00 00 00\njmpq   282 <func0+0x282>\nmovl   $0x0,-0x94(%rbp)\n00 00 00\njmp    240 <func0+0x240>\nmov    -0x9c(%rbp),%eax\ncltq\nmov    -0x60(%rbp,%rax,8),%rdx\nmov    -0x94(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xa0(%rbp),%eax\ncltq\nlea    0x0(%rip),%rcx\nmov    %dl,(%rax,%rcx,1)\naddl   $0x1,-0x94(%rbp)\naddl   $0x1,-0xa0(%rbp)\nmov    -0x9c(%rbp),%eax\ncltq\nmov    -0x60(%rbp,%rax,8),%rdx\nmov    -0x94(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    205 <func0+0x205>\nmov    -0xa0(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xa0(%rbp)\ncltq\nlea    0x0(%rip),%rdx\nmovb   $0x20,(%rax,%rdx,1)\naddl   $0x1,-0x98(%rbp)\nmov    -0x9c(%rbp),%eax\ncltq\nmov    -0x90(%rbp,%rax,4),%eax\ncmp    %eax,-0x98(%rbp)\njl     1f9 <func0+0x1f9>\naddl   $0x1,-0x9c(%rbp)\ncmpl   $0x9,-0x9c(%rbp)\njle    1ea <func0+0x1ea>\ncmpl   $0x0,-0xa0(%rbp)\njle    2d2 <func0+0x2d2>\nmov    -0xa0(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x0(%rip),%rdx\nmovb   $0x0,(%rax,%rdx,1)\njmp    2d9 <func0+0x2d9>\nmovb   $0x0,0x0(%rip)\nlea    0x0(%rip),%rax\nmov    -0x8(%rbp),%rsi\nxor    %fs:0x28,%rsi\n00 00\nje     2f4 <func0+0x2f4>\ncallq  2f4 <func0+0x2f4>\nleaveq\nretq"
    },
    {
        "task_id": 19,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x98,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x88(%rsp)\n00\nxor    %eax,%eax\nmovq   $0x0,(%rsp)\n00\nmovq   $0x0,0x8(%rsp)\n00 00\nmovq   $0x0,0x10(%rsp)\n00 00\nmovq   $0x0,0x18(%rsp)\n00 00\nmovq   $0x0,0x20(%rsp)\n00 00\nlea    0x0(%rip),%rax\nmov    %rax,0x30(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x48(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x50(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x58(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x60(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x68(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x70(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x78(%rsp)\ncmpb   $0x0,(%rdi)\nje     15c <func0+0x15c>\nmov    %rdi,%rbp\nlea    0x81(%rsp),%r15\n00\nlea    0x82(%rsp),%r14\n00\njmp    10a <func0+0x10a>\nmov    $0x0,%ecx\nmov    $0x0,%r13d\njmp    12f <func0+0x12f>\nmovslq %ebx,%r12\naddl   $0x1,(%rsp,%r12,4)\nlea    0x1(%rbp,%r13,1),%rbp\ncmpb   $0x0,-0x1(%rbp)\nje     15c <func0+0x15c>\nmovzbl 0x0(%rbp),%edx\ntest   $0xdf,%dl\nje     ea <func0+0xea>\nmov    $0x1,%eax\nmov    %dl,(%r15,%rax,1)\nmov    %eax,%ecx\nmovzbl 0x0(%rbp,%rax,1),%edx\nmov    %rax,%r13\nadd    $0x1,%rax\ntest   $0xdf,%dl\njne    118 <func0+0x118>\nmovslq %ecx,%rcx\nmovb   $0x0,0x82(%rsp,%rcx,1)\n00\nmov    $0x0,%ebx\nmov    0x30(%rsp,%rbx,8),%rsi\nmov    %r14,%rdi\ncallq  14c <func0+0x14c>\ntest   %eax,%eax\nje     f7 <func0+0xf7>\nadd    $0x1,%rbx\ncmp    $0xa,%rbx\njne    13f <func0+0x13f>\njmp    ff <func0+0xff>\nmov    $0x0,%r13d\nmov    $0x0,%r8d\nlea    0x0(%rip),%rdi\nlea    0x1(%rdi),%r12\njmp    1c1 <func0+0x1c1>\nmov    %dl,(%rax,%rdi,1)\nmov    %eax,%ecx\nadd    $0x1,%rax\nmovzbl -0x1(%rsi,%rax,1),%edx\ntest   %dl,%dl\njne    175 <func0+0x175>\nlea    0x1(%rcx),%r8d\nmovslq %ecx,%rcx\nmovb   $0x20,(%r12,%rcx,1)\nadd    $0x1,%r9d\ncmp    %r10d,%r9d\nje     1b7 <func0+0x1b7>\nlea    0x1(%r8),%eax\ncltq\nmov    %ebp,%edx\nmovslq %r8d,%rcx\nmov    %rbx,%rsi\nsub    %rcx,%rsi\nmov    %r8d,%ecx\ntest   %r11b,%r11b\njne    175 <func0+0x175>\njmp    187 <func0+0x187>\nadd    $0x1,%r13\ncmp    $0xa,%r13\nje     1de <func0+0x1de>\nmov    (%rsp,%r13,4),%r10d\ntest   %r10d,%r10d\njle    1b7 <func0+0x1b7>\nmov    0x30(%rsp,%r13,8),%rbx\nmovzbl (%rbx),%r11d\nmov    $0x0,%r9d\nmov    %r11d,%ebp\njmp    19c <func0+0x19c>\ntest   %r8d,%r8d\njle    220 <func0+0x220>\nlea    -0x1(%r8),%eax\ncltq\nlea    0x0(%rip),%rdx\nmovb   $0x0,(%rdx,%rax,1)\nmov    0x88(%rsp),%rax\n00\nxor    %fs:0x28,%rax\n00 00\njne    229 <func0+0x229>\nlea    0x0(%rip),%rax\nadd    $0x98,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmovb   $0x0,0x0(%rip)\njmp    1f4 <func0+0x1f4>\ncallq  22e <.LC9+0x201>"
    },
    {
        "task_id": 19,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npxor   %xmm0,%xmm0\nxor    %r10d,%r10d\npush   %r14\nlea    0x0(%rip),%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xa8,%rsp\nmovzbl (%rdi),%edx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x98(%rsp)\n00\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %r14,0x40(%rsp)\nmov    %rax,0x48(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x50(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x58(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x60(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x68(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x70(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x78(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x80(%rsp)\n00\nlea    0x0(%rip),%rax\nmovq   $0x0,0x30(%rsp)\n00 00\nmov    %rax,0x88(%rsp)\n00\nmovaps %xmm0,0x10(%rsp)\nmovaps %xmm0,0x20(%rsp)\ntest   %dl,%dl\nje     16c <func0+0x16c>\nmov    %r14,0x8(%rsp)\nmov    %rdi,%rbx\nlea    0x92(%rsp),%r12\n00\nlea    0x91(%rsp),%r13\n00\ntest   $0xdf,%dl\nje     14f <func0+0x14f>\nmov    $0x1,%eax\nnopl   (%rax)\nmov    %dl,0x0(%r13,%rax,1)\nmovzbl (%rbx,%rax,1),%edx\nmovslq %eax,%rcx\nadd    $0x1,%rax\ntest   $0xdf,%dl\njne    f0 <func0+0xf0>\nmov    %rax,%rbp\nmovb   $0x0,0x92(%rsp,%rcx,1)\n00\nmov    0x8(%rsp),%rsi\nxor    %r14d,%r14d\njmp    125 <func0+0x125>\nnopw   0x0(%rax,%rax,1)\nmov    0x40(%rsp,%r14,8),%rsi\nmov    %r12,%rdi\nmovslq %r14d,%r15\ncallq  130 <func0+0x130>\ntest   %eax,%eax\nje     158 <func0+0x158>\nadd    $0x1,%r14\ncmp    $0xa,%r14\njne    120 <func0+0x120>\nadd    %rbp,%rbx\ncmpb   $0x0,-0x1(%rbx)\nje     167 <func0+0x167>\nmovzbl (%rbx),%edx\ntest   $0xdf,%dl\njne    e8 <func0+0xe8>\nmov    $0x1,%ebp\nxor    %ecx,%ecx\njmp    108 <func0+0x108>\nadd    %rbp,%rbx\naddl   $0x1,0x10(%rsp,%r15,4)\ncmpb   $0x0,-0x1(%rbx)\njne    147 <func0+0x147>\nmov    0x10(%rsp),%r10d\nlea    0x0(%rip),%r11\nxor    %ebp,%ebp\nxor    %esi,%esi\nlea    -0x1(%r11),%rdi\nnopl   0x0(%rax,%rax,1)\ntest   %r10d,%r10d\njle    1dc <func0+0x1dc>\nmov    0x40(%rsp,%rbp,2),%rbx\nxor    %r8d,%r8d\nmovzbl (%rbx),%r9d\nnopl   0x0(%rax)\nmovslq %esi,%rcx\ntest   %r9b,%r9b\nje     1cb <func0+0x1cb>\nlea    0x1(%rsi),%eax\nmov    %rbx,%rcx\nmovslq %esi,%rsi\nmov    %r9d,%edx\nsub    %rsi,%rcx\ncltq\nmov    %rcx,%rsi\nnopl   0x0(%rax)\nmov    %dl,(%rdi,%rax,1)\nmovslq %eax,%rcx\nadd    $0x1,%rax\nmovzbl -0x1(%rsi,%rax,1),%edx\ntest   %dl,%dl\njne    1b8 <func0+0x1b8>\nadd    $0x1,%r8d\nmovb   $0x20,(%r11,%rcx,1)\nlea    0x1(%rcx),%esi\ncmp    %r10d,%r8d\njne    198 <func0+0x198>\nadd    $0x4,%rbp\ncmp    $0x28,%rbp\nje     1ed <func0+0x1ed>\nmov    0x10(%rsp,%rbp,1),%r10d\njmp    180 <func0+0x180>\ntest   %esi,%esi\nje     227 <func0+0x227>\nlea    -0x1(%rsi),%eax\ncltq\nmovb   $0x0,(%r11,%rax,1)\nmov    0x98(%rsp),%rax\n00\nxor    %fs:0x28,%rax\n00 00\njne    230 <func0+0x230>\nadd    $0xa8,%rsp\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmovb   $0x0,0x0(%rip)\njmp    1fb <func0+0x1fb>\ncallq  235 <.LC9+0x208>"
    },
    {
        "task_id": 19,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npxor   %xmm0,%xmm0\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    0x0(%rip),%rbx\nsub    $0xd8,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xc8(%rsp)\n00\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmovaps %xmm0,0x40(%rsp)\nmovq   %rax,%xmm1\nmovaps %xmm0,0x50(%rsp)\nmovq   %rbx,%xmm0\nlea    0x0(%rip),%rax\npunpcklqdq %xmm1,%xmm0\nlea    0x0(%rip),%rbx\nmovq   %rax,%xmm2\nmovq   $0x0,0x60(%rsp)\n00 00\nmovaps %xmm0,0x70(%rsp)\nmovq   %rbx,%xmm0\nlea    0x0(%rip),%rax\nlea    0x0(%rip),%rbx\npunpcklqdq %xmm2,%xmm0\nmovq   %rax,%xmm3\nlea    0x0(%rip),%rax\nmovaps %xmm0,0x80(%rsp)\n00\nmovq   %rbx,%xmm0\nlea    0x0(%rip),%rbx\nmovq   %rax,%xmm4\npunpcklqdq %xmm3,%xmm0\nlea    0x0(%rip),%rax\nmovaps %xmm0,0x90(%rsp)\n00\nmovq   %rbx,%xmm0\nlea    0x0(%rip),%rbx\nmovq   %rax,%xmm5\npunpcklqdq %xmm4,%xmm0\nmovzbl (%rdi),%eax\nmovaps %xmm0,0xa0(%rsp)\n00\nmovq   %rbx,%xmm0\npunpcklqdq %xmm5,%xmm0\nmovaps %xmm0,0xb0(%rsp)\n00\ntest   %al,%al\nje     2f4 <func0+0x2f4>\nmov    0x88(%rsp),%rbx\n00\nmov    0x70(%rsp),%r13\nmov    %rdi,%rbp\nmov    0x78(%rsp),%r15\nmov    0x80(%rsp),%r14\n00\nmov    %rbx,0x8(%rsp)\nmov    0x90(%rsp),%rbx\n00\nmov    %rbx,0x18(%rsp)\nmov    0x98(%rsp),%rbx\n00\nmov    %rbx,0x10(%rsp)\nmov    0xa0(%rsp),%rbx\n00\nmov    %rbx,0x28(%rsp)\nmov    0xa8(%rsp),%rbx\n00\nmov    %rbx,0x20(%rsp)\nmov    0xb0(%rsp),%rbx\n00\nmov    %rbx,0x38(%rsp)\nmov    0xb8(%rsp),%rbx\n00\nmov    %rbx,0x30(%rsp)\nlea    0xc2(%rsp),%rbx\n00\njmpq   2ca <func0+0x2ca>\nmov    %al,0xc2(%rsp)\nmovzbl 0x1(%rbp),%eax\ntest   $0xdf,%al\nje     3b2 <func0+0x3b2>\nmov    %al,0xc3(%rsp)\nmovzbl 0x2(%rbp),%eax\ntest   $0xdf,%al\nje     3c2 <func0+0x3c2>\nmov    %al,0xc4(%rsp)\nmovzbl 0x3(%rbp),%eax\ntest   $0xdf,%al\nje     3db <func0+0x3db>\nmov    %al,0xc5(%rsp)\nmovzbl 0x4(%rbp),%eax\ntest   $0xdf,%al\nje     3eb <func0+0x3eb>\nmov    %al,0xc6(%rsp)\nmovzbl 0x5(%rbp),%eax\ntest   $0xdf,%al\nje     3fb <func0+0x3fb>\nmov    %al,0xc7(%rsp)\nmov    $0x6,%r12d\nmov    $0x6,%eax\nadd    $0x1,%r12\nmov    %r13,%rsi\nmov    %rbx,%rdi\nmovb   $0x0,0xc2(%rsp,%rax,1)\n00\ncallq  200 <func0+0x200>\ntest   %eax,%eax\nje     2e4 <func0+0x2e4>\nmov    %r15,%rsi\nmov    %rbx,%rdi\ncallq  213 <func0+0x213>\ntest   %eax,%eax\nje     40b <func0+0x40b>\nmov    %r14,%rsi\nmov    %rbx,%rdi\ncallq  226 <func0+0x226>\ntest   %eax,%eax\nje     42d <func0+0x42d>\nmov    0x8(%rsp),%rsi\nmov    %rbx,%rdi\ncallq  23b <func0+0x23b>\ntest   %eax,%eax\nje     41c <func0+0x41c>\nmov    0x18(%rsp),%rsi\nmov    %rbx,%rdi\ncallq  250 <func0+0x250>\ntest   %eax,%eax\nje     44f <func0+0x44f>\nmov    0x10(%rsp),%rsi\nmov    %rbx,%rdi\ncallq  265 <func0+0x265>\ntest   %eax,%eax\nje     43e <func0+0x43e>\nmov    0x28(%rsp),%rsi\nmov    %rbx,%rdi\ncallq  27a <func0+0x27a>\ntest   %eax,%eax\nje     471 <func0+0x471>\nmov    0x20(%rsp),%rsi\nmov    %rbx,%rdi\ncallq  28f <func0+0x28f>\ntest   %eax,%eax\nje     482 <func0+0x482>\nmov    0x38(%rsp),%rsi\nmov    %rbx,%rdi\ncallq  2a4 <func0+0x2a4>\ntest   %eax,%eax\nje     2df <func0+0x2df>\nmov    0x30(%rsp),%rsi\nmov    %rbx,%rdi\ncallq  2b5 <func0+0x2b5>\ntest   %eax,%eax\nje     460 <func0+0x460>\nadd    %r12,%rbp\ncmpb   $0x0,-0x1(%rbp)\nje     2f4 <func0+0x2f4>\nmovzbl 0x0(%rbp),%eax\ntest   $0xdf,%al\njne    178 <func0+0x178>\nmov    $0x1,%r12d\nxor    %eax,%eax\njmpq   1ed <func0+0x1ed>\nmov    $0x8,%eax\ncltq\naddl   $0x1,0x40(%rsp,%rax,4)\nadd    %r12,%rbp\ncmpb   $0x0,-0x1(%rbp)\njne    2c6 <func0+0x2c6>\nlea    0x0(%rip),%rbx\nxor    %ebp,%ebp\nlea    0x40(%rsp),%r12\nxor    %esi,%esi\nlea    -0x1(%rbx),%rdi\nnopl   0x0(%rax,%rax,1)\n00\nmov    (%r12,%rbp,4),%r10d\ntest   %r10d,%r10d\njle    36b <func0+0x36b>\nmov    0x70(%rsp,%rbp,8),%r11\nxor    %r8d,%r8d\nmovzbl (%r11),%r9d\nnopl   (%rax)\nmovslq %esi,%rcx\ntest   %r9b,%r9b\nje     35b <func0+0x35b>\nlea    0x1(%rsi),%eax\nmov    %r11,%rcx\nmovslq %esi,%rsi\nmov    %r9d,%edx\nsub    %rsi,%rcx\ncltq\nmov    %rcx,%rsi\nnopl   0x0(%rax)\nmov    %dl,(%rdi,%rax,1)\nmovslq %eax,%rcx\nadd    $0x1,%rax\nmovzbl -0x1(%rsi,%rax,1),%edx\ntest   %dl,%dl\njne    348 <func0+0x348>\nadd    $0x1,%r8d\nmovb   $0x20,(%rbx,%rcx,1)\nlea    0x1(%rcx),%esi\ncmp    %r8d,%r10d\njne    328 <func0+0x328>\nadd    $0x1,%rbp\ncmp    $0xa,%rbp\njne    310 <func0+0x310>\ntest   %esi,%esi\nje     3d2 <func0+0x3d2>\nlea    -0x1(%rsi),%eax\ncltq\nmovb   $0x0,(%rbx,%rax,1)\nmov    0xc8(%rsp),%rax\n00\nxor    %fs:0x28,%rax\n00 00\njne    493 <func0+0x493>\nadd    $0xd8,%rsp\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    $0x1,%eax\nmov    $0x1,%r12d\njmpq   1e9 <func0+0x1e9>\nmov    $0x2,%eax\nmov    $0x2,%r12d\njmpq   1e9 <func0+0x1e9>\nmovb   $0x0,0x0(%rip)\njmp    382 <func0+0x382>\nmov    $0x3,%eax\nmov    $0x3,%r12d\njmpq   1e9 <func0+0x1e9>\nmov    $0x4,%eax\nmov    $0x4,%r12d\njmpq   1e9 <func0+0x1e9>\nmov    $0x5,%eax\nmov    $0x5,%r12d\njmpq   1e9 <func0+0x1e9>\nmov    $0x1,%eax\ncltq\naddl   $0x1,0x40(%rsp,%rax,4)\njmpq   2eb <func0+0x2eb>\nmov    $0x3,%eax\ncltq\naddl   $0x1,0x40(%rsp,%rax,4)\njmpq   2eb <func0+0x2eb>\nmov    $0x2,%eax\ncltq\naddl   $0x1,0x40(%rsp,%rax,4)\njmpq   2eb <func0+0x2eb>\nmov    $0x5,%eax\ncltq\naddl   $0x1,0x40(%rsp,%rax,4)\njmpq   2eb <func0+0x2eb>\nmov    $0x4,%eax\ncltq\naddl   $0x1,0x40(%rsp,%rax,4)\njmpq   2eb <func0+0x2eb>\nmov    $0x9,%eax\ncltq\naddl   $0x1,0x40(%rsp,%rax,4)\njmpq   2eb <func0+0x2eb>\nmov    $0x6,%eax\ncltq\naddl   $0x1,0x40(%rsp,%rax,4)\njmpq   2eb <func0+0x2eb>\nmov    $0x7,%eax\ncltq\naddl   $0x1,0x40(%rsp,%rax,4)\njmpq   2eb <func0+0x2eb>\ncallq  498 <.LC9+0x46b>"
    },
    {
        "task_id": 20,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovss  0x0(%rip),%xmm0\n00\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x38(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x38(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x28(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmovss  %xmm0,(%rdx)\nmovl   $0x0,-0x10(%rbp)\njmpq   110 <func0+0x110>\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmpq   100 <func0+0x100>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nsubss  %xmm1,%xmm0\nmovss  0x0(%rip),%xmm1\n00\nandps  %xmm1,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x14(%rbp),%xmm0\ncomiss -0x4(%rbp),%xmm0\njbe    fc <func0+0xfc>\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x38(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     5f <func0+0x5f>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     51 <func0+0x51>\nmov    -0x38(%rbp),%rax\nmovss  (%rax),%xmm0\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmovss  (%rax),%xmm1\ncomiss %xmm1,%xmm0\nja     137 <func0+0x137>\njmp    166 <func0+0x166>\nmov    -0x38(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x38(%rbp),%rax\nmovss  0x4(%rax),%xmm0\nmov    -0x38(%rbp),%rax\nmovss  %xmm0,(%rax)\nmov    -0x38(%rbp),%rax\nadd    $0x4,%rax\nmovss  -0x8(%rbp),%xmm0\nmovss  %xmm0,(%rax)\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 20,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovss  (%rdi),%xmm0\nmovss  %xmm0,(%rdx)\nmovss  0x4(%rdi),%xmm0\nmovss  %xmm0,0x4(%rdx)\ntest   %esi,%esi\njle    7e <func0+0x7e>\nmov    %rdi,%rcx\nlea    -0x1(%rsi),%r9d\nadd    $0x1,%r9\nmov    $0x1,%r8d\nmovss  0x0(%rip),%xmm2\n00\nmovss  0x0(%rip),%xmm3\n00\njmp    74 <func0+0x74>\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    6c <func0+0x6c>\nmovss  (%rcx),%xmm1\nmovaps %xmm1,%xmm0\nsubss  (%rdi,%rax,4),%xmm0\nandps  %xmm3,%xmm0\ncomiss %xmm0,%xmm2\njbe    3d <func0+0x3d>\nmovss  %xmm1,(%rdx)\nmovss  (%rdi,%rax,4),%xmm1\nmovss  %xmm1,0x4(%rdx)\nmovaps %xmm0,%xmm2\njmp    3d <func0+0x3d>\nadd    $0x1,%r8\nadd    $0x4,%rcx\ncmp    %r9,%r8\nje     7e <func0+0x7e>\nmov    %r8,%rax\njmp    45 <func0+0x45>\nmovss  (%rdx),%xmm0\nmovss  0x4(%rdx),%xmm1\ncomiss %xmm1,%xmm0\njbe    95 <func0+0x95>\nmovss  %xmm1,(%rdx)\nmovss  %xmm0,0x4(%rdx)\nretq"
    },
    {
        "task_id": 20,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovss  (%rdi),%xmm0\nmovss  %xmm0,(%rdx)\nmovss  0x4(%rdi),%xmm1\nmovss  %xmm1,0x4(%rdx)\ntest   %esi,%esi\njle    8b <func0+0x8b>\nlea    -0x1(%rsi),%r9d\nmov    $0x1,%r8d\nmov    %rdi,%rcx\nmovss  0x0(%rip),%xmm2\n00\nadd    $0x1,%r9\nmovss  0x0(%rip),%xmm3\n00\ncmp    %r8,%r9\nje     82 <func0+0x82>\nmov    %r8,%rax\nnopl   0x0(%rax,%rax,1)\nmovss  (%rcx),%xmm1\nmovaps %xmm1,%xmm0\nsubss  (%rdi,%rax,4),%xmm0\nandps  %xmm3,%xmm0\ncomiss %xmm0,%xmm2\njbe    6d <func0+0x6d>\nmovss  %xmm1,(%rdx)\nmovss  (%rdi,%rax,4),%xmm1\nmovaps %xmm0,%xmm2\nmovss  %xmm1,0x4(%rdx)\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     48 <func0+0x48>\nadd    $0x1,%r8\nadd    $0x4,%rcx\ncmp    %r8,%r9\njne    40 <func0+0x40>\nmovss  (%rdx),%xmm0\nmovss  0x4(%rdx),%xmm1\ncomiss %xmm1,%xmm0\njbe    99 <func0+0x99>\nmovss  %xmm1,(%rdx)\nmovss  %xmm0,0x4(%rdx)\nretq"
    },
    {
        "task_id": 20,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovss  (%rdi),%xmm0\nmovss  %xmm0,(%rdx)\nmovss  0x4(%rdi),%xmm1\nmovss  %xmm1,0x4(%rdx)\ntest   %esi,%esi\njle    8b <func0+0x8b>\ncmp    $0x1,%esi\nje     82 <func0+0x82>\nlea    -0x2(%rsi),%r9d\nmov    %rdi,%rcx\nmovss  0x0(%rip),%xmm2\n00\nmov    $0x1,%r8d\nadd    $0x2,%r9\nmovss  0x0(%rip),%xmm3\n00\nmov    %r8,%rax\nnopl   0x0(%rax,%rax,1)\nmovss  (%rcx),%xmm1\nmovaps %xmm1,%xmm0\nsubss  (%rdi,%rax,4),%xmm0\nandps  %xmm3,%xmm0\ncomiss %xmm0,%xmm2\njbe    6d <func0+0x6d>\nmovss  %xmm1,(%rdx)\nmovss  (%rdi,%rax,4),%xmm1\nmovaps %xmm0,%xmm2\nmovss  %xmm1,0x4(%rdx)\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     48 <func0+0x48>\nadd    $0x1,%r8\nadd    $0x4,%rcx\ncmp    %r8,%r9\njne    40 <func0+0x40>\nmovss  (%rdx),%xmm0\nmovss  0x4(%rdx),%xmm1\ncomiss %xmm1,%xmm0\njbe    99 <func0+0x99>\nmovss  %xmm1,(%rdx)\nmovss  %xmm0,0x4(%rdx)\nretq"
    },
    {
        "task_id": 21,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovl   $0x1,-0x8(%rbp)\njmp    b0 <func0+0xb0>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nmovss  -0x10(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njbe    71 <func0+0x71>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x10(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncomiss -0xc(%rbp),%xmm0\njbe    ac <func0+0xac>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     32 <func0+0x32>\nmovl   $0x0,-0x4(%rbp)\njmp    10c <func0+0x10c>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nsubss  -0x10(%rbp),%xmm0\nmovss  -0xc(%rbp),%xmm1\nsubss  -0x10(%rbp),%xmm1\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\ndivss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     c5 <func0+0xc5>\nnop\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 21,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovss  (%rdi),%xmm1\ncmp    $0x1,%esi\njle    5e <func0+0x5e>\nlea    0x4(%rdi),%rax\nlea    -0x2(%rsi),%edx\nlea    0x8(%rdi,%rdx,4),%rdx\nmovaps %xmm1,%xmm0\nmovss  (%rax),%xmm2\nmovaps %xmm2,%xmm3\nminss  %xmm1,%xmm3\nmovaps %xmm3,%xmm1\nmaxss  %xmm0,%xmm2\nmovaps %xmm2,%xmm0\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    1c <func0+0x1c>\nmov    $0x0,%eax\nsubss  %xmm3,%xmm2\nmovss  (%rdi,%rax,4),%xmm0\nsubss  %xmm1,%xmm0\ndivss  %xmm2,%xmm0\nmovss  %xmm0,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     43 <func0+0x43>\nretq\nje     61 <func0+0x61>\nretq\nmovss  (%rdi),%xmm0\nsubss  %xmm1,%xmm0\nsubss  %xmm1,%xmm1\ndivss  %xmm1,%xmm0\nmovss  %xmm0,(%rdi)\njmp    60 <func0+0x60>"
    },
    {
        "task_id": 21,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovss  (%rdi),%xmm0\ncmp    $0x1,%esi\njle    70 <func0+0x70>\nlea    -0x2(%rsi),%edx\nlea    0x4(%rdi),%rax\nmovaps %xmm0,%xmm1\nlea    0x8(%rdi,%rdx,4),%rdx\nmovaps %xmm0,%xmm2\nnop\nmovss  (%rax),%xmm3\nadd    $0x4,%rax\nmovaps %xmm3,%xmm4\nmaxss  %xmm1,%xmm3\nminss  %xmm2,%xmm4\nmovaps %xmm3,%xmm1\nmovaps %xmm4,%xmm2\ncmp    %rdx,%rax\njne    20 <func0+0x20>\nsubss  %xmm2,%xmm1\nxor    %eax,%eax\njmp    55 <func0+0x55>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmovss  (%rdi,%rax,4),%xmm0\nsubss  %xmm2,%xmm0\ndivss  %xmm1,%xmm0\nmovss  %xmm0,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     50 <func0+0x50>\nretq\nnopl   0x0(%rax,%rax,1)\njne    6a <func0+0x6a>\nmovaps %xmm0,%xmm1\nmovaps %xmm0,%xmm2\njmp    3e <func0+0x3e>"
    },
    {
        "task_id": 21,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovss  (%rdi),%xmm1\ncmp    $0x1,%esi\njle    f0 <func0+0xf0>\nlea    -0x2(%rsi),%edx\nlea    0x4(%rdi),%rax\nmovaps %xmm1,%xmm2\nlea    0x8(%rdi,%rdx,4),%rdx\nmovss  (%rax),%xmm0\nadd    $0x4,%rax\nmovaps %xmm0,%xmm5\nmaxss  %xmm2,%xmm0\nminss  %xmm1,%xmm5\nmovaps %xmm0,%xmm2\nmovaps %xmm5,%xmm1\ncmp    %rdx,%rax\njne    20 <func0+0x20>\ntest   %esi,%esi\nmov    $0x1,%ecx\nsubss  %xmm5,%xmm2\ncmovg  %esi,%ecx\ncmp    $0x3,%esi\njle    f3 <func0+0xf3>\nmov    %ecx,%edx\nmovaps %xmm5,%xmm4\nmov    %rdi,%rax\nshr    $0x2,%edx\nmovaps %xmm2,%xmm3\nshufps $0x0,%xmm4,%xmm4\nshl    $0x4,%rdx\nshufps $0x0,%xmm3,%xmm3\nadd    %rdi,%rdx\nnopw   0x0(%rax,%rax,1)\nmovups (%rax),%xmm0\nadd    $0x10,%rax\nsubps  %xmm4,%xmm0\ndivps  %xmm3,%xmm0\nmovups %xmm0,-0x10(%rax)\ncmp    %rdx,%rax\njne    78 <func0+0x78>\nmov    %ecx,%eax\nand    $0xfffffffc,%eax\nand    $0x3,%ecx\nje     f2 <func0+0xf2>\nmovslq %eax,%rdx\nadd    $0x1,%eax\nlea    (%rdi,%rdx,4),%rdx\nmovss  (%rdx),%xmm0\nsubss  %xmm1,%xmm0\ndivss  %xmm2,%xmm0\nmovss  %xmm0,(%rdx)\ncmp    %eax,%esi\njle    f2 <func0+0xf2>\nmovslq %eax,%rdx\nadd    $0x1,%eax\nlea    (%rdi,%rdx,4),%rdx\nmovss  (%rdx),%xmm0\nsubss  %xmm1,%xmm0\ndivss  %xmm2,%xmm0\nmovss  %xmm0,(%rdx)\ncmp    %esi,%eax\njge    f2 <func0+0xf2>\ncltq\nlea    (%rdi,%rax,4),%rax\nmovss  (%rax),%xmm0\nsubss  %xmm1,%xmm0\ndivss  %xmm2,%xmm0\nmovss  %xmm0,(%rax)\nretq\nnopl   0x0(%rax,%rax,1)\nje     10a <func0+0x10a>\nretq\nmovss  (%rdi),%xmm0\nmov    $0x1,%eax\nsubss  %xmm5,%xmm0\ndivss  %xmm2,%xmm0\nmovss  %xmm0,(%rdi)\njmp    b6 <func0+0xb6>\nsubss  %xmm1,%xmm1\ndivss  %xmm1,%xmm1\nmovss  %xmm1,(%rdi)\nretq"
    },
    {
        "task_id": 22,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x20(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x10(%rbp)\njmpq   110 <func0+0x110>\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     7a <func0+0x7a>\ncallq  4c <func0+0x4c>\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x800,%eax\ntest   %eax,%eax\njne    7a <func0+0x7a>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\njne    37 <func0+0x37>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     121 <func0+0x121>\nlea    -0x18(%rbp),%rcx\nmov    -0x10(%rbp),%rax\nmov    $0xa,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncallq  a1 <func0+0xa1>\nmov    %eax,-0x1c(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    %rax,-0x10(%rbp)\nje     f2 <func0+0xf2>\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x2c,%al\nje     c4 <func0+0xc4>\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    f2 <func0+0xf2>\nmov    -0x20(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x20(%rbp)\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nlea    0x0(%rip),%rdx\nmov    -0x1c(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\njmp    108 <func0+0x108>\nmov    -0x18(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     108 <func0+0x108>\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x2c,%al\njne    e6 <func0+0xe6>\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    3c <func0+0x3c>\njmp    122 <func0+0x122>\nnop\nmov    -0x30(%rbp),%rax\nmov    -0x20(%rbp),%edx\nmov    %edx,(%rax)\nlea    0x0(%rip),%rax\nmov    -0x8(%rbp),%rsi\nxor    %fs:0x28,%rsi\n00 00\nje     146 <func0+0x146>\ncallq  146 <func0+0x146>\nleaveq\nretq"
    },
    {
        "task_id": 22,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,%r15\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmovzbl (%rdi),%ebx\nmov    $0x0,%r13d\ntest   %bl,%bl\nje     ae <func0+0xae>\nmov    %rdi,%rbp\ncallq  3a <func0+0x3a>\nmov    %rax,%r12\nmov    $0x0,%r13d\nlea    0x0(%rip),%r14\njmp    8e <func0+0x8e>\ntest   %bl,%bl\nje     ae <func0+0xae>\nmov    %rsp,%rsi\nmov    $0xa,%edx\nmov    %rbp,%rdi\ncallq  60 <func0+0x60>\nmov    (%rsp),%rdx\ncmp    %rbp,%rdx\nje     d7 <func0+0xd7>\nmovzbl (%rdx),%ecx\ncmp    $0x2c,%cl\nje     75 <func0+0x75>\ntest   %cl,%cl\njne    e3 <func0+0xe3>\nmovslq %r13d,%rdx\nmov    %eax,(%r14,%rdx,4)\nlea    0x1(%r13),%r13d\nmov    (%rsp),%rax\nmovzbl (%rax),%ebx\ntest   %bl,%bl\nje     ae <func0+0xae>\nmov    %rax,%rbp\nmovsbq %bl,%rax\nmov    (%r12),%rdx\ntestb  $0x8,0x1(%rdx,%rax,2)\njne    4c <func0+0x4c>\ncmp    $0x2d,%bl\nje     4c <func0+0x4c>\nlea    0x1(%rbp),%rax\nmovzbl 0x1(%rbp),%ebx\ntest   %bl,%bl\njne    8b <func0+0x8b>\nmov    %r13d,(%r15)\nmov    0x8(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    fd <func0+0xfd>\nlea    0x0(%rip),%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmovzbl 0x0(%rbp),%eax\ntest   %al,%al\nje     80 <func0+0x80>\ncmp    $0x2c,%al\nje     80 <func0+0x80>\nlea    0x1(%rdx),%rax\nmov    %rax,(%rsp)\nmovzbl (%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\nje     80 <func0+0x80>\ncmp    $0x2c,%dl\njne    e7 <func0+0xe7>\njmp    80 <func0+0x80>\ncallq  102 <func0+0x102>"
    },
    {
        "task_id": 22,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nxor    %r15d,%r15d\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovzbl (%rdi),%ebx\nmov    %rsi,0x8(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ntest   %bl,%bl\nje     e8 <func0+0xe8>\nmov    %rdi,%rbp\nxor    %r15d,%r15d\nlea    0x10(%rsp),%r13\ncallq  45 <func0+0x45>\nlea    0x0(%rip),%r14\nmov    (%rax),%rcx\nmov    %rax,%r12\njmp    6c <func0+0x6c>\nnopl   0x0(%rax)\ncmp    $0x2d,%bl\nje     77 <func0+0x77>\nmovzbl 0x1(%rbp),%ebx\nlea    0x1(%rbp),%rdx\ntest   %bl,%bl\nje     e8 <func0+0xe8>\nmov    %rdx,%rbp\nmovsbq %bl,%rax\ntestb  $0x8,0x1(%rcx,%rax,2)\nje     58 <func0+0x58>\nmov    $0xa,%edx\nmov    %r13,%rsi\nmov    %rbp,%rdi\ncallq  87 <func0+0x87>\nmov    0x10(%rsp),%rdx\ncmp    %rbp,%rdx\nje     b8 <func0+0xb8>\nmovzbl (%rdx),%ecx\ncmp    $0x2c,%cl\nje     9d <func0+0x9d>\ntest   %cl,%cl\njne    c5 <func0+0xc5>\nmovslq %r15d,%rcx\nadd    $0x1,%r15d\nmov    %eax,(%r14,%rcx,4)\nmovzbl (%rdx),%ebx\ntest   %bl,%bl\nje     e8 <func0+0xe8>\nmov    (%r12),%rcx\njmp    69 <func0+0x69>\nnopl   (%rax)\nmovzbl 0x0(%rbp),%ebx\ncmp    $0x2c,%bl\nje     116 <func0+0x116>\ntest   %bl,%bl\nje     116 <func0+0x116>\nlea    0x1(%rdx),%rax\njmp    d5 <func0+0xd5>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x2c,%bl\nje     ab <func0+0xab>\nmov    %rax,0x10(%rsp)\nmovzbl (%rax),%ebx\nmov    %rax,%rdx\nadd    $0x1,%rax\ntest   %bl,%bl\njne    d0 <func0+0xd0>\nmov    0x8(%rsp),%rax\nmov    %r15d,(%rax)\nmov    0x18(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    11b <func0+0x11b>\nadd    $0x28,%rsp\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    %rbp,%rdx\njmp    ab <func0+0xab>\ncallq  120 <func0+0x120>"
    },
    {
        "task_id": 22,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nxor    %r15d,%r15d\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovzbl (%rdi),%ebx\nmov    %rsi,0x8(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ntest   %bl,%bl\nje     e8 <func0+0xe8>\nmov    %rdi,%rbp\nxor    %r15d,%r15d\nlea    0x10(%rsp),%r13\ncallq  45 <func0+0x45>\nlea    0x0(%rip),%r14\nmov    (%rax),%rcx\nmov    %rax,%r12\njmp    6c <func0+0x6c>\nnopl   0x0(%rax)\ncmp    $0x2d,%bl\nje     77 <func0+0x77>\nmovzbl 0x1(%rbp),%ebx\nlea    0x1(%rbp),%rdx\ntest   %bl,%bl\nje     e8 <func0+0xe8>\nmov    %rdx,%rbp\nmovsbq %bl,%rax\ntestb  $0x8,0x1(%rcx,%rax,2)\nje     58 <func0+0x58>\nmov    $0xa,%edx\nmov    %r13,%rsi\nmov    %rbp,%rdi\ncallq  87 <func0+0x87>\nmov    0x10(%rsp),%rdx\ncmp    %rbp,%rdx\nje     b8 <func0+0xb8>\nmovzbl (%rdx),%ecx\ncmp    $0x2c,%cl\nje     9d <func0+0x9d>\ntest   %cl,%cl\njne    c5 <func0+0xc5>\nmovslq %r15d,%rcx\nadd    $0x1,%r15d\nmov    %eax,(%r14,%rcx,4)\nmovzbl (%rdx),%ebx\ntest   %bl,%bl\nje     e8 <func0+0xe8>\nmov    (%r12),%rcx\njmp    69 <func0+0x69>\nnopl   (%rax)\nmovzbl 0x0(%rbp),%ebx\ncmp    $0x2c,%bl\nje     116 <func0+0x116>\ntest   %bl,%bl\nje     116 <func0+0x116>\nlea    0x1(%rdx),%rax\njmp    d5 <func0+0xd5>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x2c,%bl\nje     ab <func0+0xab>\nmov    %rax,0x10(%rsp)\nmovzbl (%rax),%ebx\nmov    %rax,%rdx\nadd    $0x1,%rax\ntest   %bl,%bl\njne    d0 <func0+0xd0>\nmov    0x8(%rsp),%rax\nmov    %r15d,(%rax)\nmov    0x18(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    11b <func0+0x11b>\nadd    $0x28,%rsp\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    %rbp,%rdx\njmp    ab <func0+0xab>\ncallq  120 <func0+0x120>"
    },
    {
        "task_id": 23,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    19 <func0+0x19>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    15 <func0+0x15>\nmov    -0x4(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 23,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmpb   $0x0,(%rdi)\nje     1e <func0+0x1e>\nmov    $0x1,%eax\nmov    %eax,%edx\nadd    $0x1,%rax\ncmpb   $0x0,-0x1(%rdi,%rax,1)\njne    e <func0+0xe>\nmov    %edx,%eax\nretq\nmov    $0x0,%edx\njmp    1b <func0+0x1b>"
    },
    {
        "task_id": 23,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmpb   $0x0,(%rdi)\nje     28 <func0+0x28>\nmov    $0x1,%eax\nxchg   %ax,%ax\nmov    %eax,%r8d\nadd    $0x1,%rax\ncmpb   $0x0,-0x1(%rdi,%rax,1)\njne    10 <func0+0x10>\nmov    %r8d,%eax\nretq\nnopw   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 23,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmpb   $0x0,(%rdi)\nje     28 <func0+0x28>\nmov    $0x1,%eax\nxchg   %ax,%ax\nmov    %eax,%r8d\nadd    $0x1,%rax\ncmpb   $0x0,-0x1(%rdi,%rax,1)\njne    10 <func0+0x10>\nmov    %r8d,%eax\nretq\nnopw   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 24,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x2,-0x4(%rbp)\njmp    2e <func0+0x2e>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    2a <func0+0x2a>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\njmp    3e <func0+0x3e>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    14 <func0+0x14>\nmov    $0x1,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 24,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x3,%edi\njle    3c <func0+0x3c>\ntest   $0x1,%dil\nje     2f <func0+0x2f>\nmov    $0x2,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njg     36 <func0+0x36>\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    14 <func0+0x14>\nmov    %edi,%eax\ncltd\nidiv   %ecx\nretq\nmov    $0x2,%ecx\njmp    29 <func0+0x29>\nmov    $0x1,%eax\nretq\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 24,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x3,%edi\njle    35 <func0+0x35>\nmov    $0x2,%ecx\ntest   $0x1,%dil\njne    29 <func0+0x29>\njmp    40 <func0+0x40>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     40 <func0+0x40>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njle    20 <func0+0x20>\nmov    $0x1,%eax\nretq\nnopl   0x0(%rax,%rax,1)\nmov    %edi,%eax\ncltd\nidiv   %ecx\nretq"
    },
    {
        "task_id": 24,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x3,%edi\njle    35 <func0+0x35>\nmov    $0x2,%ecx\ntest   $0x1,%dil\njne    29 <func0+0x29>\njmp    40 <func0+0x40>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     40 <func0+0x40>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njle    20 <func0+0x20>\nmov    $0x1,%eax\nretq\nnopl   0x0(%rax,%rax,1)\nmov    %edi,%eax\ncltd\nidiv   %ecx\nretq"
    },
    {
        "task_id": 25,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    $0x100,%edi\ncallq  1d <func0+0x1d>\nmov    %rax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x2,-0xc(%rbp)\njmp    74 <func0+0x74>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %eax,-0x14(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%ecx\nmov    -0x20(%rbp),%rdx\nmov    %ecx,(%rdx)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\nje     34 <func0+0x34>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    63 <func0+0x63>\ncmpl   $0x1,-0x14(%rbp)\njle    aa <func0+0xaa>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%ecx\nmov    -0x20(%rbp),%rdx\nmov    %ecx,(%rdx)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 25,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %edi,%ebx\nmov    %rsi,%rbp\nmov    $0x100,%edi\ncallq  19 <func0+0x19>\nmov    %rax,%r8\nmovl   $0x0,0x0(%rbp)\nmov    $0x2,%ecx\ncmp    $0x3,%ebx\njg     7c <func0+0x7c>\ncmp    $0x1,%ebx\njle    41 <func0+0x41>\nmov    0x0(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x0(%rbp)\ncltq\nmov    %ebx,(%r8,%rax,4)\nmov    %r8,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq\nmov    0x0(%rbp),%eax\nlea    0x1(%rax),%esi\nmovslq %esi,%rsi\nmov    %ebx,%eax\ncltd\nidiv   %ecx\nmov    %eax,%ebx\nmov    %esi,%edi\nmov    %ecx,-0x4(%r8,%rsi,4)\nadd    $0x1,%rsi\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     54 <func0+0x54>\nmov    %edi,0x0(%rbp)\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebx,%eax\njg     2d <func0+0x2d>\nmov    %ebx,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     4b <func0+0x4b>\njmp    70 <func0+0x70>"
    },
    {
        "task_id": 25,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmov    %edi,%ebx\nmov    $0x100,%edi\nsub    $0x8,%rsp\ncallq  19 <func0+0x19>\nmovl   $0x0,0x0(%rbp)\nmov    $0x2,%ecx\nmov    %rax,%r9\ncmp    $0x3,%ebx\njle    72 <func0+0x72>\nnopl   (%rax)\nmov    %ebx,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    66 <func0+0x66>\nmov    0x0(%rbp),%eax\nlea    0x1(%rax),%edi\nmovslq %edi,%rdi\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%eax\nmov    %ecx,-0x4(%r9,%rdi,4)\nmov    %edi,%r8d\nadd    $0x1,%rdi\ncltd\nidiv   %ecx\ncltd\nmov    %eax,%ebx\nidiv   %ecx\ntest   %edx,%edx\nje     48 <func0+0x48>\nmov    %r8d,0x0(%rbp)\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebx,%eax\njle    30 <func0+0x30>\ncmp    $0x1,%ebx\njle    85 <func0+0x85>\nmovslq 0x0(%rbp),%rax\nlea    0x1(%rax),%edx\nmov    %ebx,(%r9,%rax,4)\nmov    %edx,0x0(%rbp)\nadd    $0x8,%rsp\nmov    %r9,%rax\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 25,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmov    %edi,%ebx\nmov    $0x100,%edi\nsub    $0x8,%rsp\ncallq  19 <func0+0x19>\nmovl   $0x0,0x0(%rbp)\nmov    $0x2,%ecx\nmov    %rax,%r9\ncmp    $0x3,%ebx\njle    72 <func0+0x72>\nnopl   (%rax)\nmov    %ebx,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    66 <func0+0x66>\nmov    0x0(%rbp),%eax\nlea    0x1(%rax),%edi\nmovslq %edi,%rdi\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%eax\nmov    %ecx,-0x4(%r9,%rdi,4)\nmov    %edi,%r8d\nadd    $0x1,%rdi\ncltd\nidiv   %ecx\ncltd\nmov    %eax,%ebx\nidiv   %ecx\ntest   %edx,%edx\nje     48 <func0+0x48>\nmov    %r8d,0x0(%rbp)\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebx,%eax\njle    30 <func0+0x30>\ncmp    $0x1,%ebx\njle    85 <func0+0x85>\nmovslq 0x0(%rbp),%rax\nlea    0x1(%rax),%edx\nmov    %ebx,(%r9,%rax,4)\nmov    %edx,0x0(%rbp)\nadd    $0x8,%rsp\nmov    %r9,%rax\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 26,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (int[]){}, 0));\n    free(result);\n\n    result = func0((int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %esi,-0x5c(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    -0x5c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  28 <func0+0x28>\nmov    %rax,-0x18(%rbp)\nmov    -0x5c(%rbp),%eax\ncltq\nmov    $0x4,%esi\nmov    %rax,%rdi\ncallq  3e <func0+0x3e>\nmov    %rax,-0x10(%rbp)\nmov    -0x5c(%rbp),%eax\ncltq\nmov    $0x4,%esi\nmov    %rax,%rdi\ncallq  54 <func0+0x54>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x4c(%rbp)\nmovl   $0x0,-0x48(%rbp)\nmovl   $0x0,-0x44(%rbp)\nmovl   $0x0,-0x40(%rbp)\njmpq   169 <func0+0x169>\nmov    -0x40(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x1c(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmovl   $0x0,-0x38(%rbp)\njmp    ca <func0+0xca>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x1c(%rbp)\njne    c6 <func0+0xc6>\nmovl   $0x1,-0x3c(%rbp)\njmp    d2 <func0+0xd2>\naddl   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0x48(%rbp),%eax\njl     a2 <func0+0xa2>\ncmpl   $0x0,-0x3c(%rbp)\njne    164 <func0+0x164>\nmovl   $0x0,-0x34(%rbp)\nmovl   $0x0,-0x30(%rbp)\njmp    114 <func0+0x114>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x1c(%rbp)\njne    110 <func0+0x110>\nmovl   $0x1,-0x34(%rbp)\njmp    11c <func0+0x11c>\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x4c(%rbp),%eax\njl     ec <func0+0xec>\ncmpl   $0x0,-0x34(%rbp)\nje     143 <func0+0x143>\nmov    -0x48(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x48(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\nmov    %eax,(%rdx)\njmp    165 <func0+0x165>\nmov    -0x4c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x4c(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\nmov    %eax,(%rdx)\njmp    165 <func0+0x165>\nnop\naddl   $0x1,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0x5c(%rbp),%eax\njl     79 <func0+0x79>\nmovl   $0x0,-0x2c(%rbp)\njmpq   203 <func0+0x203>\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x20(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    1d2 <func0+0x1d2>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x20(%rbp)\njne    1ce <func0+0x1ce>\nmovl   $0x1,-0x28(%rbp)\njmp    1da <func0+0x1da>\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x48(%rbp),%eax\njl     1aa <func0+0x1aa>\ncmpl   $0x0,-0x28(%rbp)\njne    1ff <func0+0x1ff>\nmov    -0x44(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x44(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x5c(%rbp),%eax\njl     181 <func0+0x181>\nmov    -0x68(%rbp),%rax\nmov    -0x44(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncallq  224 <func0+0x224>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncallq  230 <func0+0x230>\nmov    -0x18(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 26,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (int[]){}, 0));\n    free(result);\n\n    result = func0((int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r14\nmov    %esi,%r15d\nmov    %rdx,%r13\nmovslq %esi,%rbx\nlea    0x0(,%rbx,4),%rdi\n00\ncallq  2b <func0+0x2b>\nmov    %rax,%r12\nmov    $0x4,%esi\nmov    %rbx,%rdi\ncallq  3b <func0+0x3b>\nmov    %rax,%rbp\nmov    $0x4,%esi\nmov    %rbx,%rdi\ncallq  4b <func0+0x4b>\nmov    %rax,%rbx\ntest   %r15d,%r15d\njle    8c <func0+0x8c>\nmov    %r14,%rsi\nlea    -0x1(%r15),%eax\nlea    0x4(%r14,%rax,4),%rdi\nmov    $0x0,%r8d\nmov    $0x0,%r9d\nlea    0x4(%rbp),%r11\nlea    0x4(%rbx),%r10\njmpq   109 <func0+0x109>\nmov    %rbx,%r10\nlea    -0x1(%r8),%eax\nlea    0x4(%rbx,%rax,4),%rcx\nmov    $0x0,%r9d\njmp    cc <func0+0xcc>\nmov    $0x0,%r9d\nmov    %r9d,0x0(%r13)\nmov    %rbp,%rdi\ncallq  9e <func0+0x9e>\nmov    %rbx,%rdi\ncallq  a6 <func0+0xa6>\nmov    %r12,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmovslq %r9d,%rax\nmov    %edx,(%r12,%rax,4)\nlea    0x1(%r9),%r9d\nadd    $0x4,%rsi\ncmp    %rdi,%rsi\nje     92 <func0+0x92>\nmov    (%rsi),%edx\ntest   %r8d,%r8d\njle    b8 <func0+0xb8>\nmov    %r10,%rax\ncmp    %edx,(%rax)\nje     c3 <func0+0xc3>\nadd    $0x4,%rax\ncmp    %rax,%rcx\njne    d6 <func0+0xd6>\njmp    b8 <func0+0xb8>\nmovslq %r8d,%rax\nmov    %edx,(%rbx,%rax,4)\nlea    0x1(%r8),%r8d\njmp    fc <func0+0xfc>\nmovslq %r9d,%rax\nmov    %edx,0x0(%rbp,%rax,4)\nlea    0x1(%r9),%r9d\nadd    $0x4,%r14\ncmp    %rdi,%r14\nje     78 <func0+0x78>\nmov    (%r14),%edx\ntest   %r8d,%r8d\njle    129 <func0+0x129>\nmov    %rbx,%rax\nlea    -0x1(%r8),%ecx\nlea    (%r10,%rcx,4),%rcx\ncmp    %edx,(%rax)\nje     fc <func0+0xfc>\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    11c <func0+0x11c>\ntest   %r9d,%r9d\njle    f1 <func0+0xf1>\nmov    %rbp,%rax\nlea    -0x1(%r9),%ecx\nlea    (%r11,%rcx,4),%rcx\ncmp    %edx,(%rax)\nje     e5 <func0+0xe5>\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    139 <func0+0x139>\njmp    f1 <func0+0xf1>"
    },
    {
        "task_id": 26,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (int[]){}, 0));\n    free(result);\n\n    result = func0((int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rdi,%r15\npush   %r14\npush   %r13\nmovslq %esi,%r13\npush   %r12\nlea    0x0(,%r13,4),%rdi\n00\nmov    %r13,%r14\npush   %rbp\npush   %rbx\nmov    %rdx,%rbx\nsub    $0x8,%rsp\ncallq  2b <func0+0x2b>\nmov    %r13,%rdi\nmov    $0x4,%esi\nmov    %rax,%r12\ncallq  3b <func0+0x3b>\nmov    %r13,%rdi\nmov    $0x4,%esi\nmov    %rax,%rbp\ncallq  4b <func0+0x4b>\nmov    %rax,%r13\ntest   %r14d,%r14d\njle    185 <func0+0x185>\nlea    -0x1(%r14),%eax\nmov    %r15,%r8\nmov    %r15,%r9\nxor    %edx,%edx\nlea    0x4(%r15,%rax,4),%rax\nxor    %r10d,%r10d\nlea    0x4(%r13),%r11\nlea    0x4(%rbp),%r14\nnopl   0x0(%rax,%rax,1)\nmov    (%r9),%esi\ntest   %edx,%edx\nje     100 <func0+0x100>\nlea    -0x1(%rdx),%edi\nmov    %r13,%rcx\nlea    (%r11,%rdi,4),%rdi\njmp    99 <func0+0x99>\nnop\nadd    $0x4,%rcx\ncmp    %rdi,%rcx\nje     100 <func0+0x100>\ncmp    %esi,(%rcx)\njne    90 <func0+0x90>\nadd    $0x4,%r9\ncmp    %rax,%r9\njne    78 <func0+0x78>\nlea    -0x1(%rdx),%ecx\nxor    %r9d,%r9d\nlea    (%r11,%rcx,4),%rdi\nmov    (%r8),%esi\ntest   %edx,%edx\nje     148 <func0+0x148>\nmov    %r13,%rcx\njmp    c9 <func0+0xc9>\nadd    $0x4,%rcx\ncmp    %rcx,%rdi\nje     148 <func0+0x148>\ncmp    %esi,(%rcx)\njne    c0 <func0+0xc0>\nadd    $0x4,%r8\ncmp    %rax,%r8\njne    b0 <func0+0xb0>\nmov    %r9d,(%rbx)\nmov    %rbp,%rdi\ncallq  e1 <func0+0xe1>\nmov    %r13,%rdi\ncallq  e9 <func0+0xe9>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax,%rax,1)\ntest   %r10d,%r10d\nje     168 <func0+0x168>\nlea    -0x1(%r10),%edi\nmov    %rbp,%rcx\nlea    (%r14,%rdi,4),%rdi\njmp    121 <func0+0x121>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rcx\ncmp    %rdi,%rcx\nje     168 <func0+0x168>\ncmp    %esi,(%rcx)\njne    118 <func0+0x118>\nmovslq %edx,%rcx\nadd    $0x4,%r9\nadd    $0x1,%edx\nmov    %esi,0x0(%r13,%rcx,4)\ncmp    %rax,%r9\njne    78 <func0+0x78>\njmpq   a6 <func0+0xa6>\nnopw   0x0(%rax,%rax,1)\nmovslq %r9d,%rcx\nadd    $0x4,%r8\nadd    $0x1,%r9d\nmov    %esi,(%r12,%rcx,4)\ncmp    %rax,%r8\njne    b0 <func0+0xb0>\njmpq   d6 <func0+0xd6>\nnopl   (%rax)\nmovslq %r10d,%rcx\nadd    $0x4,%r9\nadd    $0x1,%r10d\nmov    %esi,0x0(%rbp,%rcx,4)\ncmp    %rax,%r9\njne    78 <func0+0x78>\njmpq   a6 <func0+0xa6>\nxor    %r9d,%r9d\njmpq   d6 <func0+0xd6>"
    },
    {
        "task_id": 26,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (int[]){}, 0));\n    free(result);\n\n    result = func0((int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rdi,%r15\npush   %r14\npush   %r13\nmovslq %esi,%r13\npush   %r12\nlea    0x0(,%r13,4),%rdi\n00\nmov    %r13,%r14\npush   %rbp\npush   %rbx\nmov    %rdx,%rbx\nsub    $0x8,%rsp\ncallq  2b <func0+0x2b>\nmov    %r13,%rdi\nmov    $0x4,%esi\nmov    %rax,%r12\ncallq  3b <func0+0x3b>\nmov    %r13,%rdi\nmov    $0x4,%esi\nmov    %rax,%rbp\ncallq  4b <func0+0x4b>\nmov    %rax,%r13\ntest   %r14d,%r14d\njle    185 <func0+0x185>\nlea    -0x1(%r14),%eax\nmov    %r15,%r8\nmov    %r15,%r9\nxor    %edx,%edx\nlea    0x4(%r15,%rax,4),%rax\nxor    %r10d,%r10d\nlea    0x4(%r13),%r11\nlea    0x4(%rbp),%r14\nnopl   0x0(%rax,%rax,1)\nmov    (%r9),%esi\ntest   %edx,%edx\nje     100 <func0+0x100>\nlea    -0x1(%rdx),%edi\nmov    %r13,%rcx\nlea    (%r11,%rdi,4),%rdi\njmp    99 <func0+0x99>\nnop\nadd    $0x4,%rcx\ncmp    %rdi,%rcx\nje     100 <func0+0x100>\ncmp    %esi,(%rcx)\njne    90 <func0+0x90>\nadd    $0x4,%r9\ncmp    %rax,%r9\njne    78 <func0+0x78>\nlea    -0x1(%rdx),%ecx\nxor    %r9d,%r9d\nlea    (%r11,%rcx,4),%rdi\nmov    (%r8),%esi\ntest   %edx,%edx\nje     148 <func0+0x148>\nmov    %r13,%rcx\njmp    c9 <func0+0xc9>\nadd    $0x4,%rcx\ncmp    %rcx,%rdi\nje     148 <func0+0x148>\ncmp    %esi,(%rcx)\njne    c0 <func0+0xc0>\nadd    $0x4,%r8\ncmp    %rax,%r8\njne    b0 <func0+0xb0>\nmov    %r9d,(%rbx)\nmov    %rbp,%rdi\ncallq  e1 <func0+0xe1>\nmov    %r13,%rdi\ncallq  e9 <func0+0xe9>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax,%rax,1)\ntest   %r10d,%r10d\nje     168 <func0+0x168>\nlea    -0x1(%r10),%edi\nmov    %rbp,%rcx\nlea    (%r14,%rdi,4),%rdi\njmp    121 <func0+0x121>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rcx\ncmp    %rdi,%rcx\nje     168 <func0+0x168>\ncmp    %esi,(%rcx)\njne    118 <func0+0x118>\nmovslq %edx,%rcx\nadd    $0x4,%r9\nadd    $0x1,%edx\nmov    %esi,0x0(%r13,%rcx,4)\ncmp    %rax,%r9\njne    78 <func0+0x78>\njmpq   a6 <func0+0xa6>\nnopw   0x0(%rax,%rax,1)\nmovslq %r9d,%rcx\nadd    $0x4,%r8\nadd    $0x1,%r9d\nmov    %esi,(%r12,%rcx,4)\ncmp    %rax,%r8\njne    b0 <func0+0xb0>\njmpq   d6 <func0+0xd6>\nnopl   (%rax)\nmovslq %r10d,%rcx\nadd    $0x4,%r9\nadd    $0x1,%r10d\nmov    %esi,0x0(%rbp,%rcx,4)\ncmp    %rax,%r9\njne    78 <func0+0x78>\njmpq   a6 <func0+0xa6>\nxor    %r9d,%r9d\njmpq   d6 <func0+0xd6>"
    },
    {
        "task_id": 27,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  20 <func0+0x20>\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    84 <func0+0x84>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x9(%rbp)\ncmpb   $0x60,-0x9(%rbp)\njle    57 <func0+0x57>\ncmpb   $0x7a,-0x9(%rbp)\njg     57 <func0+0x57>\nmovzbl -0x9(%rbp),%eax\nsub    $0x20,%eax\nmov    %al,-0x9(%rbp)\njmp    6d <func0+0x6d>\ncmpb   $0x40,-0x9(%rbp)\njle    6d <func0+0x6d>\ncmpb   $0x5a,-0x9(%rbp)\njg     6d <func0+0x6d>\nmovzbl -0x9(%rbp),%eax\nadd    $0x20,%eax\nmov    %al,-0x9(%rbp)\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x9(%rbp),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     2c <func0+0x2c>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\nleaveq\nretq"
    },
    {
        "task_id": 27,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r8\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%r9\ntest   %r9d,%r9d\njle    5d <func0+0x5d>\nlea    -0x1(%r9),%r10d\nmov    $0x0,%edx\njmp    48 <func0+0x48>\nlea    -0x41(%rax),%edi\nadd    $0x20,%ecx\ncmp    $0x1a,%dil\ncmovb  %ecx,%eax\nmov    %al,(%rsi,%rdx,1)\nlea    0x1(%rdx),%rax\ncmp    %r10,%rdx\nje     5d <func0+0x5d>\nmov    %rax,%rdx\nmovzbl (%r8,%rdx,1),%eax\nmov    %eax,%ecx\nlea    -0x61(%rax),%edi\ncmp    $0x19,%dil\nja     2c <func0+0x2c>\nsub    $0x20,%eax\njmp    39 <func0+0x39>\nmovslq %r9d,%r9\nmovb   $0x0,(%rsi,%r9,1)\nretq"
    },
    {
        "task_id": 27,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x8,%rsp\ncallq  15 <func0+0x15>\ntest   %eax,%eax\njle    5b <func0+0x5b>\nlea    -0x1(%rax),%esi\nxor    %ecx,%ecx\njmp    32 <func0+0x32>\nsub    $0x20,%edx\nmov    %dl,(%rbx,%rcx,1)\nlea    0x1(%rcx),%rdx\ncmp    %rcx,%rsi\nje     5b <func0+0x5b>\nmov    %rdx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edx\nlea    -0x61(%rdx),%r8d\ncmp    $0x19,%r8b\njbe    20 <func0+0x20>\nlea    -0x41(%rdx),%r8d\nlea    0x20(%rdx),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%edx\nmov    %dl,(%rbx,%rcx,1)\nlea    0x1(%rcx),%rdx\ncmp    %rcx,%rsi\njne    2f <func0+0x2f>\ncltq\nmovb   $0x0,(%rbx,%rax,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 27,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x8,%rsp\ncallq  15 <func0+0x15>\ntest   %eax,%eax\njle    377 <func0+0x377>\nlea    0xf(%rbp),%rcx\nlea    -0x1(%rax),%edx\nsub    %rbx,%rcx\ncmp    $0x1e,%rcx\njbe    400 <func0+0x400>\ncmp    $0xe,%edx\njbe    400 <func0+0x400>\nmov    %eax,%ecx\nmovdqa 0x0(%rip),%xmm7\n00\nxor    %edx,%edx\npxor   %xmm4,%xmm4\nshr    $0x4,%ecx\nmovdqa 0x0(%rip),%xmm5\n00\nmovdqa 0x0(%rip),%xmm9\n00 00\nmovdqa 0x0(%rip),%xmm8\n00 00\nmovdqa 0x0(%rip),%xmm6\n00\nshl    $0x4,%rcx\nnopl   0x0(%rax,%rax,1)\nmovdqu 0x0(%rbp,%rdx,1),%xmm10\nmovdqa %xmm10,%xmm2\nmovdqa %xmm10,%xmm1\nmovdqa %xmm10,%xmm11\npaddb  %xmm8,%xmm1\npaddb  %xmm9,%xmm2\nmovdqa %xmm1,%xmm0\npsubusb %xmm5,%xmm2\nmovdqa %xmm1,%xmm12\npcmpeqb %xmm4,%xmm2\npsubusb %xmm5,%xmm0\npminub %xmm5,%xmm12\npcmpeqb %xmm4,%xmm0\npcmpeqb %xmm12,%xmm1\npaddb  %xmm7,%xmm11\nmovdqa %xmm2,%xmm3\npcmpeqb %xmm4,%xmm3\npcmpeqb %xmm4,%xmm0\npand   %xmm3,%xmm1\npand   %xmm3,%xmm0\nmovdqa %xmm10,%xmm3\npaddb  %xmm6,%xmm3\npand   %xmm2,%xmm3\npandn  %xmm11,%xmm2\npand   %xmm1,%xmm11\nmovdqa %xmm3,%xmm12\nmovdqa %xmm2,%xmm3\nmovdqa %xmm10,%xmm2\npor    %xmm12,%xmm3\npand   %xmm0,%xmm2\npandn  %xmm3,%xmm1\npor    %xmm11,%xmm1\npandn  %xmm1,%xmm0\npor    %xmm0,%xmm2\nmovups %xmm2,(%rbx,%rdx,1)\nadd    $0x10,%rdx\ncmp    %rcx,%rdx\njne    78 <func0+0x78>\nmov    %eax,%edx\nand    $0xfffffff0,%edx\ntest   $0xf,%al\nje     377 <func0+0x377>\nmovslq %edx,%rsi\nmovzbl 0x0(%rbp,%rsi,1),%ecx\nlea    -0x61(%rcx),%edi\ncmp    $0x19,%dil\njbe    388 <func0+0x388>\nlea    -0x41(%rcx),%r8d\nlea    0x20(%rcx),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%ecx\nmov    %cl,(%rbx,%rsi,1)\nlea    0x1(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     390 <func0+0x390>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x2(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     3a8 <func0+0x3a8>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x3(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     3c0 <func0+0x3c0>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x4(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     3d8 <func0+0x3d8>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x5(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\njbe    3f0 <func0+0x3f0>\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x6(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     448 <func0+0x448>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x7(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     460 <func0+0x460>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x8(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     478 <func0+0x478>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0x9(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     490 <func0+0x490>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0xa(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     4a8 <func0+0x4a8>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0xb(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     4c0 <func0+0x4c0>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0xc(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     4d3 <func0+0x4d3>\nsub    $0x20,%esi\nmov    %sil,(%rbx,%rcx,1)\nlea    0xd(%rdx),%ecx\ncmp    %ecx,%eax\njle    377 <func0+0x377>\nmovslq %ecx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%esi\nlea    -0x61(%rsi),%edi\ncmp    $0x19,%dil\nja     4e6 <func0+0x4e6>\nsub    $0x20,%esi\nadd    $0xe,%edx\nmov    %sil,(%rbx,%rcx,1)\ncmp    %edx,%eax\njle    377 <func0+0x377>\nmovslq %edx,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%ecx\nlea    -0x61(%rcx),%esi\ncmp    $0x19,%sil\nja     4f9 <func0+0x4f9>\nsub    $0x20,%ecx\nmov    %cl,(%rbx,%rdx,1)\ncltq\nmovb   $0x0,(%rbx,%rax,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq\nnopl   0x0(%rax)\nsub    $0x20,%ecx\njmpq   154 <func0+0x154>\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmpq   17a <func0+0x17a>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmpq   1a1 <func0+0x1a1>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmpq   1c8 <func0+0x1c8>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmpq   1ef <func0+0x1ef>\nnopl   0x0(%rax,%rax,1)\nsub    $0x20,%esi\njmpq   221 <func0+0x221>\nnopl   0x0(%rax,%rax,1)\n00\nmov    %edx,%esi\nxor    %ecx,%ecx\njmp    431 <func0+0x431>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nlea    -0x41(%rdx),%r8d\nlea    0x20(%rdx),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%edx\nmov    %dl,(%rbx,%rcx,1)\nlea    0x1(%rcx),%rdx\ncmp    %rsi,%rcx\nje     377 <func0+0x377>\nmov    %rdx,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%edx\nlea    -0x61(%rdx),%edi\ncmp    $0x19,%dil\nja     410 <func0+0x410>\nsub    $0x20,%edx\njmp    41e <func0+0x41e>\nnopl   0x0(%rax)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmpq   248 <func0+0x248>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmpq   26f <func0+0x26f>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmpq   296 <func0+0x296>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmpq   2bd <func0+0x2bd>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmpq   2e4 <func0+0x2e4>\nnopl   0x0(%rax,%rax,1)\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmpq   30b <func0+0x30b>\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmpq   32e <func0+0x32e>\nlea    -0x41(%rsi),%r8d\nlea    0x20(%rsi),%edi\ncmp    $0x1a,%r8b\ncmovb  %edi,%esi\njmpq   351 <func0+0x351>\nlea    -0x41(%rcx),%edi\nlea    0x20(%rcx),%esi\ncmp    $0x1a,%dil\ncmovb  %esi,%ecx\njmpq   374 <func0+0x374>"
    },
    {
        "task_id": 28,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    50 <func0+0x50>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncallq  42 <func0+0x42>\nmov    %eax,%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     23 <func0+0x23>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncallq  68 <func0+0x68>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    7a <func0+0x7a>\nmov    $0x0,%eax\njmp    c0 <func0+0xc0>\nmov    -0x8(%rbp),%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0xc(%rbp)\njmp    b4 <func0+0xb4>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  b0 <func0+0xb0>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     8a <func0+0x8a>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 28,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %esi,%esi\njle    8a <func0+0x8a>\nmov    %rdi,%r12\nmov    %esi,%ebp\nmov    %rdi,%rdx\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%r9\nmov    $0x0,%esi\nmov    $0xffffffffffffffff,%r8\nmov    $0x0,%eax\nmov    (%rdx),%rdi\nmov    %r8,%rcx\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rsi,%rcx,1),%esi\nadd    $0x8,%rdx\ncmp    %r9,%rdx\njne    33 <func0+0x33>\nlea    0x1(%rsi),%edi\nmovslq %edi,%rdi\ncallq  56 <func0+0x56>\nmov    %rax,%r13\ntest   %rax,%rax\nje     7c <func0+0x7c>\nmovb   $0x0,0x0(%r13)\nmov    $0x0,%ebx\nmov    (%r12,%rbx,8),%rsi\nmov    %r13,%rdi\ncallq  74 <func0+0x74>\nadd    $0x1,%rbx\ncmp    %ebx,%ebp\njg     68 <func0+0x68>\nmov    %r13,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nmov    $0x1,%edi\ncallq  94 <func0+0x94>\nmov    %rax,%r13\ntest   %rax,%rax\nje     7c <func0+0x7c>\nmovb   $0x0,(%rax)\njmp    7c <func0+0x7c>"
    },
    {
        "task_id": 28,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %esi,%esi\njle    88 <func0+0x88>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nmov    %rdi,%rbp\nxor    %r12d,%r12d\nlea    0x8(%rdi,%rax,8),%r13\nnopl   0x0(%rax,%rax,1)\nmov    0x0(%rbp),%rdi\nadd    $0x8,%rbp\ncallq  35 <func0+0x35>\nadd    %eax,%r12d\ncmp    %r13,%rbp\njne    28 <func0+0x28>\nlea    0x1(%r12),%edi\nmovslq %edi,%rdi\ncallq  4a <func0+0x4a>\nmov    %rax,%r8\ntest   %rax,%rax\nje     ab <func0+0xab>\nmovb   $0x0,(%r8)\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    (%rbx),%rsi\nmov    %r8,%rdi\nadd    $0x8,%rbx\ncallq  6f <func0+0x6f>\nmov    %rax,%r8\ncmp    %r13,%rbx\njne    60 <func0+0x60>\nadd    $0x8,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopl   (%rax)\nmov    $0x1,%edi\ncallq  92 <func0+0x92>\nmov    %rax,%r8\ntest   %rax,%rax\nje     ab <func0+0xab>\nmovb   $0x0,(%rax)\nadd    $0x8,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nxor    %r8d,%r8d\njmp    77 <func0+0x77>"
    },
    {
        "task_id": 28,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %esi,%esi\njle    88 <func0+0x88>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nmov    %rdi,%rbp\nxor    %r12d,%r12d\nlea    0x8(%rdi,%rax,8),%r13\nnopl   0x0(%rax,%rax,1)\nmov    0x0(%rbp),%rdi\nadd    $0x8,%rbp\ncallq  35 <func0+0x35>\nadd    %eax,%r12d\ncmp    %rbp,%r13\njne    28 <func0+0x28>\nlea    0x1(%r12),%edi\nmovslq %edi,%rdi\ncallq  4a <func0+0x4a>\nmov    %rax,%r8\ntest   %rax,%rax\nje     ab <func0+0xab>\nmovb   $0x0,(%r8)\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    (%rbx),%rsi\nmov    %r8,%rdi\nadd    $0x8,%rbx\ncallq  6f <func0+0x6f>\nmov    %rax,%r8\ncmp    %rbx,%r13\njne    60 <func0+0x60>\nadd    $0x8,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopl   (%rax)\nmov    $0x1,%edi\ncallq  92 <func0+0x92>\nmov    %rax,%r8\ntest   %rax,%rax\nje     ab <func0+0xab>\nmovb   $0x0,(%rax)\nadd    $0x8,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nxor    %r8d,%r8d\njmp    77 <func0+0x77>"
    },
    {
        "task_id": 29,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n\n    count = func0((char*[]){}, 0, \"john\", &result);\n    assert(issame(result, count, (char*[]){}, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  27 <func0+0x27>\nmov    %eax,-0x4(%rbp)\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncallq  3b <func0+0x3b>\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nmov    %rdx,(%rax)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    be <func0+0xbe>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    -0x28(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncallq  81 <func0+0x81>\ntest   %eax,%eax\njne    ba <func0+0xba>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x30(%rbp),%rax\nmov    (%rax),%rsi\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\ncltq\nshl    $0x3,%rax\nlea    (%rsi,%rax,1),%rdx\nmov    (%rcx),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     55 <func0+0x55>\nmov    -0xc(%rbp),%eax\nleaveq\nretq"
    },
    {
        "task_id": 29,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n\n    count = func0((char*[]){}, 0, \"john\", &result);\n    assert(issame(result, count, (char*[]){}, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%r14\nmov    %esi,%r12d\nmov    %rdx,%r13\nmov    %rcx,%r15\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nmov    %rdx,%rdi\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%ebp\nmovslq %esi,%rdi\nshl    $0x3,%rdi\ncallq  41 <func0+0x41>\nmov    %rax,(%r15)\ntest   %r12d,%r12d\njle    97 <func0+0x97>\nmov    %r14,%rbx\nlea    -0x1(%r12),%eax\nlea    0x8(%r14,%rax,8),%r14\nmov    $0x0,%r12d\nmovslq %ebp,%rax\nmov    %rax,0x8(%rsp)\njmp    6f <func0+0x6f>\nadd    $0x8,%rbx\ncmp    %r14,%rbx\nje     9d <func0+0x9d>\nmov    (%rbx),%rbp\nmov    0x8(%rsp),%rdx\nmov    %r13,%rsi\nmov    %rbp,%rdi\ncallq  82 <func0+0x82>\ntest   %eax,%eax\njne    66 <func0+0x66>\nmovslq %r12d,%rdx\nmov    (%r15),%rax\nmov    %rbp,(%rax,%rdx,8)\nlea    0x1(%r12),%r12d\njmp    66 <func0+0x66>\nmov    $0x0,%r12d\nmov    %r12d,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 29,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n\n    count = func0((char*[]){}, 0, \"john\", &result);\n    assert(issame(result, count, (char*[]){}, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rcx,%r15\npush   %r14\npush   %r13\nmov    %rdx,%r13\npush   %r12\nmov    %esi,%r12d\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %rdx,%rdi\nsub    $0x18,%rsp\ncallq  26 <func0+0x26>\nmovslq %r12d,%rdi\nshl    $0x3,%rdi\nmov    %rax,%rbp\ncallq  35 <func0+0x35>\nmov    %rax,0x8(%rsp)\nmov    %rax,(%r15)\ntest   %r12d,%r12d\njle    a0 <func0+0xa0>\nlea    -0x1(%r12),%eax\nmovslq %ebp,%rbp\nxor    %r12d,%r12d\nlea    0x8(%rbx,%rax,8),%r15\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%r14\nmov    %rbp,%rdx\nmov    %r13,%rsi\nmov    %r14,%rdi\ncallq  69 <func0+0x69>\ntest   %eax,%eax\njne    7d <func0+0x7d>\nmov    0x8(%rsp),%rcx\nmovslq %r12d,%rax\nadd    $0x1,%r12d\nmov    %r14,(%rcx,%rax,8)\nadd    $0x8,%rbx\ncmp    %r15,%rbx\njne    58 <func0+0x58>\nadd    $0x18,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax,%rax,1)\n00\nxor    %r12d,%r12d\njmp    86 <func0+0x86>"
    },
    {
        "task_id": 29,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n\n    count = func0((char*[]){}, 0, \"john\", &result);\n    assert(issame(result, count, (char*[]){}, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rcx,%r15\npush   %r14\npush   %r13\nmov    %rdx,%r13\npush   %r12\nmov    %esi,%r12d\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %rdx,%rdi\nsub    $0x18,%rsp\ncallq  26 <func0+0x26>\nmovslq %r12d,%rdi\nshl    $0x3,%rdi\nmov    %rax,%rbp\ncallq  35 <func0+0x35>\nmov    %rax,0x8(%rsp)\nmov    %rax,(%r15)\ntest   %r12d,%r12d\njle    a0 <func0+0xa0>\nlea    -0x1(%r12),%eax\nmovslq %ebp,%rbp\nxor    %r12d,%r12d\nlea    0x8(%rbx,%rax,8),%r15\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%r14\nmov    %rbp,%rdx\nmov    %r13,%rsi\nmov    %r14,%rdi\ncallq  69 <func0+0x69>\ntest   %eax,%eax\njne    7d <func0+0x7d>\nmov    0x8(%rsp),%rcx\nmovslq %r12d,%rax\nadd    $0x1,%r12d\nmov    %r14,(%rcx,%rax,8)\nadd    $0x8,%rbx\ncmp    %rbx,%r15\njne    58 <func0+0x58>\nadd    $0x18,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax,%rax,1)\n00\nxor    %r12d,%r12d\njmp    86 <func0+0x86>"
    },
    {
        "task_id": 30,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (float[]){}, 0));\n    free(result);\n\n    result = func0((float[]){}, 0, &count);\n    assert(issame(result, count, (float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  28 <func0+0x28>\nmov    %rax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0xc(%rbp)\njmp    a1 <func0+0xa1>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm1,%xmm1\ncomiss %xmm1,%xmm0\njbe    9d <func0+0x9d>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rsi\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%ecx\nmov    -0x28(%rbp),%rdx\nmov    %ecx,(%rdx)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rsi),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     3f <func0+0x3f>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 30,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (float[]){}, 0));\n    free(result);\n\n    result = func0((float[]){}, 0, &count);\n    assert(issame(result, count, (float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r12\nmov    %esi,%ebp\nmov    %rdx,%rbx\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncallq  1c <func0+0x1c>\nmovl   $0x0,(%rbx)\ntest   %ebp,%ebp\njle    5e <func0+0x5e>\nmov    %r12,%rdx\nlea    -0x1(%rbp),%ecx\nlea    0x4(%r12,%rcx,4),%rdi\npxor   %xmm1,%xmm1\njmp    40 <func0+0x40>\nadd    $0x4,%rdx\ncmp    %rdi,%rdx\nje     5e <func0+0x5e>\nmovss  (%rdx),%xmm0\ncomiss %xmm1,%xmm0\njbe    37 <func0+0x37>\nmov    (%rbx),%ecx\nlea    0x1(%rcx),%esi\nmov    %esi,(%rbx)\nmovslq %ecx,%rcx\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax,%rcx,4)\njmp    37 <func0+0x37>\npop    %rbx\npop    %rbp\npop    %r12\nretq"
    },
    {
        "task_id": 30,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (float[]){}, 0));\n    free(result);\n\n    result = func0((float[]){}, 0, &count);\n    assert(issame(result, count, (float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nshl    $0x2,%rdi\ncallq  1d <func0+0x1d>\nmovl   $0x0,0x0(%rbp)\ntest   %r12d,%r12d\njle    61 <func0+0x61>\nlea    -0x1(%r12),%edx\nmov    %rbx,%rdi\npxor   %xmm1,%xmm1\nlea    0x4(%rbx,%rdx,4),%rsi\nnopw   0x0(%rax,%rax,1)\nmovss  (%rdi),%xmm0\ncomiss %xmm1,%xmm0\njbe    58 <func0+0x58>\nmovslq 0x0(%rbp),%rcx\nlea    0x1(%rcx),%edx\nmovss  %xmm0,(%rax,%rcx,4)\nmov    %edx,0x0(%rbp)\nadd    $0x4,%rdi\ncmp    %rsi,%rdi\njne    40 <func0+0x40>\npop    %rbx\npop    %rbp\npop    %r12\nretq"
    },
    {
        "task_id": 30,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (float[]){}, 0));\n    free(result);\n\n    result = func0((float[]){}, 0, &count);\n    assert(issame(result, count, (float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nshl    $0x2,%rdi\ncallq  1d <func0+0x1d>\nmovl   $0x0,0x0(%rbp)\ntest   %r12d,%r12d\njle    61 <func0+0x61>\nlea    -0x1(%r12),%edx\nmov    %rbx,%rdi\npxor   %xmm1,%xmm1\nlea    0x4(%rbx,%rdx,4),%rsi\nnopw   0x0(%rax,%rax,1)\nmovss  (%rdi),%xmm0\ncomiss %xmm1,%xmm0\njbe    58 <func0+0x58>\nmovslq 0x0(%rbp),%rcx\nlea    0x1(%rcx),%edx\nmovss  %xmm0,(%rax,%rcx,4)\nmov    %edx,0x0(%rbp)\nadd    $0x4,%rdi\ncmp    %rdi,%rsi\njne    40 <func0+0x40>\npop    %rbx\npop    %rbp\npop    %r12\nretq"
    },
    {
        "task_id": 31,
        "type": "O0",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\ncmpq   $0x1,-0x18(%rbp)\njg     1a <func0+0x1a>\nmov    $0x0,%eax\njmp    55 <func0+0x55>\nmovq   $0x2,-0x8(%rbp)\n00\njmp    42 <func0+0x42>\nmov    -0x18(%rbp),%rax\ncqto\nidivq  -0x8(%rbp)\nmov    %rdx,%rax\ntest   %rax,%rax\njne    3d <func0+0x3d>\nmov    $0x0,%eax\njmp    55 <func0+0x55>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nimul   %rax,%rax\ncmp    %rax,-0x18(%rbp)\njge    24 <func0+0x24>\nmov    $0x1,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 31,
        "type": "O1",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x0,%eax\ncmp    $0x1,%rdi\njle    42 <func0+0x42>\ncmp    $0x3,%rdi\njle    49 <func0+0x49>\ntest   $0x1,%dil\nje     4f <func0+0x4f>\nmov    $0x2,%ecx\nadd    $0x1,%rcx\nmov    %rcx,%rax\nimul   %rcx,%rax\ncmp    %rdi,%rax\njg     43 <func0+0x43>\nmov    %rdi,%rax\ncqto\nidiv   %rcx\ntest   %rdx,%rdx\njne    20 <func0+0x20>\nmov    $0x0,%eax\nretq\nmov    $0x1,%eax\nretq\nmov    $0x1,%eax\nretq\nmov    $0x0,%eax\nretq"
    },
    {
        "task_id": 31,
        "type": "O2",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ncmp    $0x1,%rdi\njle    4a <func0+0x4a>\ncmp    $0x3,%rdi\njle    3d <func0+0x3d>\ntest   $0x1,%dil\nje     4a <func0+0x4a>\nmov    $0x2,%ecx\njmp    2d <func0+0x2d>\nnop\nmov    %rdi,%rax\ncqto\nidiv   %rcx\ntest   %rdx,%rdx\nje     48 <func0+0x48>\nadd    $0x1,%rcx\nmov    %rcx,%rax\nimul   %rcx,%rax\ncmp    %rdi,%rax\njle    20 <func0+0x20>\nmov    $0x1,%eax\nretq\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 31,
        "type": "O3",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ncmp    $0x1,%rdi\njle    4a <func0+0x4a>\ncmp    $0x3,%rdi\njle    3d <func0+0x3d>\ntest   $0x1,%dil\nje     4a <func0+0x4a>\nmov    $0x2,%ecx\njmp    2d <func0+0x2d>\nnop\nmov    %rdi,%rax\ncqto\nidiv   %rcx\ntest   %rdx,%rdx\nje     48 <func0+0x48>\nadd    $0x1,%rcx\nmov    %rcx,%rax\nimul   %rcx,%rax\ncmp    %rdi,%rax\njle    20 <func0+0x20>\nmov    $0x1,%eax\nretq\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 32,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovl   $0x1,-0x30(%rbp)\njmp    8e <func0+0x8e>\nmovsd  0x0(%rip),%xmm0\n00\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x2c(%rbp)\njmp    57 <func0+0x57>\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     44 <func0+0x44>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  -0x18(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     2e <func0+0x2e>\njmpq   1b8 <func0+0x1b8>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovl   $0x1,-0x30(%rbp)\njmp    116 <func0+0x116>\nmovsd  0x0(%rip),%xmm0\n00\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x1,-0x28(%rbp)\njmp    d6 <func0+0xd6>\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     c3 <func0+0xc3>\ncvtsi2sdl -0x30(%rbp),%xmm1\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  -0x10(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     ad <func0+0xad>\nmovsd  -0x18(%rbp),%xmm0\nmovapd %xmm0,%xmm1\ndivsd  -0x10(%rbp),%xmm1\nmovsd  -0x20(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovl   $0x1,-0x30(%rbp)\njmp    1b0 <func0+0x1b0>\nmovsd  0x0(%rip),%xmm0\n00\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    179 <func0+0x179>\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     166 <func0+0x166>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  -0x18(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     150 <func0+0x150>\nmovsd  -0x18(%rbp),%xmm0\nmovq   0x0(%rip),%xmm1\n00\nandpd  %xmm1,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\nja     9b <func0+0x9b>\nmovsd  -0x20(%rbp),%xmm0\npop    %rbp\nretq"
    },
    {
        "task_id": 32,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r8\nmov    %esi,%r9d\nmovsd  (%rdi),%xmm5\ncmp    $0x1,%esi\njle    5c <func0+0x5c>\nlea    -0x2(%rsi),%esi\nadd    $0x2,%rsi\nmovapd %xmm5,%xmm3\nmov    $0x1,%ecx\npxor   %xmm1,%xmm1\njmp    47 <func0+0x47>\nmulsd  %xmm1,%xmm0\nadd    $0x1,%eax\ncmp    %edx,%eax\njne    29 <func0+0x29>\nmulsd  (%r8,%rcx,8),%xmm0\naddsd  %xmm0,%xmm3\nadd    $0x1,%rcx\ncmp    %rsi,%rcx\nje     60 <func0+0x60>\nmov    %ecx,%edx\nmov    $0x0,%eax\nmovsd  0x0(%rip),%xmm0\n00\ntest   %ecx,%ecx\njg     29 <func0+0x29>\njmp    34 <func0+0x34>\nmovapd %xmm5,%xmm3\nmovapd %xmm3,%xmm0\nandpd  0x0(%rip),%xmm0\n00\npxor   %xmm1,%xmm1\ncomisd 0x0(%rip),%xmm0\n00\njbe    95 <func0+0x95>\nmov    $0x1,%r10d\nmovq   0x0(%rip),%xmm7\n00\nmovsd  0x0(%rip),%xmm6\n00\njmpq   142 <func0+0x142>\npxor   %xmm1,%xmm1\nmovapd %xmm1,%xmm0\nretq\nmov    $0x1,%eax\nmovsd  0x0(%rip),%xmm0\n00\nmulsd  %xmm1,%xmm0\nmov    %eax,%edx\nadd    $0x1,%eax\ncmp    %edx,%ecx\njne    ab <func0+0xab>\nadd    $0x8,%rdi\nmov    %esi,%ecx\npxor   %xmm2,%xmm2\ncvtsi2sd %ecx,%xmm2\nmulsd  (%rdi),%xmm2\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm4\nlea    0x1(%rcx),%esi\ncmp    %esi,%r9d\nje     160 <func0+0x160>\ncmp    $0x1,%esi\njg     9e <func0+0x9e>\nmovsd  0x0(%rip),%xmm0\n00\njmp    b8 <func0+0xb8>\nmulsd  %xmm1,%xmm0\nadd    $0x1,%eax\ncmp    %eax,%edx\njne    ed <func0+0xed>\nmulsd  (%r8,%rcx,8),%xmm0\naddsd  %xmm0,%xmm3\nadd    $0x1,%rcx\ncmp    %rcx,%rsi\nje     130 <func0+0x130>\nmov    %ecx,%edx\nmov    $0x0,%eax\nmovsd  0x0(%rip),%xmm0\n00\ntest   %ecx,%ecx\njg     ed <func0+0xed>\njmp    f8 <func0+0xf8>\ndivsd  0x0(%rip),%xmm3\n00\nsubsd  %xmm3,%xmm1\nmovapd %xmm5,%xmm3\nmovapd %xmm3,%xmm0\nandpd  %xmm7,%xmm0\ncomisd %xmm6,%xmm0\njbe    99 <func0+0x99>\ncmp    $0x1,%r9d\njle    120 <func0+0x120>\nlea    0x8(%r8),%rdi\nmov    %r10d,%ecx\npxor   %xmm4,%xmm4\nmovsd  0x0(%rip),%xmm0\n00\njmpq   be <func0+0xbe>\ndivsd  %xmm4,%xmm3\nsubsd  %xmm3,%xmm1\nlea    -0x1(%rcx),%esi\nadd    $0x2,%rsi\nmovapd %xmm5,%xmm3\nmov    $0x1,%ecx\njmp    10b <func0+0x10b>"
    },
    {
        "task_id": 32,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovsd  (%rdi),%xmm7\nmov    %rdi,%r9\nmov    %esi,%r8d\ncmp    $0x1,%esi\njle    179 <func0+0x179>\nlea    -0x2(%rsi),%ecx\nmovapd %xmm7,%xmm3\npxor   %xmm6,%xmm6\nmov    $0x1,%edx\nmovsd  0x0(%rip),%xmm1\n00\nadd    $0x2,%rcx\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nmovapd %xmm1,%xmm0\nxchg   %ax,%ax\nmulsd  %xmm6,%xmm0\nadd    $0x1,%eax\ncmp    %edx,%eax\njne    40 <func0+0x40>\nmulsd  (%r9,%rdx,8),%xmm0\nadd    $0x1,%rdx\naddsd  %xmm0,%xmm3\ncmp    %rdx,%rcx\njne    38 <func0+0x38>\nmovapd %xmm3,%xmm0\nmovsd  0x0(%rip),%xmm5\n00\nmovapd %xmm6,%xmm1\nmovq   0x0(%rip),%xmm9\n00 00\nmovsd  0x0(%rip),%xmm8\n00 00\nandpd  %xmm9,%xmm0\ncomisd %xmm8,%xmm0\njbe    152 <func0+0x152>\ncmp    $0x1,%r8d\njle    157 <func0+0x157>\nlea    0x8(%r9),%rdi\nmovapd %xmm6,%xmm4\nmov    $0x1,%ecx\nmovapd %xmm5,%xmm0\nnopl   0x0(%rax,%rax,1)\npxor   %xmm2,%xmm2\nlea    0x1(%rcx),%esi\ncvtsi2sd %ecx,%xmm2\nmulsd  (%rdi),%xmm2\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm4\ncmp    %esi,%r8d\nje     f0 <func0+0xf0>\nmov    $0x1,%eax\nmovapd %xmm5,%xmm0\nnopl   (%rax)\nmulsd  %xmm1,%xmm0\nmov    %eax,%edx\nadd    $0x1,%eax\ncmp    %ecx,%edx\njne    d8 <func0+0xd8>\nadd    $0x8,%rdi\nmov    %esi,%ecx\njmp    b0 <func0+0xb0>\nnopl   (%rax)\ndivsd  %xmm4,%xmm3\nsub    $0x1,%ecx\nmov    $0x1,%edx\nadd    $0x2,%rcx\nsubsd  %xmm3,%xmm1\nmovapd %xmm7,%xmm3\nnopl   0x0(%rax,%rax,1)\n00\nxor    %eax,%eax\nmovapd %xmm5,%xmm0\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmulsd  %xmm1,%xmm0\nadd    $0x1,%eax\ncmp    %edx,%eax\njne    120 <func0+0x120>\nmulsd  (%r9,%rdx,8),%xmm0\nadd    $0x1,%rdx\naddsd  %xmm0,%xmm3\ncmp    %rdx,%rcx\njne    110 <func0+0x110>\nmovapd %xmm3,%xmm0\nandpd  %xmm9,%xmm0\ncomisd %xmm8,%xmm0\nja     90 <func0+0x90>\nmovapd %xmm1,%xmm0\nretq\ndivsd  %xmm6,%xmm3\nsubsd  %xmm3,%xmm1\nmovapd %xmm7,%xmm3\nmovapd %xmm3,%xmm0\nandpd  %xmm9,%xmm0\ncomisd %xmm8,%xmm0\nja     90 <func0+0x90>\njmp    152 <func0+0x152>\nmovapd %xmm7,%xmm3\npxor   %xmm6,%xmm6\njmpq   5e <func0+0x5e>"
    },
    {
        "task_id": 32,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovsd  (%rdi),%xmm8\nmov    %esi,%r10d\ncmp    $0x1,%esi\njle    189 <func0+0x189>\nlea    -0x2(%rsi),%ecx\nmovapd %xmm8,%xmm3\nmov    $0x1,%edx\nmovsd  0x0(%rip),%xmm5\n00\nadd    $0x2,%rcx\npxor   %xmm6,%xmm6\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nmovapd %xmm5,%xmm0\nxchg   %ax,%ax\nmulsd  %xmm6,%xmm0\nadd    $0x1,%eax\ncmp    %edx,%eax\njne    40 <func0+0x40>\nmulsd  (%rdi,%rdx,8),%xmm0\nadd    $0x1,%rdx\naddsd  %xmm0,%xmm3\ncmp    %rdx,%rcx\njne    38 <func0+0x38>\nmovq   0x0(%rip),%xmm9\n00 00\nmovapd %xmm3,%xmm0\nmovapd %xmm6,%xmm1\nmovsd  0x0(%rip),%xmm10\n00 00\nandpd  %xmm9,%xmm0\ncomisd %xmm10,%xmm0\njbe    161 <func0+0x161>\nmovsd  0x0(%rip),%xmm7\n00\nlea    -0x2(%r10),%r8d\nlea    -0x3(%r10),%r9d\nadd    $0x2,%r8\nadd    $0x3,%r9\nmovq   %xmm7,%r11\nnopl   0x0(%rax)\ncmp    $0x1,%r10d\njle    166 <func0+0x166>\nmovsd  0x8(%rdi),%xmm4\nmovq   %r11,%xmm5\naddsd  %xmm6,%xmm4\ncmp    $0x2,%r10d\nje     109 <func0+0x109>\nmov    $0x2,%esi\nmovapd %xmm7,%xmm5\nnop\nmov    %esi,%ecx\nmov    %esi,%edx\nmovapd %xmm7,%xmm0\nmov    $0x1,%eax\nnopl   (%rax)\nmulsd  %xmm1,%xmm0\nadd    $0x1,%eax\ncmp    %edx,%eax\njne    e0 <func0+0xe0>\npxor   %xmm2,%xmm2\ncvtsi2sd %ecx,%xmm2\nmulsd  (%rdi,%rsi,8),%xmm2\nadd    $0x1,%rsi\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm4\ncmp    %rsi,%r9\njne    d0 <func0+0xd0>\ndivsd  %xmm4,%xmm3\nmov    $0x1,%edx\nsubsd  %xmm3,%xmm1\nmovapd %xmm8,%xmm3\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nmovapd %xmm5,%xmm0\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmulsd  %xmm1,%xmm0\nadd    $0x1,%eax\ncmp    %edx,%eax\njne    130 <func0+0x130>\nmulsd  (%rdi,%rdx,8),%xmm0\nadd    $0x1,%rdx\naddsd  %xmm0,%xmm3\ncmp    %r8,%rdx\njne    120 <func0+0x120>\nmovapd %xmm3,%xmm0\nandpd  %xmm9,%xmm0\ncomisd %xmm10,%xmm0\nja     a8 <func0+0xa8>\nmovapd %xmm1,%xmm0\nretq\ndivsd  %xmm6,%xmm3\nsubsd  %xmm3,%xmm1\nmovapd %xmm8,%xmm3\nmovapd %xmm3,%xmm0\nandpd  %xmm9,%xmm0\ncomisd %xmm10,%xmm0\nja     a8 <func0+0xa8>\njmp    161 <func0+0x161>\nmovapd %xmm8,%xmm3\npxor   %xmm6,%xmm6\njmpq   5d <func0+0x5d>"
    },
    {
        "task_id": 33,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x1f,%eax\nmov    %edx,%esi\nsub    %eax,%esi\nmov    %esi,%eax\nadd    $0x1,%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  42 <func0+0x42>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    98 <func0+0x98>\nmov    -0x1c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x14(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncmp    %eax,-0x2c(%rbp)\njg     5d <func0+0x5d>\nmovl   $0x0,-0x1c(%rbp)\njmpq   170 <func0+0x170>\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\njmp    fd <func0+0xfd>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    f9 <func0+0xf9>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x10(%rbp)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     c3 <func0+0xc3>\nmov    -0x10(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\nje     16c <func0+0x16c>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x14(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x1c(%rbp)\njl     b2 <func0+0xb2>\nmovl   $0x0,-0x1c(%rbp)\njmpq   22f <func0+0x22f>\nmov    -0x1c(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %rax,%rdx\nmov    %ecx,%eax\nsar    $0x1f,%eax\nmov    %edx,%edi\nsub    %eax,%edi\nmov    %edi,%eax\nmov    %eax,%edx\nadd    %edx,%edx\nadd    %eax,%edx\nmov    %ecx,%eax\nsub    %edx,%eax\ntest   %eax,%eax\njne    1fe <func0+0x1fe>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x1f,%eax\nmov    %edx,%esi\nsub    %eax,%esi\nmov    %esi,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x38(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\njmp    22b <func0+0x22b>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x38(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     18b <func0+0x18b>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncallq  247 <func0+0x247>\nnop\nleaveq\nretq"
    },
    {
        "task_id": 33,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nmov    %esi,%ebp\nmov    %rdx,%r12\nmovslq %esi,%rdi\nimul   $0x55555556,%rdi,%rdi\nshr    $0x20,%rdi\nmov    %esi,%eax\nsar    $0x1f,%eax\nsub    %eax,%edi\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  3a <func0+0x3a>\nmov    %rax,%rdi\ntest   %ebp,%ebp\njle    122 <func0+0x122>\nmov    $0x0,%edx\nmov    $0x0,%eax\nmov    %eax,%r10d\nmov    (%rbx,%rdx,4),%ecx\nmov    %ecx,(%rdi,%rax,4)\nmov    %rax,%r9\nadd    $0x1,%rax\nadd    $0x3,%rdx\ncmp    %edx,%ebp\njg     4f <func0+0x4f>\ntest   %r10d,%r10d\njle    132 <func0+0x132>\nsub    $0x1,%r9d\nmov    %r9d,%r11d\nmov    $0x0,%esi\njmp    8e <func0+0x8e>\nlea    0x1(%rsi),%rax\ncmp    %r11,%rsi\nje     132 <func0+0x132>\nmov    %rax,%rsi\nmov    %esi,%ecx\nmov    %esi,%r13d\ncmp    %r10d,%esi\njge    7e <func0+0x7e>\nlea    0x1(%rsi),%rdx\nmov    %r9d,%eax\nsub    %esi,%eax\nlea    0x2(%rsi,%rax,1),%r8\nmovslq %ecx,%rax\nmov    (%rdi,%rax,4),%eax\ncmp    %eax,(%rdi,%rdx,4)\ncmovl  %edx,%ecx\nadd    $0x1,%rdx\ncmp    %r8,%rdx\njne    a6 <func0+0xa6>\ncmp    %r13d,%ecx\nje     7e <func0+0x7e>\nmov    (%rdi,%rsi,4),%edx\nmovslq %ecx,%rcx\nlea    (%rdi,%rcx,4),%rax\nmov    (%rax),%ecx\nmov    %ecx,(%rdi,%rsi,4)\nmov    %edx,(%rax)\njmp    7e <func0+0x7e>\nmov    (%rbx,%rdx,4),%eax\nmov    %eax,(%r12,%rdx,4)\nlea    0x1(%rdx),%rax\ncmp    %rcx,%rdx\nje     122 <func0+0x122>\nmov    %rax,%rdx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nlea    (%rax,%rax,2),%eax\ncmp    %edx,%eax\njne    d3 <func0+0xd3>\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\ncltq\nmov    (%rdi,%rax,4),%eax\nmov    %eax,(%r12,%rdx,4)\njmp    da <func0+0xda>\ncallq  127 <func0+0x127>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nlea    -0x1(%rbp),%ecx\nmov    $0x0,%edx\njmp    e6 <func0+0xe6>"
    },
    {
        "task_id": 33,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nimul   $0x55555556,%rdi,%rdi\nmov    %r12d,%eax\nsar    $0x1f,%eax\nshr    $0x20,%rdi\nsub    %eax,%edi\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  3a <func0+0x3a>\nmov    %rax,%r8\ntest   %r12d,%r12d\njle    e0 <func0+0xe0>\nxor    %ecx,%ecx\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx,%rcx,4),%edx\nadd    $0x3,%rcx\nmov    %eax,%r11d\nmov    %edx,(%r8,%rax,4)\nadd    $0x1,%rax\ncmp    %ecx,%r12d\njg     50 <func0+0x50>\ntest   %r11d,%r11d\nje     f0 <func0+0xf0>\nlea    -0x1(%r11),%r13d\nxor    %r9d,%r9d\nmov    %r13,%rsi\nnopw   0x0(%rax,%rax,1)\nmov    %r9d,%edi\nmov    %r9d,%r14d\nlea    0x1(%r9),%rdx\ncmp    %r9d,%r11d\njle    cf <func0+0xcf>\nmov    %esi,%eax\nmov    %rdx,%rcx\nsub    %r9d,%eax\nlea    0x2(%r9,%rax,1),%r10\nnopl   0x0(%rax)\nmovslq %edi,%rax\nmov    (%r8,%rax,4),%eax\ncmp    %eax,(%r8,%rcx,4)\ncmovl  %ecx,%edi\nadd    $0x1,%rcx\ncmp    %r10,%rcx\njne    a0 <func0+0xa0>\ncmp    %r14d,%edi\nje     cf <func0+0xcf>\nmovslq %edi,%rdi\nmov    (%r8,%r9,4),%ecx\nlea    (%r8,%rdi,4),%rax\nmov    (%rax),%edi\nmov    %edi,(%r8,%r9,4)\nmov    %ecx,(%rax)\ncmp    %r9,%r13\nje     f0 <func0+0xf0>\nmov    %rdx,%r9\njmp    80 <func0+0x80>\nnopl   0x0(%rax)\npop    %rbx\nmov    %r8,%rdi\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\njmpq   f0 <func0+0xf0>\nlea    -0x1(%r12),%esi\nxor    %eax,%eax\nmov    $0xaaaaaaab,%edi\njmp    11e <func0+0x11e>\nxchg   %ax,%ax\nmov    %eax,%ecx\nimul   %rdi,%rcx\nshr    $0x21,%rcx\nmov    (%r8,%rcx,4),%edx\nmov    %edx,0x0(%rbp,%rax,4)\nlea    0x1(%rax),%rdx\ncmp    %rax,%rsi\nje     e0 <func0+0xe0>\nmov    %rdx,%rax\nimul   $0xaaaaaaab,%eax,%edx\ncmp    $0x55555555,%edx\njbe    100 <func0+0x100>\nmov    (%rbx,%rax,4),%edx\nmov    %edx,0x0(%rbp,%rax,4)\njmp    112 <func0+0x112>"
    },
    {
        "task_id": 33,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rdx,%r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nimul   $0x55555556,%rdi,%rdi\nmov    %r12d,%eax\nsar    $0x1f,%eax\nsub    $0x8,%rsp\nshr    $0x20,%rdi\nsub    %eax,%edi\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  40 <func0+0x40>\nmov    %rax,%rbp\ntest   %r12d,%r12d\njle    1e6 <func0+0x1e6>\nlea    -0x1(%r12),%esi\nmov    $0xaaaaaaab,%eax\nmov    %rsi,%r15\nimul   %rax,%rsi\nshr    $0x21,%rsi\nadd    $0x1,%esi\ncmp    $0x8,%r15d\njbe    210 <func0+0x210>\nmov    %esi,%ecx\nmovdqa 0x0(%rip),%xmm2\n00\nmov    %rbx,%rax\nmov    %rbp,%rdx\nshr    $0x2,%ecx\nmovdqa 0x0(%rip),%xmm4\n00\nshl    $0x4,%rcx\nadd    %rbp,%rcx\nmovd   (%rax),%xmm0\nadd    $0x10,%rdx\nmovdqa %xmm2,%xmm3\nadd    $0x30,%rax\nmovd   -0x18(%rax),%xmm1\nmovd   -0xc(%rax),%xmm5\npaddd  %xmm4,%xmm2\nmovd   -0x24(%rax),%xmm6\npunpckldq %xmm5,%xmm1\npunpckldq %xmm6,%xmm0\npunpcklqdq %xmm1,%xmm0\nmovups %xmm0,-0x10(%rdx)\ncmp    %rcx,%rdx\njne    90 <func0+0x90>\nmov    %esi,%edx\npshufd $0xff,%xmm3,%xmm3\nand    $0xfffffffc,%edx\nmovd   %xmm3,%r10d\nlea    (%rdx,%rdx,2),%eax\ncmp    %esi,%edx\nje     1ff <func0+0x1ff>\ncltq\nmovslq %edx,%rcx\nmov    (%rbx,%rax,4),%eax\nmov    %eax,0x0(%rbp,%rcx,4)\nlea    0x1(%rdx),%ecx\nlea    (%rcx,%rcx,2),%eax\ncmp    %eax,%r12d\njle    1fc <func0+0x1fc>\nmovslq %eax,%rdi\nmovslq %ecx,%rsi\nlea    0x2(%rdx),%r10d\nadd    $0x3,%eax\nmov    (%rbx,%rdi,4),%edi\nmov    %edi,0x0(%rbp,%rsi,4)\ncmp    %r12d,%eax\njge    219 <func0+0x219>\ncltq\nmovslq %r10d,%rdx\nmov    (%rbx,%rax,4),%eax\nmov    %eax,0x0(%rbp,%rdx,4)\nlea    0x4(%rbp),%rdx\nxor    %eax,%eax\nnopl   0x0(%rax)\nmov    -0x4(%rdx),%r14d\nmov    %eax,%r12d\nadd    $0x1,%eax\nmov    %rdx,%rcx\nmov    %r12d,%r11d\nmov    %eax,%esi\nmov    %r14d,%r8d\njmp    166 <func0+0x166>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovslq %r11d,%rdi\nadd    $0x4,%rcx\nlea    0x0(%rbp,%rdi,4),%r9\nlea    0x1(%rsi),%edi\ncmp    %r10d,%esi\njge    182 <func0+0x182>\nmov    %edi,%esi\nmov    (%rcx),%edi\nmov    %rcx,%r9\ncmp    %edi,%r8d\njle    150 <func0+0x150>\nmov    %edi,%r8d\nmov    %esi,%r11d\nlea    0x1(%rsi),%edi\nadd    $0x4,%rcx\ncmp    %r10d,%esi\njl     164 <func0+0x164>\ncmp    %r12d,%r11d\nje     18e <func0+0x18e>\nmov    %r8d,-0x4(%rdx)\nmov    %r14d,(%r9)\nadd    $0x4,%rdx\ncmp    %r10d,%eax\njne    130 <func0+0x130>\nmov    %r15d,%r15d\nxor    %eax,%eax\nmov    $0xaaaaaaab,%ecx\njmp    1c7 <func0+0x1c7>\nnopl   0x0(%rax,%rax,1)\nmov    %eax,%edx\nimul   %rcx,%rdx\nshr    $0x21,%rdx\nmov    0x0(%rbp,%rdx,4),%edx\nmov    %edx,0x0(%r13,%rax,4)\nlea    0x1(%rax),%rdx\ncmp    %rax,%r15\nje     1e6 <func0+0x1e6>\nmov    %rdx,%rax\nimul   $0xaaaaaaab,%eax,%edx\ncmp    $0x55555555,%edx\njbe    1a8 <func0+0x1a8>\nmov    (%rbx,%rax,4),%edx\nmov    %edx,0x0(%r13,%rax,4)\nlea    0x1(%rax),%rdx\ncmp    %rax,%r15\njne    1c4 <func0+0x1c4>\nadd    $0x8,%rsp\nmov    %rbp,%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmpq   1fc <func0+0x1fc>\nmov    %edx,%r10d\ntest   %r10d,%r10d\njg     126 <func0+0x126>\njmp    197 <func0+0x197>\nnopw   0x0(%rax,%rax,1)\nxor    %edx,%edx\nxor    %eax,%eax\njmpq   e2 <func0+0xe2>\nmov    %ecx,%r10d\njmpq   126 <func0+0x126>"
    },
    {
        "task_id": 34,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  28 <func0+0x28>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmpq   d1 <func0+0xd1>\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    8c <func0+0x8c>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    88 <func0+0x88>\nmovl   $0x1,-0x1c(%rbp)\njmp    94 <func0+0x94>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     4f <func0+0x4f>\ncmpl   $0x0,-0x1c(%rbp)\njne    cd <func0+0xcd>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     3f <func0+0x3f>\nmovl   $0x0,-0x14(%rbp)\njmpq   19a <func0+0x19a>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmpq   18a <func0+0x18a>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    186 <func0+0x186>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     f7 <func0+0xf7>\naddl   $0x1,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x14(%rbp)\njl     e9 <func0+0xe9>\nmov    -0x38(%rbp),%rax\nmov    -0x18(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 34,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r12\nmov    %esi,%ebp\nmov    %rdx,%rbx\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncallq  1c <func0+0x1c>\ntest   %ebp,%ebp\njle    80 <func0+0x80>\nmov    %r12,%rdi\nlea    -0x1(%rbp),%edx\nlea    0x4(%r12,%rdx,4),%r9\nmov    $0x0,%r8d\nlea    0x4(%rax),%r10\njmp    a3 <func0+0xa3>\ncmp    $0x1,%r8d\njle    86 <func0+0x86>\nmov    %rax,%rdi\nlea    -0x2(%r8),%r10d\nadd    $0x2,%r10\nmov    $0x1,%r9d\njmp    76 <func0+0x76>\nadd    $0x1,%rdx\ncmp    %edx,%r8d\njle    69 <func0+0x69>\nmov    (%rdi),%ecx\nmov    (%rax,%rdx,4),%esi\ncmp    %esi,%ecx\njle    50 <func0+0x50>\nmov    %esi,(%rdi)\nmov    %ecx,(%rax,%rdx,4)\njmp    50 <func0+0x50>\nadd    $0x1,%r9\nadd    $0x4,%rdi\ncmp    %r10,%r9\nje     86 <func0+0x86>\ncmp    %r9d,%r8d\njle    69 <func0+0x69>\nmov    %r9,%rdx\njmp    59 <func0+0x59>\nmov    $0x0,%r8d\nmov    %r8d,(%rbx)\npop    %rbx\npop    %rbp\npop    %r12\nretq\nmovslq %r8d,%rdx\nmov    (%rdi),%ecx\nmov    %ecx,(%rax,%rdx,4)\nlea    0x1(%r8),%r8d\nadd    $0x4,%rdi\ncmp    %r9,%rdi\nje     37 <func0+0x37>\ntest   %r8d,%r8d\njle    8e <func0+0x8e>\nmov    (%rdi),%ecx\nmov    %rax,%rdx\nlea    -0x1(%r8),%esi\nlea    (%r10,%rsi,4),%rsi\ncmp    (%rdx),%ecx\nje     9a <func0+0x9a>\nadd    $0x4,%rdx\ncmp    %rsi,%rdx\njne    b5 <func0+0xb5>\njmp    8e <func0+0x8e>"
    },
    {
        "task_id": 34,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nshl    $0x2,%rdi\ncallq  1d <func0+0x1d>\ntest   %r12d,%r12d\njle    d9 <func0+0xd9>\nlea    -0x1(%r12),%edx\nmov    %rbx,%r8\nlea    0x4(%rax),%r11\nxor    %r9d,%r9d\nlea    0x4(%rbx,%rdx,4),%r10\nnopw   0x0(%rax,%rax,1)\nmov    (%r8),%esi\ntest   %r9d,%r9d\nje     c0 <func0+0xc0>\nlea    -0x1(%r9),%edx\nmov    %rax,%rcx\nlea    (%r11,%rdx,4),%rdi\njmp    61 <func0+0x61>\nnopl   (%rax)\nadd    $0x4,%rcx\ncmp    %rdi,%rcx\nje     c0 <func0+0xc0>\ncmp    %esi,(%rcx)\njne    58 <func0+0x58>\nadd    $0x4,%r8\ncmp    %r10,%r8\njne    40 <func0+0x40>\ncmp    $0x1,%r9d\nje     b6 <func0+0xb6>\nlea    -0x2(%r9),%edx\nmov    %rax,%r8\nmov    $0x1,%r10d\nadd    $0x2,%rdx\nnopl   (%rax)\nmov    %r10,%rcx\ncmp    %r10d,%r9d\njle    a9 <func0+0xa9>\nmov    (%r8),%esi\nmov    (%rax,%rcx,4),%edi\ncmp    %edi,%esi\njle    a0 <func0+0xa0>\nmov    %edi,(%r8)\nmov    %esi,(%rax,%rcx,4)\nadd    $0x1,%rcx\ncmp    %ecx,%r9d\njg     90 <func0+0x90>\nadd    $0x1,%r10\nadd    $0x4,%r8\ncmp    %rdx,%r10\njne    88 <func0+0x88>\npop    %rbx\nmov    %r9d,0x0(%rbp)\npop    %rbp\npop    %r12\nretq\nnop\nmovslq %r9d,%rdx\nadd    $0x4,%r8\nadd    $0x1,%r9d\nmov    %esi,(%rax,%rdx,4)\ncmp    %r10,%r8\njne    40 <func0+0x40>\njmp    6e <func0+0x6e>\nxor    %r9d,%r9d\npop    %rbx\nmov    %r9d,0x0(%rbp)\npop    %rbp\npop    %r12\nretq"
    },
    {
        "task_id": 34,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nshl    $0x2,%rdi\ncallq  1d <func0+0x1d>\ntest   %r12d,%r12d\njle    d9 <func0+0xd9>\nlea    -0x1(%r12),%edx\nmov    %rbx,%r8\nlea    0x4(%rax),%r11\nxor    %r9d,%r9d\nlea    0x4(%rbx,%rdx,4),%r10\nnopw   0x0(%rax,%rax,1)\nmov    (%r8),%esi\ntest   %r9d,%r9d\nje     c0 <func0+0xc0>\nlea    -0x1(%r9),%edx\nmov    %rax,%rcx\nlea    (%r11,%rdx,4),%rdi\njmp    61 <func0+0x61>\nnopl   (%rax)\nadd    $0x4,%rcx\ncmp    %rcx,%rdi\nje     c0 <func0+0xc0>\ncmp    %esi,(%rcx)\njne    58 <func0+0x58>\nadd    $0x4,%r8\ncmp    %r10,%r8\njne    40 <func0+0x40>\ncmp    $0x1,%r9d\nje     b6 <func0+0xb6>\nlea    -0x2(%r9),%edx\nmov    %rax,%r8\nmov    $0x1,%r10d\nadd    $0x2,%rdx\nnopl   (%rax)\nmov    %r10,%rcx\ncmp    %r10d,%r9d\njle    a9 <func0+0xa9>\nmov    (%r8),%esi\nmov    (%rax,%rcx,4),%edi\ncmp    %edi,%esi\njle    a0 <func0+0xa0>\nmov    %edi,(%r8)\nmov    %esi,(%rax,%rcx,4)\nadd    $0x1,%rcx\ncmp    %ecx,%r9d\njg     90 <func0+0x90>\nadd    $0x1,%r10\nadd    $0x4,%r8\ncmp    %r10,%rdx\njne    88 <func0+0x88>\npop    %rbx\nmov    %r9d,0x0(%rbp)\npop    %rbp\npop    %r12\nretq\nnop\nmovslq %r9d,%rdx\nadd    $0x4,%r8\nadd    $0x1,%r9d\nmov    %esi,(%rax,%rdx,4)\ncmp    %r10,%r8\njne    40 <func0+0x40>\njmp    6e <func0+0x6e>\nxor    %r9d,%r9d\npop    %rbx\nmov    %r9d,0x0(%rbp)\npop    %rbp\npop    %r12\nretq"
    },
    {
        "task_id": 35,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovss  0x0(%rip),%xmm0\n00\nmovss  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    64 <func0+0x64>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncomiss -0x8(%rbp),%xmm0\njbe    60 <func0+0x60>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     25 <func0+0x25>\nmovss  -0x8(%rbp),%xmm0\npop    %rbp\nretq"
    },
    {
        "task_id": 35,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    30 <func0+0x30>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%edx\nlea    0x4(%rdi,%rdx,4),%rdx\nmovss  0x0(%rip),%xmm0\n00\nmovss  (%rax),%xmm1\nmaxss  %xmm0,%xmm1\nmovaps %xmm1,%xmm0\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    1b <func0+0x1b>\nretq\nmovss  0x0(%rip),%xmm0\n00\nretq"
    },
    {
        "task_id": 35,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    38 <func0+0x38>\nlea    -0x1(%rsi),%eax\nmovss  0x0(%rip),%xmm0\n00\nlea    0x4(%rdi,%rax,4),%rax\nnopl   0x0(%rax,%rax,1)\n00\nmovss  (%rdi),%xmm1\nadd    $0x4,%rdi\nmaxss  %xmm0,%xmm1\nmovaps %xmm1,%xmm0\ncmp    %rax,%rdi\njne    20 <func0+0x20>\nretq\nnopl   (%rax)\nmovss  0x0(%rip),%xmm0\n00\nretq"
    },
    {
        "task_id": 35,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    38 <func0+0x38>\nlea    -0x1(%rsi),%eax\nmovss  0x0(%rip),%xmm0\n00\nlea    0x4(%rdi,%rax,4),%rax\nnopl   0x0(%rax,%rax,1)\n00\nmovss  (%rdi),%xmm1\nadd    $0x4,%rdi\nmaxss  %xmm0,%xmm1\nmovaps %xmm1,%xmm0\ncmp    %rax,%rdi\njne    20 <func0+0x20>\nretq\nnopl   (%rax)\nmovss  0x0(%rip),%xmm0\n00\nretq"
    },
    {
        "task_id": 36,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmpq   e0 <func0+0xe0>\nmov    -0x8(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x2e8ba2e9,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%edx\nsar    %edx\nmov    %ecx,%eax\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\nje     7d <func0+0x7d>\nmov    -0x8(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x4ec4ec4f,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%edx\nsar    $0x2,%edx\nmov    %ecx,%eax\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\njne    dc <func0+0xdc>\nmov    -0x8(%rbp),%eax\nmov    %eax,-0x4(%rbp)\njmp    d6 <func0+0xd6>\nmov    -0x4(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%edx\nsar    $0x2,%edx\nmov    %ecx,%eax\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ncmp    $0x7,%edx\njne    b8 <func0+0xb8>\naddl   $0x1,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njg     85 <func0+0x85>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     1e <func0+0x1e>\nmov    -0xc(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 36,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    bb <func0+0xbb>\nmov    $0x0,%ecx\nmov    $0x0,%esi\njmp    23 <func0+0x23>\nadd    $0x1,%ecx\ncmp    %ecx,%edi\nje     c0 <func0+0xc0>\nmovslq %ecx,%rax\nimul   $0x2e8ba2e9,%rax,%rax\nsar    $0x21,%rax\nmov    %ecx,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,4),%edx\nlea    (%rax,%rdx,2),%eax\ncmp    %eax,%ecx\nje     61 <func0+0x61>\nmovslq %ecx,%rax\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x22,%rax\nmov    %ecx,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,2),%edx\nlea    (%rax,%rdx,4),%eax\ncmp    %eax,%ecx\njne    18 <func0+0x18>\ntest   %ecx,%ecx\njle    18 <func0+0x18>\nmov    %ecx,%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%r8d\nsar    $0x1f,%r8d\nsub    %r8d,%eax\nlea    (%rax,%rax,4),%eax\nadd    %eax,%eax\nmov    %edx,%r9d\nsub    %eax,%r9d\ncmp    $0x7,%r9d\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%esi\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%r8d\nsar    $0x1f,%r8d\nsub    %r8d,%eax\ncmp    $0x9,%edx\njle    18 <func0+0x18>\nmov    %eax,%edx\njmp    67 <func0+0x67>\nmov    $0x0,%esi\nmov    %esi,%eax\nretq"
    },
    {
        "task_id": 36,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    7c <func0+0x7c>\nxor    %esi,%esi\nxor    %r8d,%r8d\nmov    $0xcccccccd,%r9d\njmp    2c <func0+0x2c>\nnopl   (%rax)\nimul   $0xc4ec4ec5,%esi,%eax\ncmp    $0x13b13b13,%eax\njbe    39 <func0+0x39>\nadd    $0x1,%esi\ncmp    %esi,%edi\nje     78 <func0+0x78>\nimul   $0xba2e8ba3,%esi,%eax\ncmp    $0x1745d174,%eax\nja     18 <func0+0x18>\nmov    %esi,%edx\ntest   %esi,%esi\njne    4a <func0+0x4a>\njmp    25 <func0+0x25>\nnopl   0x0(%rax)\nmov    %eax,%edx\nmov    %edx,%eax\nmov    %edx,%r10d\nimul   %r9,%rax\nshr    $0x23,%rax\nlea    (%rax,%rax,4),%ecx\nadd    %ecx,%ecx\nsub    %ecx,%r10d\ncmp    $0x7,%r10d\nsete   %cl\nmovzbl %cl,%ecx\nadd    %ecx,%r8d\ncmp    $0x9,%edx\njg     48 <func0+0x48>\nadd    $0x1,%esi\ncmp    %esi,%edi\njne    2c <func0+0x2c>\nmov    %r8d,%eax\nretq\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 36,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    7c <func0+0x7c>\nmov    $0x1,%esi\nxor    %r8d,%r8d\nmov    $0xcccccccd,%r9d\ncmp    $0x1,%edi\njne    34 <func0+0x34>\njmp    78 <func0+0x78>\nnopl   (%rax)\nimul   $0xc4ec4ec5,%esi,%eax\ncmp    $0x13b13b13,%eax\njbe    41 <func0+0x41>\nadd    $0x1,%esi\ncmp    %esi,%edi\nje     78 <func0+0x78>\nimul   $0xba2e8ba3,%esi,%eax\ncmp    $0x1745d174,%eax\nja     20 <func0+0x20>\nmov    %esi,%edx\njmp    4a <func0+0x4a>\nnopl   (%rax)\nmov    %eax,%edx\nmov    %edx,%eax\nmov    %edx,%r10d\nimul   %r9,%rax\nshr    $0x23,%rax\nlea    (%rax,%rax,4),%ecx\nadd    %ecx,%ecx\nsub    %ecx,%r10d\ncmp    $0x7,%r10d\nsete   %cl\nmovzbl %cl,%ecx\nadd    %ecx,%r8d\ncmp    $0x9,%edx\njg     48 <func0+0x48>\nadd    $0x1,%esi\ncmp    %esi,%edi\njne    34 <func0+0x34>\nmov    %r8d,%eax\nretq\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 37,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nadd    $0x1,%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  34 <func0+0x34>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    83 <func0+0x83>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rcx),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x2,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     48 <func0+0x48>\nmovl   $0x0,-0x18(%rbp)\njmpq   168 <func0+0x168>\nmovl   $0x0,-0x14(%rbp)\njmpq   152 <func0+0x152>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\ncomiss %xmm1,%xmm0\njbe    14e <func0+0x14e>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovss  -0xc(%rbp),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nsub    -0x18(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x14(%rbp)\njl     a3 <func0+0xa3>\naddl   $0x1,-0x18(%rbp)\nmov    -0x10(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x18(%rbp)\njl     97 <func0+0x97>\nmovl   $0x0,-0x18(%rbp)\njmp    1f9 <func0+0x1f9>\nmov    -0x18(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    1c5 <func0+0x1c5>\nmov    -0x18(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x38(%rbp),%rax\nadd    %rcx,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\njmp    1f5 <func0+0x1f5>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x38(%rbp),%rax\nadd    %rcx,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     180 <func0+0x180>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncallq  211 <func0+0x211>\nnop\nleaveq\nretq"
    },
    {
        "task_id": 37,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbp\nmov    %esi,%ebx\nmov    %rdx,%r12\nmov    %esi,%edi\nshr    $0x1f,%edi\nadd    %esi,%edi\nsar    %edi\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  28 <func0+0x28>\nmov    %rax,%rdi\ntest   %ebx,%ebx\njle    c5 <func0+0xc5>\nmov    $0x0,%edx\nmovss  0x0(%rbp,%rdx,4),%xmm0\nmovss  %xmm0,(%rdi,%rdx,2)\nadd    $0x2,%rdx\ncmp    %edx,%ebx\njg     38 <func0+0x38>\nlea    -0x1(%rbx),%esi\nshr    %esi\nje     cf <func0+0xcf>\nlea    0x4(%rdi),%r8\njmp    7f <func0+0x7f>\nadd    $0x4,%rdx\ncmp    %rcx,%rdx\nje     7a <func0+0x7a>\nmovss  (%rdx),%xmm0\nmovss  0x4(%rdx),%xmm1\ncomiss %xmm1,%xmm0\njbe    58 <func0+0x58>\nmovss  %xmm1,(%rdx)\nmovss  %xmm0,0x4(%rdx)\njmp    58 <func0+0x58>\nsub    $0x1,%esi\nje     cf <func0+0xcf>\ntest   %esi,%esi\njle    7a <func0+0x7a>\nmov    %rdi,%rdx\nlea    -0x1(%rsi),%eax\nlea    (%r8,%rax,4),%rcx\njmp    61 <func0+0x61>\nmovss  0x0(%rbp,%rdx,4),%xmm0\nmovss  %xmm0,(%r12,%rdx,4)\nlea    0x1(%rdx),%rax\ncmp    %rdx,%rsi\nje     c5 <func0+0xc5>\nmov    %rax,%rdx\ntest   $0x1,%dl\njne    8f <func0+0x8f>\nmov    %edx,%ecx\nshr    $0x1f,%ecx\nadd    %edx,%ecx\nsar    %ecx\nmovslq %ecx,%rcx\nmovss  (%rdi,%rcx,4),%xmm0\nmovss  %xmm0,(%r12,%rdx,4)\njmp    9b <func0+0x9b>\ncallq  ca <func0+0xca>\npop    %rbx\npop    %rbp\npop    %r12\nretq\nlea    -0x1(%rbx),%esi\nmov    $0x0,%edx\njmp    a7 <func0+0xa7>"
    },
    {
        "task_id": 37,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %rdi,%rbp\nmov    %esi,%edi\nshr    $0x1f,%edi\npush   %rbx\nmov    %esi,%ebx\nadd    %esi,%edi\nsar    %edi\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  28 <func0+0x28>\nmov    %rax,%r8\ntest   %ebx,%ebx\njle    d8 <func0+0xd8>\nxor    %ecx,%ecx\nnopl   (%rax)\nmovss  0x0(%rbp,%rcx,4),%xmm0\nmovss  %xmm0,(%r8,%rcx,2)\nadd    $0x2,%rcx\ncmp    %ecx,%ebx\njg     38 <func0+0x38>\nsub    $0x1,%ebx\nmov    %ebx,%esi\nshr    %esi\nje     96 <func0+0x96>\nlea    0x4(%r8),%rdx\nnopl   0x0(%rax)\nlea    -0x1(%rsi),%eax\nmov    %r8,%rcx\nmov    %rax,%rdi\nlea    (%rdx,%rax,4),%rsi\nnopl   (%rax)\nmovss  (%rcx),%xmm0\nmovss  0x4(%rcx),%xmm1\ncomiss %xmm1,%xmm0\njbe    87 <func0+0x87>\nmovss  %xmm1,(%rcx)\nmovss  %xmm0,0x4(%rcx)\nadd    $0x4,%rcx\ncmp    %rsi,%rcx\njne    70 <func0+0x70>\nmov    %edi,%esi\ntest   %edi,%edi\njne    60 <func0+0x60>\nmov    %ebx,%esi\nxor    %ecx,%ecx\njmp    be <func0+0xbe>\nnopl   0x0(%rax)\nmov    %ecx,%eax\nsar    %eax\ncltq\nmovss  (%r8,%rax,4),%xmm0\nlea    0x1(%rcx),%rax\nmovss  %xmm0,(%r12,%rcx,4)\ncmp    %rcx,%rsi\nje     d8 <func0+0xd8>\nmov    %rax,%rcx\ntest   $0x1,%cl\nje     a0 <func0+0xa0>\nmovss  0x0(%rbp,%rcx,4),%xmm0\nlea    0x1(%rcx),%rax\nmovss  %xmm0,(%r12,%rcx,4)\ncmp    %rcx,%rsi\njne    bb <func0+0xbb>\npop    %rbx\nmov    %r8,%rdi\npop    %rbp\npop    %r12\njmpq   e4 <func0+0xe4>"
    },
    {
        "task_id": 37,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %esi,%r12d\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %esi,%edi\nshr    $0x1f,%edi\nadd    %esi,%edi\nsar    %edi\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  29 <func0+0x29>\nmov    %rax,%r8\ntest   %r12d,%r12d\njle    16f <func0+0x16f>\nlea    -0x1(%r12),%edx\nmov    %edx,%edi\nshr    %edi\ncmp    $0x7,%edx\njbe    1a0 <func0+0x1a0>\nmov    %edx,%eax\nxor    %ecx,%ecx\nshr    $0x3,%eax\nmov    %eax,%esi\nshl    $0x4,%rsi\nnopl   0x0(%rax)\nmovups (%rbx,%rcx,2),%xmm0\nmovups 0x10(%rbx,%rcx,2),%xmm2\nshufps $0x88,%xmm2,%xmm0\nmovups %xmm0,(%r8,%rcx,1)\nadd    $0x10,%rcx\ncmp    %rsi,%rcx\njne    58 <func0+0x58>\nlea    0x0(,%rax,4),%ecx\nshl    $0x3,%eax\nmovslq %eax,%r10\nmovslq %ecx,%rsi\nlea    0x1(%rcx),%r9d\nmovss  (%rbx,%r10,4),%xmm0\nmovss  %xmm0,(%r8,%rsi,4)\nlea    0x2(%rax),%esi\ncmp    %r12d,%esi\njge    18d <func0+0x18d>\nmovslq %esi,%rsi\nmovslq %r9d,%r9\nadd    $0x2,%ecx\nmovss  (%rbx,%rsi,4),%xmm0\nlea    0x4(%rax),%esi\nmovss  %xmm0,(%r8,%r9,4)\ncmp    %esi,%r12d\njle    ea <func0+0xea>\nmovslq %esi,%rsi\nmovslq %ecx,%rcx\nadd    $0x6,%eax\nmovss  (%rbx,%rsi,4),%xmm0\nlea    0x0(,%rcx,4),%r9\n00\nmovss  %xmm0,(%r8,%rcx,4)\ncmp    %eax,%r12d\njle    ea <func0+0xea>\ncltq\nmovss  (%rbx,%rax,4),%xmm0\nmovss  %xmm0,0x4(%r8,%r9,1)\nlea    0x4(%r8),%r9\nxchg   %ax,%ax\ntest   %edi,%edi\njle    180 <func0+0x180>\nlea    -0x1(%rdi),%eax\nmov    %r8,%rcx\nmov    %rax,%rdi\nlea    (%r9,%rax,4),%rsi\nnopl   (%rax)\nmovss  (%rcx),%xmm0\nmovss  0x4(%rcx),%xmm1\ncomiss %xmm1,%xmm0\njbe    11f <func0+0x11f>\nmovss  %xmm1,(%rcx)\nmovss  %xmm0,0x4(%rcx)\nadd    $0x4,%rcx\ncmp    %rsi,%rcx\njne    108 <func0+0x108>\ntest   %edi,%edi\njne    f0 <func0+0xf0>\nmov    %edx,%edx\nxor    %ecx,%ecx\njmp    156 <func0+0x156>\nnopw   0x0(%rax,%rax,1)\nmov    %ecx,%eax\nsar    %eax\ncltq\nmovss  (%r8,%rax,4),%xmm0\nlea    0x1(%rcx),%rax\nmovss  %xmm0,0x0(%rbp,%rcx,4)\ncmp    %rdx,%rcx\nje     16f <func0+0x16f>\nmov    %rax,%rcx\ntest   $0x1,%cl\nje     138 <func0+0x138>\nmovss  (%rbx,%rcx,4),%xmm0\nlea    0x1(%rcx),%rax\nmovss  %xmm0,0x0(%rbp,%rcx,4)\ncmp    %rdx,%rcx\njne    153 <func0+0x153>\npop    %rbx\nmov    %r8,%rdi\npop    %rbp\npop    %r12\njmpq   17b <func0+0x17b>\nnopl   0x0(%rax,%rax,1)\nsub    $0x1,%edi\ntest   %edi,%edi\njne    f0 <func0+0xf0>\njmp    12c <func0+0x12c>\ntest   %edi,%edi\njne    ea <func0+0xea>\njmp    12c <func0+0x12c>\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %ecx,%ecx\nxor    %eax,%eax\njmpq   7d <func0+0x7d>"
    },
    {
        "task_id": 38,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  2e <func0+0x2e>\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nadd    $0x2,%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x1f,%eax\nmov    %edx,%ecx\nsub    %eax,%ecx\nmov    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmpq   12d <func0+0x12d>\nmov    -0x1c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncmp    %eax,-0x18(%rbp)\njge    7f <func0+0x7f>\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshl    $0x2,%eax\nsub    %eax,%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\njmp    84 <func0+0x84>\nmov    $0x3,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x1c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rsi\nlea    -0xc(%rbp),%rax\nmov    %rcx,%rdx\nmov    %rax,%rdi\ncallq  b0 <func0+0xb0>\nmov    -0x10(%rbp),%eax\ncltq\nmovb   $0x0,-0xc(%rbp,%rax,1)\ncmpl   $0x3,-0x10(%rbp)\njne    100 <func0+0x100>\ncmpl   $0x0,-0x2c(%rbp)\nje     e4 <func0+0xe4>\nmovzbl -0xa(%rbp),%eax\nmov    %al,-0x1d(%rbp)\nmovzbl -0xb(%rbp),%eax\nmov    %al,-0xa(%rbp)\nmovzbl -0xc(%rbp),%eax\nmov    %al,-0xb(%rbp)\nmovzbl -0x1d(%rbp),%eax\nmov    %al,-0xc(%rbp)\njmp    100 <func0+0x100>\nmovzbl -0xc(%rbp),%eax\nmov    %al,-0x1e(%rbp)\nmovzbl -0xb(%rbp),%eax\nmov    %al,-0xc(%rbp)\nmovzbl -0xa(%rbp),%eax\nmov    %al,-0xb(%rbp)\nmovzbl -0x1e(%rbp),%eax\nmov    %al,-0xa(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x1c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rdi\nlea    -0xc(%rbp),%rax\nmov    %rcx,%rdx\nmov    %rax,%rsi\ncallq  129 <func0+0x129>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     5d <func0+0x5d>\nnop\nmov    -0x8(%rbp),%rax\nxor    %fs:0x28,%rax\n00 00\nje     14e <func0+0x14e>\ncallq  14e <func0+0x14e>\nleaveq\nretq"
    },
    {
        "task_id": 38,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,%r12\nmov    %esi,0xc(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmov    $0xffffffffffffffff,%rcx\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%rbp\nmov    %ebp,0x8(%rsp)\nlea    0x2(%rbp),%eax\nmovslq %eax,%r15\nimul   $0x55555556,%r15,%r15\nshr    $0x20,%r15\nsar    $0x1f,%eax\nsub    %eax,%r15d\ntest   %ebp,%ebp\njle    117 <func0+0x117>\nmov    $0x0,%ebx\nlea    0x14(%rsp),%r14\njmp    a8 <func0+0xa8>\nmovslq %ebp,%r13\nmov    %r12,(%rsp)\nmov    $0x4,%ecx\nmov    %r13,%rdx\nmov    %r12,%rsi\nmov    %r14,%rdi\ncallq  82 <func0+0x82>\nmovb   $0x0,0x14(%rsp,%r13,1)\ncmp    $0x3,%ebp\nje     d3 <func0+0xd3>\nmov    %r13,%rdx\nmov    %r14,%rsi\nmov    (%rsp),%rdi\ncallq  9c <func0+0x9c>\nadd    $0x3,%r12\nsub    $0x3,%ebp\ncmp    %r15d,%ebx\njge    117 <func0+0x117>\nadd    $0x1,%ebx\nlea    (%rbx,%rbx,2),%eax\ncmp    %eax,0x8(%rsp)\njl     68 <func0+0x68>\nmov    %r12,(%rsp)\nmov    $0x3,%edx\nmov    %r12,%rsi\nmov    %r14,%rdi\ncallq  c8 <func0+0xc8>\nmovb   $0x0,0x17(%rsp)\nmov    $0x3,%r13d\ncmpl   $0x0,0xc(%rsp)\nje     f7 <func0+0xf7>\nmovzbl 0x16(%rsp),%eax\nmovzbl 0x15(%rsp),%edx\nmov    %dl,0x16(%rsp)\nmovzbl 0x14(%rsp),%edx\nmov    %dl,0x15(%rsp)\nmov    %al,0x14(%rsp)\njmp    8d <func0+0x8d>\nmovzbl 0x14(%rsp),%eax\nmovzbl 0x15(%rsp),%edx\nmov    %dl,0x14(%rsp)\nmovzbl 0x16(%rsp),%edx\nmov    %dl,0x15(%rsp)\nmov    %al,0x16(%rsp)\njmpq   8d <func0+0x8d>\nmov    0x18(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    136 <func0+0x136>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\ncallq  13b <func0+0x13b>"
    },
    {
        "task_id": 38,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x28,%rsp\nmov    %esi,0xc(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncallq  2e <func0+0x2e>\nlea    0x2(%rax),%edx\nlea    (%rax,%rbx,1),%edi\nmov    %eax,0x4(%rsp)\nmovslq %edx,%r12\nsar    $0x1f,%edx\nmov    %edi,0x8(%rsp)\nimul   $0x55555556,%r12,%r12\nshr    $0x20,%r12\nsub    %edx,%r12d\ntest   %eax,%eax\njle    120 <func0+0x120>\nxor    %r15d,%r15d\nlea    0x14(%rsp),%rbp\njmp    c7 <func0+0xc7>\nnopw   0x0(%rax,%rax,1)\nmov    $0x3,%edx\nmov    %rbx,%rsi\nmov    %rbp,%rdi\ncallq  78 <func0+0x78>\nmovb   $0x0,0x17(%rsp)\nmov    0xc(%rsp),%esi\nmovzbl 0x15(%rsp),%ecx\nmovzbl 0x16(%rsp),%edx\nmovzbl 0x14(%rsp),%eax\ntest   %esi,%esi\nje     108 <func0+0x108>\nmov    %cl,0x16(%rsp)\nmov    $0x3,%r14d\nmov    %al,0x15(%rsp)\nmov    %dl,0x14(%rsp)\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    %rbx,%rdi\nmov    %r14,%rdx\nmov    %rbp,%rsi\nadd    $0x3,%rbx\ncallq  c2 <func0+0xc2>\ncmp    %r12d,%r15d\njge    120 <func0+0x120>\nadd    $0x1,%r15d\nlea    (%r15,%r15,2),%eax\ncmp    0x4(%rsp),%eax\njle    68 <func0+0x68>\nmov    0x8(%rsp),%r13d\nmov    $0x4,%ecx\nmov    %rbx,%rsi\nmov    %rbp,%rdi\nsub    %ebx,%r13d\nmovslq %r13d,%r14\nmov    %r14,%rdx\ncallq  f3 <func0+0xf3>\nmovb   $0x0,0x14(%rsp,%r14,1)\ncmp    $0x3,%r13d\njne    b0 <func0+0xb0>\njmpq   7d <func0+0x7d>\nnopl   0x0(%rax)\nmov    %cl,0x14(%rsp)\nmov    $0x3,%r14d\nmov    %dl,0x15(%rsp)\nmov    %al,0x16(%rsp)\njmp    b0 <func0+0xb0>\nnopl   0x0(%rax)\nmov    0x18(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    13f <func0+0x13f>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\ncallq  144 <func0+0x144>"
    },
    {
        "task_id": 38,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %esi,%r15d\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncallq  2d <func0+0x2d>\nmov    %rax,%rbp\nmov    %eax,%r13d\nadd    $0x2,%eax\nmovslq %eax,%r12\nsar    $0x1f,%eax\nimul   $0x55555556,%r12,%r12\nshr    $0x20,%r12\nsub    %eax,%r12d\ntest   %ebp,%ebp\njle    e8 <func0+0xe8>\ntest   %r15d,%r15d\njne    110 <func0+0x110>\nlea    0x14(%rsp),%r14\njmp    ac <func0+0xac>\nnopw   0x0(%rax,%rax,1)\nmov    $0x3,%edx\nmov    %rbx,%rsi\nmov    %r14,%rdi\ncallq  78 <func0+0x78>\nmovb   $0x0,0x17(%rsp)\nmovzbl 0x14(%rsp),%eax\nmovzwl 0x15(%rsp),%edx\nmov    %al,0x16(%rsp)\nmov    %dx,0x14(%rsp)\nmov    $0x3,%edx\nmov    %rbx,%rdi\nmov    %r14,%rsi\nadd    $0x3,%rbx\nsub    $0x3,%ebp\ncallq  a7 <func0+0xa7>\ncmp    %r15d,%r12d\njle    e8 <func0+0xe8>\nadd    $0x1,%r15d\nlea    (%r15,%r15,2),%eax\ncmp    %eax,%r13d\njge    68 <func0+0x68>\nmovslq %ebp,%rdx\nmov    $0x4,%ecx\nmov    %rbx,%rsi\nmov    %r14,%rdi\nmov    %rdx,0x8(%rsp)\ncallq  d1 <func0+0xd1>\nmov    0x8(%rsp),%rdx\nmovb   $0x0,0x14(%rsp,%rdx,1)\ncmp    $0x3,%ebp\njne    95 <func0+0x95>\njmp    7d <func0+0x7d>\nnopw   0x0(%rax,%rax,1)\nmov    0x18(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    19a <func0+0x19a>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax,%rax,1)\nxor    %r15d,%r15d\nlea    0x14(%rsp),%r14\njmp    164 <func0+0x164>\nnopw   0x0(%rax,%rax,1)\nmov    $0x3,%edx\nmov    %rbx,%rsi\nmov    %r14,%rdi\ncallq  130 <func0+0x130>\nmovb   $0x0,0x17(%rsp)\nmovzbl 0x16(%rsp),%eax\nmovzwl 0x14(%rsp),%edx\nmov    %al,0x14(%rsp)\nmov    %dx,0x15(%rsp)\nmov    $0x3,%edx\nmov    %rbx,%rdi\nmov    %r14,%rsi\nadd    $0x3,%rbx\nsub    $0x3,%ebp\ncallq  15f <func0+0x15f>\ncmp    %r12d,%r15d\njge    e8 <func0+0xe8>\nadd    $0x1,%r15d\nlea    (%r15,%r15,2),%eax\ncmp    %eax,%r13d\njge    120 <func0+0x120>\nmovslq %ebp,%rdx\nmov    $0x4,%ecx\nmov    %rbx,%rsi\nmov    %r14,%rdi\nmov    %rdx,0x8(%rsp)\ncallq  189 <func0+0x189>\nmov    0x8(%rsp),%rdx\nmovb   $0x0,0x14(%rsp,%rdx,1)\ncmp    $0x3,%ebp\njne    14d <func0+0x14d>\njmp    135 <func0+0x135>\ncallq  19f <func0+0x19f>"
    },
    {
        "task_id": 39,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmovl   $0x1,-0x18(%rbp)\nmovl   $0x2,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    86 <func0+0x86>\nmov    -0x14(%rbp),%eax\nadd    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x2,-0x8(%rbp)\njmp    64 <func0+0x64>\nmov    -0x18(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    60 <func0+0x60>\nmovl   $0x0,-0xc(%rbp)\njmp    6f <func0+0x6f>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x18(%rbp)\njge    4a <func0+0x4a>\ncmpl   $0x0,-0xc(%rbp)\nje     79 <func0+0x79>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njne    86 <func0+0x86>\nmov    -0x18(%rbp),%eax\njmp    93 <func0+0x93>\nmov    -0x10(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     22 <func0+0x22>\nmov    $0x0,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 39,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x0,%r8d\nmov    $0x2,%esi\nmov    $0x1,%eax\njmp    2c <func0+0x2c>\nmov    $0x0,%esi\nmov    %esi,%eax\nretq\nadd    $0x1,%r8d\ncmp    %r8d,%edi\nje     1b <func0+0x1b>\nmov    %esi,%eax\nmov    %r9d,%esi\ncmp    %edi,%r8d\njge    16 <func0+0x16>\nlea    (%rax,%rsi,1),%r9d\ncmp    $0x3,%esi\njle    1e <func0+0x1e>\ntest   $0x1,%sil\nje     27 <func0+0x27>\nmov    $0x2,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njg     1e <func0+0x1e>\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    45 <func0+0x45>\njmp    27 <func0+0x27>"
    },
    {
        "task_id": 39,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    58 <func0+0x58>\nxor    %r9d,%r9d\nmov    $0x2,%esi\nmov    $0x1,%eax\nnopl   (%rax)\nmov    %esi,%r8d\nadd    %eax,%esi\ncmp    $0x3,%r8d\njle    47 <func0+0x47>\ntest   $0x1,%r8b\nje     50 <func0+0x50>\nmov    $0x2,%ecx\njmp    3a <func0+0x3a>\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     50 <func0+0x50>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %r8d,%eax\njle    30 <func0+0x30>\nadd    $0x1,%r9d\ncmp    %r9d,%edi\nje     5b <func0+0x5b>\nmov    %r8d,%eax\ncmp    %r9d,%edi\njg     18 <func0+0x18>\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 39,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    58 <func0+0x58>\nxor    %r9d,%r9d\nmov    $0x2,%esi\nmov    $0x1,%eax\nnopl   (%rax)\nmov    %esi,%r8d\nadd    %eax,%esi\ncmp    $0x3,%r8d\njle    47 <func0+0x47>\ntest   $0x1,%r8b\nje     50 <func0+0x50>\nmov    $0x2,%ecx\njmp    3a <func0+0x3a>\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     50 <func0+0x50>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %r8d,%eax\njle    30 <func0+0x30>\nadd    $0x1,%r9d\ncmp    %r9d,%edi\nje     5b <func0+0x5b>\nmov    %r8d,%eax\ncmp    %r9d,%edi\njg     18 <func0+0x18>\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 40,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmpq   9e <func0+0x9e>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x8(%rbp)\njmp    92 <func0+0x92>\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    86 <func0+0x86>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nadd    %eax,%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nadd    %edx,%eax\ntest   %eax,%eax\njne    82 <func0+0x82>\nmov    $0x1,%eax\njmp    af <func0+0xaf>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     31 <func0+0x31>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     26 <func0+0x26>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1b <func0+0x1b>\nmov    $0x0,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 40,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    4e <func0+0x4e>\nlea    -0x1(%rsi),%r9d\nadd    $0x1,%r9\nmov    $0x1,%r8d\ncmp    %r9,%r8\nje     54 <func0+0x54>\nlea    0x1(%r8),%r10\nmov    %r10,%rcx\ncmp    %ecx,%esi\njle    49 <func0+0x49>\nmov    -0x4(%rdi,%rcx,4),%edx\nadd    -0x4(%rdi,%r8,4),%edx\nmov    %rcx,%rax\nmov    %edx,%r11d\nadd    (%rdi,%rax,4),%r11d\nje     5a <func0+0x5a>\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     32 <func0+0x32>\nadd    $0x1,%rcx\njmp    22 <func0+0x22>\nmov    %r10,%r8\njmp    16 <func0+0x16>\nmov    $0x0,%eax\nretq\nmov    $0x0,%eax\nretq\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 40,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    5d <func0+0x5d>\nlea    -0x1(%rsi),%r9d\nmov    $0x1,%r8d\nadd    $0x1,%r9\ncmp    %r9,%r8\nje     5d <func0+0x5d>\nlea    0x1(%r8),%r10\nmov    %r10,%rcx\ncmp    %ecx,%esi\njle    58 <func0+0x58>\nmov    -0x4(%rdi,%rcx,4),%edx\nmov    %rcx,%rax\nadd    -0x4(%rdi,%r8,4),%edx\njmp    40 <func0+0x40>\nnopl   0x0(%rax)\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    50 <func0+0x50>\nmov    %edx,%r11d\nadd    (%rdi,%rax,4),%r11d\njne    38 <func0+0x38>\nmov    $0x1,%eax\nretq\nnop\nadd    $0x1,%rcx\ncmp    %ecx,%esi\njg     26 <func0+0x26>\nmov    %r10,%r8\njmp    16 <func0+0x16>\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 40,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    5d <func0+0x5d>\nlea    -0x1(%rsi),%r9d\nmov    $0x1,%r8d\nadd    $0x1,%r9\ncmp    %r9,%r8\nje     5d <func0+0x5d>\nlea    0x1(%r8),%r10\nmov    %r10,%rcx\ncmp    %ecx,%esi\njle    58 <func0+0x58>\nmov    -0x4(%rdi,%rcx,4),%edx\nmov    %rcx,%rax\nadd    -0x4(%rdi,%r8,4),%edx\njmp    40 <func0+0x40>\nnopl   0x0(%rax)\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    50 <func0+0x50>\nmov    %edx,%r11d\nadd    (%rdi,%rax,4),%r11d\njne    38 <func0+0x38>\nmov    $0x1,%eax\nretq\nnop\nadd    $0x1,%rcx\ncmp    %ecx,%esi\njg     26 <func0+0x26>\nmov    %r10,%r8\njmp    16 <func0+0x16>\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 41,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 41,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nimul   %edi,%edi\nmov    %edi,%eax\nretq"
    },
    {
        "task_id": 41,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nimul   %edi,%eax\nretq"
    },
    {
        "task_id": 41,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nimul   %edi,%eax\nretq"
    },
    {
        "task_id": 42,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    4b <func0+0x4b>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nadd    $0x1,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     18 <func0+0x18>\nnop\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 42,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1f <func0+0x1f>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%edx\nlea    0x4(%rdi,%rdx,4),%rdx\naddl   $0x1,(%rax)\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    13 <func0+0x13>\nretq"
    },
    {
        "task_id": 42,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1c <func0+0x1c>\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rax\naddl   $0x1,(%rdi)\nadd    $0x4,%rdi\ncmp    %rax,%rdi\njne    10 <func0+0x10>\nretq"
    },
    {
        "task_id": 42,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    72 <func0+0x72>\nlea    -0x1(%rsi),%eax\ncmp    $0x2,%eax\njbe    79 <func0+0x79>\nmov    %esi,%edx\nmovdqa 0x0(%rip),%xmm1\n00\nmov    %rdi,%rax\nshr    $0x2,%edx\nshl    $0x4,%rdx\nadd    %rdi,%rdx\nnopw   0x0(%rax,%rax,1)\n00 00\nmovdqu (%rax),%xmm0\nadd    $0x10,%rax\npaddd  %xmm1,%xmm0\nmovups %xmm0,-0x10(%rax)\ncmp    %rdx,%rax\njne    30 <func0+0x30>\nmov    %esi,%eax\nand    $0xfffffffc,%eax\ntest   $0x3,%sil\nje     78 <func0+0x78>\nmovslq %eax,%rdx\naddl   $0x1,(%rdi,%rdx,4)\nlea    0x1(%rax),%edx\ncmp    %edx,%esi\njle    72 <func0+0x72>\nmovslq %edx,%rdx\nadd    $0x2,%eax\naddl   $0x1,(%rdi,%rdx,4)\ncmp    %eax,%esi\njle    72 <func0+0x72>\ncltq\naddl   $0x1,(%rdi,%rax,4)\nretq\nnopl   0x0(%rax,%rax,1)\nretq\nxor    %eax,%eax\njmp    50 <func0+0x50>"
    },
    {
        "task_id": 43,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    6c <func0+0x6c>\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    60 <func0+0x60>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nadd    %edx,%eax\ntest   %eax,%eax\njne    5c <func0+0x5c>\nmov    $0x1,%eax\njmp    79 <func0+0x79>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     23 <func0+0x23>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     18 <func0+0x18>\nmov    $0x0,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 43,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    38 <func0+0x38>\nlea    -0x1(%rsi),%r8d\nadd    $0x1,%r8\nmov    $0x1,%ecx\ncmp    %r8,%rcx\nje     3e <func0+0x3e>\nmov    -0x4(%rdi,%rcx,4),%edx\nmov    %rcx,%rax\nmov    %edx,%r9d\nadd    (%rdi,%rax,4),%r9d\nje     44 <func0+0x44>\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     21 <func0+0x21>\nadd    $0x1,%rcx\njmp    15 <func0+0x15>\nmov    $0x0,%eax\nretq\nmov    $0x0,%eax\nretq\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 43,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    49 <func0+0x49>\nlea    -0x1(%rsi),%r8d\nmov    $0x1,%ecx\nadd    $0x1,%r8\ncmp    %r8,%rcx\nje     49 <func0+0x49>\nmov    -0x4(%rdi,%rcx,4),%edx\nmov    %rcx,%rax\njmp    30 <func0+0x30>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    40 <func0+0x40>\nmov    %edx,%r9d\nadd    (%rdi,%rax,4),%r9d\njne    28 <func0+0x28>\nmov    $0x1,%eax\nretq\nnop\nadd    $0x1,%rcx\ncmp    %r8,%rcx\njne    1a <func0+0x1a>\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 43,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    49 <func0+0x49>\nlea    -0x1(%rsi),%r8d\nmov    $0x1,%ecx\nadd    $0x1,%r8\ncmp    %rcx,%r8\nje     49 <func0+0x49>\nmov    -0x4(%rdi,%rcx,4),%edx\nmov    %rcx,%rax\njmp    30 <func0+0x30>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    40 <func0+0x40>\nmov    %edx,%r9d\nadd    (%rdi,%rax,4),%r9d\njne    28 <func0+0x28>\nmov    $0x1,%eax\nretq\nnop\nadd    $0x1,%rcx\ncmp    %rcx,%r8\njne    1a <func0+0x1a>\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 44,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %esi,-0x48(%rbp)\nmov    %rdx,-0x50(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x38(%rbp)\njmp    55 <func0+0x55>\nmov    -0x44(%rbp),%eax\ncltd\nidivl  -0x48(%rbp)\nmov    %edx,%eax\nlea    0x30(%rax),%ecx\nmov    -0x38(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x38(%rbp)\nmov    %ecx,%edx\ncltq\nmov    %dl,-0x30(%rbp,%rax,1)\nmov    -0x44(%rbp),%eax\ncltd\nidivl  -0x48(%rbp)\nmov    %eax,-0x44(%rbp)\ncmpl   $0x0,-0x44(%rbp)\njg     2e <func0+0x2e>\nmovl   $0x0,-0x34(%rbp)\njmp    87 <func0+0x87>\nsubl   $0x1,-0x38(%rbp)\nmov    -0x34(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x34(%rbp)\nmovslq %eax,%rdx\nmov    -0x50(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmov    %al,(%rdx)\ncmpl   $0x0,-0x38(%rbp)\njg     64 <func0+0x64>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x50(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\nmov    -0x8(%rbp),%rax\nxor    %fs:0x28,%rax\n00 00\nje     b2 <func0+0xb2>\ncallq  b2 <func0+0xb2>\nleaveq\nretq"
    },
    {
        "task_id": 44,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x38,%rsp\nmov    %rdx,%r9\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\ntest   %edi,%edi\njle    8d <func0+0x8d>\nmov    $0x1,%ecx\nlea    -0x1(%rsp),%r11\nmov    %ecx,%r8d\nmov    %edi,%eax\ncltd\nidiv   %esi\nlea    0x30(%rdx),%edi\nmov    %dil,(%r11,%rcx,1)\nmov    %eax,%edi\nadd    $0x1,%rcx\ntest   %eax,%eax\njg     29 <func0+0x29>\ntest   %r8d,%r8d\njle    95 <func0+0x95>\nmovslq %r8d,%rcx\nlea    (%rsp,%rcx,1),%rax\nmov    %r9,%rdx\nlea    -0x1(%rsp,%rcx,1),%rsi\nlea    -0x1(%r8),%ecx\nsub    %rcx,%rsi\nmovzbl -0x1(%rax),%ecx\nmov    %cl,(%rdx)\nsub    $0x1,%rax\nadd    $0x1,%rdx\ncmp    %rsi,%rax\njne    5d <func0+0x5d>\nmovslq %r8d,%r8\nmovb   $0x0,(%r9,%r8,1)\nmov    0x28(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    9d <func0+0x9d>\nadd    $0x38,%rsp\nretq\nmov    $0x0,%r8d\njmp    70 <func0+0x70>\nmov    $0x0,%r8d\njmp    70 <func0+0x70>\ncallq  a2 <func0+0xa2>"
    },
    {
        "task_id": 44,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x38,%rsp\nmov    %edi,%eax\nmov    %rdx,%r8\nmov    %fs:0x28,%rdi\n00 00\nmov    %rdi,0x28(%rsp)\nxor    %edi,%edi\ntest   %eax,%eax\njle    76 <func0+0x76>\nmov    $0x1,%ecx\nlea    -0x1(%rsp),%r10\nnopl   0x0(%rax,%rax,1)\ncltd\nmovslq %ecx,%rdi\nmov    %rcx,%r9\nidiv   %esi\nadd    $0x30,%edx\nmov    %dl,(%r10,%rcx,1)\nadd    $0x1,%rcx\ntest   %eax,%eax\njg     30 <func0+0x30>\nlea    -0x1(%r9),%esi\nmov    %r8,%rax\nlea    (%rsp,%rdi,1),%rcx\nadd    %r8,%rsi\njmp    68 <func0+0x68>\nnopl   0x0(%rax,%rax,1)\n00\nmovzbl -0x1(%rcx),%edx\nadd    $0x1,%rax\nmov    %dl,(%rax)\nsub    $0x1,%rcx\ncmp    %rax,%rsi\njne    60 <func0+0x60>\nadd    %rdi,%r8\nmovb   $0x0,(%r8)\nmov    0x28(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    8f <func0+0x8f>\nadd    $0x38,%rsp\nretq\ncallq  94 <func0+0x94>"
    },
    {
        "task_id": 44,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x38,%rsp\nmov    %edi,%eax\nmov    %rdx,%r8\nmov    %fs:0x28,%rdi\n00 00\nmov    %rdi,0x28(%rsp)\nxor    %edi,%edi\ntest   %eax,%eax\njle    76 <func0+0x76>\nmov    $0x1,%ecx\nlea    -0x1(%rsp),%r10\nnopl   0x0(%rax,%rax,1)\ncltd\nmovslq %ecx,%rdi\nmov    %rcx,%r9\nidiv   %esi\nadd    $0x30,%edx\nmov    %dl,(%r10,%rcx,1)\nadd    $0x1,%rcx\ntest   %eax,%eax\njg     30 <func0+0x30>\nmov    %rsp,%rax\nlea    -0x1(%r9),%ecx\nlea    -0x1(%rax,%rdi,1),%rdx\nlea    0x1(%r8,%rcx,1),%rsi\nmov    %r8,%rax\nnopl   0x0(%rax)\nmovzbl (%rdx),%ecx\nadd    $0x1,%rax\nsub    $0x1,%rdx\nmov    %cl,-0x1(%rax)\ncmp    %rsi,%rax\njne    60 <func0+0x60>\nadd    %rdi,%r8\nmovb   $0x0,(%r8)\nmov    0x28(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    8f <func0+0x8f>\nadd    $0x38,%rsp\nretq\ncallq  94 <func0+0x94>"
    },
    {
        "task_id": 45,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  %xmm1,-0x8(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0\n00\nmulss  %xmm1,%xmm0\npop    %rbp\nretq"
    },
    {
        "task_id": 45,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmulss  %xmm1,%xmm0\nmulss  0x0(%rip),%xmm0\n00\nretq"
    },
    {
        "task_id": 45,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmulss  %xmm1,%xmm0\nmulss  0x0(%rip),%xmm0\n00\nretq"
    },
    {
        "task_id": 45,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmulss  %xmm1,%xmm0\nmulss  0x0(%rip),%xmm0\n00\nretq"
    },
    {
        "task_id": 46,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x1c0,%rsp\nmov    %edi,-0x1b4(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x1a0(%rbp)\n00 00 00\nmovl   $0x0,-0x19c(%rbp)\n00 00 00\nmovl   $0x2,-0x198(%rbp)\n00 00 00\nmovl   $0x0,-0x194(%rbp)\n00 00 00\nmovl   $0x4,-0x1a4(%rbp)\n00 00 00\njmp    bc <func0+0xbc>\nmov    -0x1a4(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%edx\nmov    -0x1a4(%rbp),%eax\nsub    $0x2,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0x1a4(%rbp),%eax\nsub    $0x3,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0x1a4(%rbp),%eax\nsub    $0x4,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0x1a4(%rbp),%eax\ncltq\nmov    %edx,-0x1a0(%rbp,%rax,4)\naddl   $0x1,-0x1a4(%rbp)\nmov    -0x1a4(%rbp),%eax\ncmp    -0x1b4(%rbp),%eax\njle    58 <func0+0x58>\nmov    -0x1b4(%rbp),%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nmov    -0x8(%rbp),%rcx\nxor    %fs:0x28,%rcx\n00 00\nje     ed <func0+0xed>\ncallq  ed <func0+0xed>\nleaveq\nretq"
    },
    {
        "task_id": 46,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x1a8,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x198(%rsp)\n00\nxor    %eax,%eax\nmovl   $0x0,(%rsp)\nmovl   $0x0,0x4(%rsp)\n00\nmovl   $0x2,0x8(%rsp)\n00\nmovl   $0x0,0xc(%rsp)\n00\ncmp    $0x3,%edi\njle    64 <func0+0x64>\nmov    %rsp,%rax\nlea    -0x4(%rdi),%edx\nlea    0x4(%rsp,%rdx,4),%rcx\nmov    0x8(%rax),%edx\nadd    0xc(%rax),%edx\nadd    0x4(%rax),%edx\nadd    (%rax),%edx\nmov    %edx,0x10(%rax)\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    4d <func0+0x4d>\nmovslq %edi,%rdi\nmov    (%rsp,%rdi,4),%eax\nmov    0x198(%rsp),%rsi\n00\nxor    %fs:0x28,%rsi\n00 00\njne    85 <func0+0x85>\nadd    $0x1a8,%rsp\nretq\ncallq  8a <func0+0x8a>"
    },
    {
        "task_id": 46,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x1a8,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x198(%rsp)\n00\nxor    %eax,%eax\nmovq   $0x0,(%rsp)\n00\nmovq   $0x2,0x8(%rsp)\n00 00\ncmp    $0x3,%edi\njle    6f <func0+0x6f>\nlea    -0x4(%rdi),%eax\nlea    0x4(%rsp),%rdx\nxor    %r8d,%r8d\nxor    %esi,%esi\nlea    0x8(%rsp,%rax,4),%r9\nmov    $0x2,%ecx\nxor    %eax,%eax\njmp    5c <func0+0x5c>\nnop\nmov    0x8(%rdx),%eax\nmov    0x4(%rdx),%ecx\nmov    (%rdx),%esi\nmov    -0x4(%rdx),%r8d\nadd    %ecx,%eax\nadd    $0x4,%rdx\nadd    %esi,%eax\nadd    %r8d,%eax\nmov    %eax,0x8(%rdx)\ncmp    %r9,%rdx\njne    50 <func0+0x50>\nmovslq %edi,%rdi\nmov    (%rsp,%rdi,4),%eax\nmov    0x198(%rsp),%rdi\n00\nxor    %fs:0x28,%rdi\n00 00\njne    90 <func0+0x90>\nadd    $0x1a8,%rsp\nretq\ncallq  95 <func0+0x95>"
    },
    {
        "task_id": 46,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x1a8,%rsp\nmovdqa 0x0(%rip),%xmm0\n00\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x198(%rsp)\n00\nxor    %eax,%eax\nmovaps %xmm0,(%rsp)\ncmp    $0x3,%edi\njle    ba <func0+0xba>\nlea    -0x1(%rdi),%r11d\ncmp    $0x6,%edi\njle    db <func0+0xdb>\nmov    %rsp,%r10\nmov    0x8(%rsp),%esi\nmov    0xc(%rsp),%edx\nmov    $0x4,%ecx\nmov    0x4(%rsp),%r8d\nmov    %r10,%rax\nlea    (%rsi,%rdx,1),%r9d\nadd    $0xc,%rax\nadd    %r9d,%r8d\nadd    -0xc(%rax),%r8d\nlea    (%r8,%rdx,1),%r9d\nmov    %r8d,0x4(%rax)\nadd    %r9d,%esi\nadd    -0x8(%rax),%esi\nlea    (%r8,%rsi,1),%r9d\nmov    %esi,0x8(%rax)\nadd    %r9d,%edx\nmov    %ecx,%r9d\nadd    -0x4(%rax),%edx\nadd    $0x3,%ecx\nadd    $0x4,%r9d\nmov    %edx,0xc(%rax)\ncmp    %r9d,%r11d\njg     58 <func0+0x58>\nmovslq %ecx,%rax\nlea    (%r10,%rax,4),%rdx\nnopl   0x0(%rax,%rax,1)\nmov    -0x4(%rdx),%eax\nadd    $0x1,%ecx\nadd    -0x8(%rdx),%eax\nadd    $0x4,%rdx\nadd    -0x10(%rdx),%eax\nadd    -0x14(%rdx),%eax\nmov    %eax,-0x4(%rdx)\ncmp    %ecx,%edi\njge    a0 <func0+0xa0>\nmov    0x198(%rsp),%rsi\n00\nxor    %fs:0x28,%rsi\n00 00\nmovslq %edi,%rdi\nmov    (%rsp,%rdi,4),%eax\njne    e5 <func0+0xe5>\nadd    $0x1a8,%rsp\nretq\nmov    $0x4,%ecx\nmov    %rsp,%r10\njmp    94 <func0+0x94>\ncallq  ea <func0+0xea>"
    },
    {
        "task_id": 47,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmpq   dc <func0+0xdc>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x8(%rbp)\njmpq   cc <func0+0xcc>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\ncomiss %xmm1,%xmm0\njbe    c8 <func0+0xc8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovss  (%rdx),%xmm0\nmovss  %xmm0,(%rax)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  -0x4(%rbp),%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     29 <func0+0x29>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1b <func0+0x1b>\nmov    -0x1c(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    11e <func0+0x11e>\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\njmp    170 <func0+0x170>\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\naddss  %xmm0,%xmm1\nmovss  0x0(%rip),%xmm0\n00\nmulss  %xmm1,%xmm0\npop    %rbp\nretq"
    },
    {
        "task_id": 47,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    4d <func0+0x4d>\nmov    %rdi,%rdx\nlea    -0x1(%rsi),%r8d\nadd    $0x1,%r8\nmov    $0x1,%ecx\njmp    43 <func0+0x43>\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    3b <func0+0x3b>\nmovss  (%rdx),%xmm0\nmovss  (%rdi,%rax,4),%xmm1\ncomiss %xmm1,%xmm0\njbe    1a <func0+0x1a>\nmovss  %xmm1,(%rdx)\nmovss  %xmm0,(%rdi,%rax,4)\njmp    1a <func0+0x1a>\nadd    $0x1,%rcx\nadd    $0x4,%rdx\ncmp    %r8,%rcx\nje     4d <func0+0x4d>\nmov    %rcx,%rax\njmp    22 <func0+0x22>\nmov    %esi,%edx\nshr    $0x1f,%edx\nlea    (%rsi,%rdx,1),%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\nje     7f <func0+0x7f>\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %eax,%esi\nsar    %esi\nmovslq %esi,%rax\nmovss  -0x4(%rdi,%rax,4),%xmm0\naddss  (%rdi,%rax,4),%xmm0\nmulss  0x0(%rip),%xmm0\n00\nretq\nmov    %edx,%eax\nadd    %esi,%eax\nsar    %eax\ncltq\nmovss  (%rdi,%rax,4),%xmm0\nretq"
    },
    {
        "task_id": 47,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    54 <func0+0x54>\nlea    -0x1(%rsi),%r8d\nmov    $0x1,%ecx\nmov    %rdi,%rdx\nadd    $0x1,%r8\ncmp    %rcx,%r8\nje     54 <func0+0x54>\nnopl   (%rax)\nmov    %rcx,%rax\nnopl   0x0(%rax,%rax,1)\nmovss  (%rdx),%xmm0\nmovss  (%rdi,%rax,4),%xmm1\ncomiss %xmm1,%xmm0\njbe    3f <func0+0x3f>\nmovss  %xmm1,(%rdx)\nmovss  %xmm0,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     28 <func0+0x28>\nadd    $0x1,%rcx\nadd    $0x4,%rdx\ncmp    %rcx,%r8\njne    20 <func0+0x20>\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %esi,%eax\nsar    %eax\ncltq\nmovss  (%rdi,%rax,4),%xmm0\nlea    0x0(,%rax,4),%rdx\n00\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %eax,%esi\nand    $0x1,%esi\nsub    %eax,%esi\ncmp    $0x1,%esi\nje     8b <func0+0x8b>\naddss  -0x4(%rdi,%rdx,1),%xmm0\nmulss  0x0(%rip),%xmm0\n00\nretq"
    },
    {
        "task_id": 47,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    54 <func0+0x54>\ncmp    $0x1,%esi\nje     54 <func0+0x54>\nlea    -0x2(%rsi),%r8d\nmov    %rdi,%rdx\nmov    $0x1,%ecx\nadd    $0x2,%r8\nnopl   (%rax)\nmov    %rcx,%rax\nnopl   0x0(%rax,%rax,1)\nmovss  (%rdx),%xmm0\nmovss  (%rdi,%rax,4),%xmm1\ncomiss %xmm1,%xmm0\njbe    3f <func0+0x3f>\nmovss  %xmm1,(%rdx)\nmovss  %xmm0,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     28 <func0+0x28>\nadd    $0x1,%rcx\nadd    $0x4,%rdx\ncmp    %rcx,%r8\njne    20 <func0+0x20>\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %esi,%eax\nsar    %eax\ncltq\nmovss  (%rdi,%rax,4),%xmm0\nlea    0x0(,%rax,4),%rdx\n00\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %eax,%esi\nand    $0x1,%esi\nsub    %eax,%esi\ncmp    $0x1,%esi\nje     8b <func0+0x8b>\naddss  -0x4(%rdi,%rdx,1),%xmm0\nmulss  0x0(%rip),%xmm0\n00\nretq"
    },
    {
        "task_id": 48,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  1c <func0+0x1c>\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    5d <func0+0x5d>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x8(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     59 <func0+0x59>\nmov    $0x0,%eax\njmp    73 <func0+0x73>\naddl   $0x1,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x8(%rbp)\njl     28 <func0+0x28>\nmov    $0x1,%eax\nleaveq\nretq"
    },
    {
        "task_id": 48,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%rsi\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nmov    %rcx,%rax\nnot    %rax\nsub    $0x1,%rax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\ncmp    $0x1,%eax\njle    54 <func0+0x54>\ncltq\nlea    -0x1(%rsi,%rax,1),%rdx\nmov    $0x0,%eax\nmovzbl (%rdx),%edi\ncmp    %dil,(%rsi,%rax,1)\njne    5a <func0+0x5a>\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %eax,%ecx\njg     39 <func0+0x39>\nmov    $0x1,%eax\nretq\nmov    $0x1,%eax\nretq\nmov    $0x0,%eax\nretq"
    },
    {
        "task_id": 48,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncallq  d <func0+0xd>\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\ncmp    $0x1,%eax\njle    50 <func0+0x50>\nsub    $0x1,%eax\nxor    %edx,%edx\ncltq\nadd    %rbx,%rax\njmp    3c <func0+0x3c>\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    $0x1,%rdx\nsub    $0x1,%rax\ncmp    %edx,%ecx\njle    50 <func0+0x50>\nmovzbl (%rax),%esi\ncmp    %sil,(%rbx,%rdx,1)\nje     30 <func0+0x30>\nxor    %eax,%eax\npop    %rbx\nretq\nnopl   0x0(%rax)\nmov    $0x1,%eax\npop    %rbx\nretq"
    },
    {
        "task_id": 48,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncallq  d <func0+0xd>\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\ncmp    $0x1,%eax\njle    50 <func0+0x50>\nsub    $0x1,%eax\nxor    %edx,%edx\ncltq\nadd    %rbx,%rax\njmp    3c <func0+0x3c>\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    $0x1,%rdx\nsub    $0x1,%rax\ncmp    %edx,%ecx\njle    50 <func0+0x50>\nmovzbl (%rax),%esi\ncmp    %sil,(%rbx,%rdx,1)\nje     30 <func0+0x30>\nxor    %eax,%eax\npop    %rbx\nretq\nnopl   0x0(%rax)\nmov    $0x1,%eax\npop    %rbx\nretq"
    },
    {
        "task_id": 49,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    2e <func0+0x2e>\nmov    -0x8(%rbp),%eax\nadd    %eax,%eax\ncltd\nidivl  -0x18(%rbp)\nmov    %edx,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     1e <func0+0x1e>\nmov    -0x8(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 49,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    22 <func0+0x22>\nmov    $0x0,%ecx\nmov    $0x1,%edx\nlea    (%rdx,%rdx,1),%eax\ncltd\nidiv   %esi\nadd    $0x1,%ecx\ncmp    %ecx,%edi\njne    12 <func0+0x12>\nmov    %edx,%eax\nretq\nmov    $0x1,%edx\njmp    1f <func0+0x1f>"
    },
    {
        "task_id": 49,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    20 <func0+0x20>\nxor    %ecx,%ecx\nmov    $0x1,%edx\nnop\nlea    (%rdx,%rdx,1),%eax\nadd    $0x1,%ecx\ncltd\nidiv   %esi\ncmp    %ecx,%edi\njne    10 <func0+0x10>\nmov    %edx,%eax\nretq\nmov    $0x1,%edx\nmov    %edx,%eax\nretq"
    },
    {
        "task_id": 49,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    20 <func0+0x20>\nxor    %ecx,%ecx\nmov    $0x1,%edx\nnop\nlea    (%rdx,%rdx,1),%eax\nadd    $0x1,%ecx\ncltd\nidiv   %esi\ncmp    %ecx,%edi\njne    10 <func0+0x10>\nmov    %edx,%eax\nretq\nmov    $0x1,%edx\nmov    %edx,%eax\nretq"
    },
    {
        "task_id": 50,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\ncmpl   $0x0,-0x2c(%rbp)\nje     20 <func0+0x20>\nmov    $0x5,%eax\njmp    25 <func0+0x25>\nmov    $0x15,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  34 <func0+0x34>\nmov    %rax,-0x8(%rbp)\nmovq   $0x0,-0x10(%rbp)\n00\njmp    99 <func0+0x99>\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nlea    -0x61(%rax),%edx\nmov    -0x18(%rbp),%eax\nadd    %eax,%edx\nmovslq %edx,%rax\nimul   $0x4ec4ec4f,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%ecx\nsar    $0x3,%ecx\nmov    %edx,%eax\nsar    $0x1f,%eax\nsub    %eax,%ecx\nmov    %ecx,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nadd    $0x61,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x14(%rbp),%edx\nmov    %dl,(%rax)\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njb     42 <func0+0x42>\nnop\nnop\nleaveq\nretq"
    },
    {
        "task_id": 50,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%rdx\ncmp    $0x1,%esi\nsbb    %r8d,%r8d\nand    $0x10,%r8d\nadd    $0x5,%r8d\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nmov    %rcx,%rdi\nsub    $0x1,%rdi\nje     65 <func0+0x65>\nmov    %rdx,%rcx\nadd    %rdx,%rdi\nmovsbl (%rcx),%eax\nlea    -0x61(%r8,%rax,1),%edx\nmovslq %edx,%rax\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x23,%rax\nmov    %edx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%edx\nadd    $0x61,%edx\nmov    %dl,(%rcx)\nadd    $0x1,%rcx\ncmp    %rdi,%rcx\njne    35 <func0+0x35>\nretq"
    },
    {
        "task_id": 50,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x8,%rsp\ncmp    $0x1,%esi\nsbb    %ebp,%ebp\nand    $0x10,%ebp\nadd    $0x5,%ebp\ncallq  1d <func0+0x1d>\ntest   %rax,%rax\nje     60 <func0+0x60>\nmov    %rbx,%rdi\nlea    (%rbx,%rax,1),%rsi\nnopl   0x0(%rax)\nmovsbl (%rdi),%eax\nadd    $0x1,%rdi\nlea    -0x61(%rbp,%rax,1),%edx\nmovslq %edx,%rax\nmov    %edx,%ecx\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%ecx\nsar    $0x23,%rax\nsub    %ecx,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%edx\nadd    $0x61,%edx\nmov    %dl,-0x1(%rdi)\ncmp    %rdi,%rsi\njne    30 <func0+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 50,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x8,%rsp\ncmp    $0x1,%esi\nsbb    %ebp,%ebp\nand    $0x10,%ebp\nadd    $0x5,%ebp\ncallq  1d <func0+0x1d>\ntest   %rax,%rax\nje     4bc <func0+0x4bc>\nlea    -0x1(%rax),%rdx\ncmp    $0xe,%rdx\njbe    4c3 <func0+0x4c3>\nmovd   %ebp,%xmm2\nmov    %rax,%rcx\nmovdqa 0x0(%rip),%xmm5\n00\nmovdqa 0x0(%rip),%xmm4\n00\npunpcklwd %xmm2,%xmm2\nand    $0xfffffffffffffff0,%rcx\npxor   %xmm6,%xmm6\nmov    %rbx,%rdx\nmovdqa 0x0(%rip),%xmm3\n00\nmovdqa 0x0(%rip),%xmm7\n00\npshufd $0x0,%xmm2,%xmm2\nadd    %rbx,%rcx\nnopw   0x0(%rax,%rax,1)\nmovdqu (%rdx),%xmm1\nmovdqa %xmm6,%xmm0\nadd    $0x10,%rdx\npcmpgtb %xmm1,%xmm0\nmovdqa %xmm1,%xmm8\npunpcklbw %xmm0,%xmm8\npunpckhbw %xmm0,%xmm1\npaddw  %xmm5,%xmm8\nmovdqa %xmm1,%xmm0\npaddw  %xmm2,%xmm8\npaddw  %xmm5,%xmm0\nmovdqa %xmm8,%xmm1\nmovdqa %xmm8,%xmm9\npaddw  %xmm2,%xmm0\npmulhw %xmm4,%xmm1\npsraw  $0xf,%xmm9\npsraw  $0x3,%xmm1\npsubw  %xmm9,%xmm1\nmovdqa %xmm1,%xmm9\npsllw  $0x1,%xmm1\npaddw  %xmm9,%xmm1\npsllw  $0x2,%xmm1\npaddw  %xmm9,%xmm1\nmovdqa %xmm0,%xmm9\npsllw  $0x1,%xmm1\npsraw  $0xf,%xmm9\npsubw  %xmm1,%xmm8\nmovdqa %xmm0,%xmm1\npmulhw %xmm4,%xmm1\npsraw  $0x3,%xmm1\npsubw  %xmm9,%xmm1\nmovdqa %xmm1,%xmm9\npsllw  $0x1,%xmm1\npaddw  %xmm9,%xmm1\npsllw  $0x2,%xmm1\npaddw  %xmm9,%xmm1\npsllw  $0x1,%xmm1\npsubw  %xmm1,%xmm0\nmovdqa %xmm0,%xmm1\nmovdqa %xmm8,%xmm0\npand   %xmm3,%xmm0\npand   %xmm3,%xmm1\npackuswb %xmm1,%xmm0\npaddb  %xmm7,%xmm0\nmovups %xmm0,-0x10(%rdx)\ncmp    %rcx,%rdx\njne    78 <func0+0x78>\nmov    %rax,%rcx\nand    $0xfffffffffffffff0,%rcx\ntest   $0xf,%al\nje     4bc <func0+0x4bc>\nlea    (%rbx,%rcx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0x1(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0x2(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0x3(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0x4(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0x5(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0x6(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0x7(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0x8(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0x9(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0xa(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0xb(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0xc(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nlea    0xd(%rcx),%rdx\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rdx,%rax\njbe    4bc <func0+0x4bc>\nlea    (%rbx,%rdx,1),%rdi\nadd    $0xe,%rcx\nmovsbl (%rdi),%edx\nlea    -0x61(%rbp,%rdx,1),%esi\nmovslq %esi,%rdx\nmov    %esi,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%esi\nadd    $0x61,%esi\nmov    %sil,(%rdi)\ncmp    %rcx,%rax\njbe    4bc <func0+0x4bc>\nadd    %rcx,%rbx\nmovsbl (%rbx),%eax\nlea    -0x61(%rbp,%rax,1),%edx\nmovslq %edx,%rax\nmov    %edx,%ecx\nimul   $0x4ec4ec4f,%rax,%rax\nsar    $0x1f,%ecx\nsar    $0x23,%rax\nsub    %ecx,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%edx\nadd    $0x61,%edx\nmov    %dl,(%rbx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq\nxor    %ecx,%ecx\njmpq   161 <func0+0x161>"
    },
    {
        "task_id": 51,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\njmp    5c <func0+0x5c>\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncallq  3d <func0+0x3d>\ntest   %rax,%rax\njne    57 <func0+0x57>\nmov    -0x10(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x10(%rbp)\nmov    -0x18(%rbp),%rdx\nmovzbl (%rdx),%edx\nmov    %dl,(%rax)\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    25 <func0+0x25>\nmov    -0x10(%rbp),%rax\nmovb   $0x0,(%rax)\nnop\nleaveq\nretq"
    },
    {
        "task_id": 51,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nmovzbl (%rdi),%ebp\ntest   %bpl,%bpl\nje     4d <func0+0x4d>\nmov    %rdi,%r12\nlea    0x0(%rip),%r13\njmp    3a <func0+0x3a>\nmov    %bpl,(%r12)\nlea    0x1(%r12),%r12\nadd    $0x1,%rbx\nmovzbl (%rbx),%ebp\ntest   %bpl,%bpl\nje     50 <func0+0x50>\nmovsbl %bpl,%esi\nmov    %r13,%rdi\ncallq  46 <func0+0x46>\ntest   %rax,%rax\njne    2e <func0+0x2e>\njmp    25 <func0+0x25>\nmov    %rdi,%r12\nmovb   $0x0,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 51,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%ebx\ntest   %bl,%bl\nje     58 <func0+0x58>\nmov    %rdi,%rbp\nlea    0x0(%rip),%r13\njmp    34 <func0+0x34>\nnopl   0x0(%rax)\nmovzbl 0x1(%rbp),%ebx\nadd    $0x1,%rbp\ntest   %bl,%bl\nje     58 <func0+0x58>\nmovsbl %bl,%esi\nmov    %r13,%rdi\ncallq  3f <func0+0x3f>\ntest   %rax,%rax\njne    28 <func0+0x28>\nadd    $0x1,%rbp\nmov    %bl,(%r12)\nadd    $0x1,%r12\nmovzbl 0x0(%rbp),%ebx\ntest   %bl,%bl\njne    34 <func0+0x34>\nmovb   $0x0,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 51,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%ebp\ntest   %bpl,%bpl\nje     46 <func0+0x46>\nlea    0x0(%rip),%r13\nnopl   0x0(%rax,%rax,1)\nmovsbl %bpl,%esi\nmov    %r13,%rdi\ncallq  34 <func0+0x34>\ntest   %rax,%rax\nje     60 <func0+0x60>\nmovzbl 0x1(%rbx),%ebp\nadd    $0x1,%rbx\ntest   %bpl,%bpl\njne    28 <func0+0x28>\nmovb   $0x0,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nadd    $0x1,%rbx\nmov    %bpl,(%r12)\nlea    0x1(%r12),%rax\nmovzbl (%rbx),%ebp\nmov    %rax,%r12\ntest   %bpl,%bpl\njne    28 <func0+0x28>\nmovb   $0x0,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 52,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    41 <func0+0x41>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x20(%rbp)\njg     3d <func0+0x3d>\nmov    $0x0,%eax\njmp    4e <func0+0x4e>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1b <func0+0x1b>\nmov    $0x1,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 52,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    26 <func0+0x26>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%ecx\nlea    0x4(%rdi,%rcx,4),%rcx\ncmp    %edx,(%rax)\njge    2c <func0+0x2c>\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    13 <func0+0x13>\nmov    $0x1,%eax\nretq\nmov    $0x1,%eax\nretq\nmov    $0x0,%eax\nretq"
    },
    {
        "task_id": 52,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    30 <func0+0x30>\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rax\njmp    21 <func0+0x21>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rdi\ncmp    %rax,%rdi\nje     30 <func0+0x30>\ncmp    %edx,(%rdi)\njl     18 <func0+0x18>\nxor    %eax,%eax\nretq\nnopl   0x0(%rax,%rax,1)\n00\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 52,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    30 <func0+0x30>\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rax\njmp    21 <func0+0x21>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rdi\ncmp    %rax,%rdi\nje     30 <func0+0x30>\ncmp    %edx,(%rdi)\njl     18 <func0+0x18>\nxor    %eax,%eax\nretq\nnopl   0x0(%rax,%rax,1)\n00\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 53,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%edx\nmov    -0x8(%rbp),%eax\nadd    %edx,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 53,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    (%rdi,%rsi,1),%eax\nretq"
    },
    {
        "task_id": 53,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    (%rdi,%rsi,1),%eax\nretq"
    },
    {
        "task_id": 53,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    (%rdi,%rsi,1),%eax\nretq"
    },
    {
        "task_id": 54,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  20 <func0+0x20>\nmov    %eax,-0x8(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncallq  2f <func0+0x2f>\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    94 <func0+0x94>\nmovb   $0x0,-0x1a(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    76 <func0+0x76>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x30(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    72 <func0+0x72>\nmovb   $0x1,-0x1a(%rbp)\njmp    7e <func0+0x7e>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     48 <func0+0x48>\nmovzbl -0x1a(%rbp),%eax\nxor    $0x1,%eax\ntest   %al,%al\nje     90 <func0+0x90>\nmov    $0x0,%eax\njmp    10b <func0+0x10b>\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njl     3b <func0+0x3b>\nmovl   $0x0,-0x10(%rbp)\njmp    fe <func0+0xfe>\nmovb   $0x0,-0x19(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    e0 <func0+0xe0>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    dc <func0+0xdc>\nmovb   $0x1,-0x19(%rbp)\njmp    e8 <func0+0xe8>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njl     b2 <func0+0xb2>\nmovzbl -0x19(%rbp),%eax\nxor    $0x1,%eax\ntest   %al,%al\nje     fa <func0+0xfa>\nmov    $0x0,%eax\njmp    10b <func0+0x10b>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     a5 <func0+0xa5>\nmov    $0x1,%eax\nleaveq\nretq"
    },
    {
        "task_id": 54,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%r8\nmov    $0xffffffffffffffff,%rdx\nmov    $0x0,%eax\nmov    %rdx,%rcx\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%r11\nmov    %r11d,%r10d\nmov    %rdx,%rcx\nmov    %rsi,%rdi\nrepnz scas %es:(%rdi),%al\nmov    %rcx,%rax\nnot    %rax\nlea    -0x1(%rax),%r9\ntest   %r11d,%r11d\njle    5c <func0+0x5c>\nmov    %r9d,%ebx\nmov    %r8,%rdi\nlea    -0x1(%r11),%eax\nlea    0x1(%r8,%rax,1),%rbp\nlea    -0x1(%r9),%eax\nlea    0x1(%rsi,%rax,1),%rcx\njmp    bc <func0+0xbc>\nmov    $0x0,%eax\njmp    d8 <func0+0xd8>\nmov    $0x1,%eax\ntest   %r9d,%r9d\njle    d8 <func0+0xd8>\nmov    %rsi,%rdi\nlea    -0x1(%r9),%eax\nlea    0x1(%rsi,%rax,1),%rsi\nlea    -0x1(%r11),%eax\nlea    0x1(%r8,%rax,1),%rcx\njmp    8d <func0+0x8d>\nmov    $0x0,%eax\njmp    d8 <func0+0xd8>\nadd    $0x1,%rdi\ncmp    %rsi,%rdi\nje     ac <func0+0xac>\ntest   %r10d,%r10d\njle    7d <func0+0x7d>\nmovzbl (%rdi),%edx\nmov    %r8,%rax\ncmp    (%rax),%dl\nje     84 <func0+0x84>\nadd    $0x1,%rax\ncmp    %rcx,%rax\njne    98 <func0+0x98>\nmov    $0x0,%eax\njmp    d8 <func0+0xd8>\nmov    $0x1,%eax\njmp    d8 <func0+0xd8>\nadd    $0x1,%rdi\ncmp    %rbp,%rdi\nje     66 <func0+0x66>\ntest   %ebx,%ebx\njle    55 <func0+0x55>\nmovzbl (%rdi),%edx\nmov    %rsi,%rax\ncmp    (%rax),%dl\nje     b3 <func0+0xb3>\nadd    $0x1,%rax\ncmp    %rcx,%rax\njne    c6 <func0+0xc6>\nmov    $0x0,%eax\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 54,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\ncallq  13 <func0+0x13>\nmov    %rbx,%rdi\nmov    %rax,%r12\ncallq  1e <func0+0x1e>\ntest   %r12d,%r12d\njle    b7 <func0+0xb7>\nlea    -0x1(%r12),%r9d\nmov    %eax,%esi\nlea    0x1(%rbp),%rdi\nsub    $0x1,%eax\nmov    %r9,%r12\nmov    %rbp,%r8\nlea    0x1(%rbx,%rax,1),%rcx\nadd    %rdi,%r9\nnopl   0x0(%rax,%rax,1)\ntest   %esi,%esi\njle    b0 <func0+0xb0>\nmovzbl (%r8),%edx\nmov    %rbx,%rax\njmp    61 <func0+0x61>\nnopl   (%rax)\nadd    $0x1,%rax\ncmp    %rcx,%rax\nje     b0 <func0+0xb0>\ncmp    (%rax),%dl\njne    58 <func0+0x58>\nadd    $0x1,%r8\ncmp    %r9,%r8\njne    48 <func0+0x48>\nxor    %r8d,%r8d\nlea    (%rdi,%r12,1),%rcx\nnopl   (%rax)\nmovzbl (%rbx,%r8,1),%edx\nmov    %rbp,%rax\njmp    91 <func0+0x91>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%rax\ncmp    %rcx,%rax\nje     b0 <func0+0xb0>\ncmp    (%rax),%dl\njne    88 <func0+0x88>\nadd    $0x1,%r8\ncmp    %r8d,%esi\njg     78 <func0+0x78>\npop    %rbx\nmov    $0x1,%eax\npop    %rbp\npop    %r12\nretq\nnopl   0x0(%rax,%rax,1)\n00\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\nretq\ntest   %eax,%eax\nsetle  %al\njmp    b2 <func0+0xb2>"
    },
    {
        "task_id": 54,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\ncallq  13 <func0+0x13>\nmov    %r12,%rdi\nmov    %rax,%rbx\ncallq  1e <func0+0x1e>\ntest   %ebx,%ebx\njle    b7 <func0+0xb7>\nlea    -0x1(%rbx),%esi\nmov    %eax,%r8d\nlea    0x1(%rbp),%r9\nsub    $0x1,%eax\nmov    %rsi,%rbx\nmov    %rbp,%rdi\nlea    0x1(%r12,%rax,1),%rcx\nadd    %r9,%rsi\nnopl   0x0(%rax)\ntest   %r8d,%r8d\njle    b0 <func0+0xb0>\nmovzbl (%rdi),%edx\nmov    %r12,%rax\njmp    61 <func0+0x61>\nnopl   (%rax)\nadd    $0x1,%rax\ncmp    %rcx,%rax\nje     b0 <func0+0xb0>\ncmp    (%rax),%dl\njne    58 <func0+0x58>\nadd    $0x1,%rdi\ncmp    %rsi,%rdi\njne    48 <func0+0x48>\nxor    %esi,%esi\nlea    (%rbx,%r9,1),%rdx\nnopl   0x0(%rax)\nmovzbl (%r12,%rsi,1),%ecx\nmov    %rbp,%rax\njmp    91 <func0+0x91>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%rax\ncmp    %rax,%rdx\nje     b0 <func0+0xb0>\ncmp    (%rax),%cl\njne    88 <func0+0x88>\nadd    $0x1,%rsi\ncmp    %esi,%r8d\njg     78 <func0+0x78>\npop    %rbx\nmov    $0x1,%eax\npop    %rbp\npop    %r12\nretq\nnopl   0x0(%rax,%rax,1)\n00\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\nretq\ntest   %eax,%eax\nsetle  %al\njmp    b2 <func0+0xb2>"
    },
    {
        "task_id": 55,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xfd0,%rsp\nmov    %edi,-0xfc4(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0xfb0(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x1f4,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x0,-0xfb0(%rbp)\n00 00 00\nmovl   $0x1,-0xfac(%rbp)\n00 00 00\nmovl   $0x2,-0xfb4(%rbp)\n00 00 00\njmp    97 <func0+0x97>\nmov    -0xfb4(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    -0xfb0(%rbp,%rax,4),%edx\nmov    -0xfb4(%rbp),%eax\nsub    $0x2,%eax\ncltq\nmov    -0xfb0(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0xfb4(%rbp),%eax\ncltq\nmov    %edx,-0xfb0(%rbp,%rax,4)\naddl   $0x1,-0xfb4(%rbp)\nmov    -0xfb4(%rbp),%eax\ncmp    -0xfc4(%rbp),%eax\njle    5b <func0+0x5b>\nmov    -0xfc4(%rbp),%eax\ncltq\nmov    -0xfb0(%rbp,%rax,4),%eax\nmov    -0x8(%rbp),%rsi\nxor    %fs:0x28,%rsi\n00 00\nje     c8 <func0+0xc8>\ncallq  c8 <func0+0xc8>\nleaveq\nretq"
    },
    {
        "task_id": 55,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0xfb8,%rsp\nmov    %edi,%esi\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xfa8(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nmov    $0x1f4,%ecx\nrep stos %rax,%es:(%rdi)\nmovl   $0x1,0x4(%rsp)\n00\ncmp    $0x1,%esi\njle    54 <func0+0x54>\nmov    %rsp,%rax\nlea    -0x2(%rsi),%edx\nlea    0x4(%rsp,%rdx,4),%rcx\nmov    (%rax),%edx\nadd    0x4(%rax),%edx\nmov    %edx,0x8(%rax)\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    43 <func0+0x43>\nmovslq %esi,%rsi\nmov    (%rsp,%rsi,4),%eax\nmov    0xfa8(%rsp),%rdi\n00\nxor    %fs:0x28,%rdi\n00 00\njne    75 <func0+0x75>\nadd    $0xfb8,%rsp\nretq\ncallq  7a <func0+0x7a>"
    },
    {
        "task_id": 55,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0xfb8,%rsp\nmovslq %edi,%r8\nmov    $0x1f4,%ecx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xfa8(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nrep stos %rax,%es:(%rdi)\nmovabs $0x100000000,%rax\n00 00 00\nmov    %rax,(%rsp)\ncmp    $0x1,%r8d\njle    68 <func0+0x68>\nlea    -0x2(%r8),%edx\nlea    0x8(%rsp),%rax\nlea    (%rax,%rdx,4),%rsi\nmov    $0x1,%edx\njmp    5f <func0+0x5f>\nnopl   0x0(%rax)\nmov    -0x4(%rax),%ecx\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\ncmp    %rsi,%rax\njne    58 <func0+0x58>\nmov    0xfa8(%rsp),%rdi\n00\nxor    %fs:0x28,%rdi\n00 00\nmov    (%rsp,%r8,4),%eax\njne    87 <func0+0x87>\nadd    $0xfb8,%rsp\nretq\ncallq  8c <func0+0x8c>"
    },
    {
        "task_id": 55,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0xfb8,%rsp\nmovslq %edi,%rsi\nmov    $0x1f4,%ecx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xfa8(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%r9\nmov    %r9,%rdi\nrep stos %rax,%es:(%rdi)\nmovabs $0x100000000,%rax\n00 00 00\nmov    %rax,(%rsp)\ncmp    $0x1,%esi\njle    94 <func0+0x94>\ncmp    $0x3,%esi\njle    b2 <func0+0xb2>\nlea    -0x4(%rsi),%eax\nlea    0x8(%rsp),%r8\nmov    $0x1,%edi\nxor    %edx,%edx\nand    $0xfffffffe,%eax\nmov    $0x2,%ecx\nadd    $0x4,%eax\nadd    %edi,%edx\nadd    $0x2,%ecx\nadd    $0x8,%r8\nadd    %edx,%edi\nmov    %edx,-0x8(%r8)\nmov    %edi,-0x4(%r8)\ncmp    %eax,%ecx\njne    61 <func0+0x61>\nmovslq %ecx,%rax\nlea    (%r9,%rax,4),%rax\nnop\nmov    -0x8(%rax),%edx\nadd    $0x1,%ecx\nadd    -0x4(%rax),%edx\nadd    $0x4,%rax\nmov    %edx,-0x4(%rax)\ncmp    %ecx,%esi\njge    80 <func0+0x80>\nmov    0xfa8(%rsp),%rdi\n00\nxor    %fs:0x28,%rdi\n00 00\nmov    (%rsp,%rsi,4),%eax\njne    b9 <func0+0xb9>\nadd    $0xfb8,%rsp\nretq\nmov    $0x2,%ecx\njmp    78 <func0+0x78>\ncallq  be <func0+0xbe>"
    },
    {
        "task_id": 56,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    5d <func0+0x5d>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x3c,%al\njne    34 <func0+0x34>\naddl   $0x1,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x3e,%al\njne    4c <func0+0x4c>\nsubl   $0x1,-0x8(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njns    59 <func0+0x59>\nmov    $0x0,%eax\njmp    83 <func0+0x83>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1c <func0+0x1c>\ncmpl   $0x0,-0x8(%rbp)\nje     7e <func0+0x7e>\nmov    $0x0,%eax\njmp    83 <func0+0x83>\nmov    $0x1,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 56,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     39 <func0+0x39>\nadd    $0x1,%rdi\nmov    $0x0,%edx\njmp    30 <func0+0x30>\ncmp    $0x3e,%al\nsete   %al\nmovzbl %al,%eax\nsub    %eax,%edx\ntest   %edx,%edx\njs     44 <func0+0x44>\nadd    $0x1,%rdi\nmovzbl -0x1(%rdi),%eax\ntest   %al,%al\nje     3e <func0+0x3e>\ncmp    $0x3c,%al\njne    16 <func0+0x16>\nadd    $0x1,%edx\njmp    20 <func0+0x20>\nmov    $0x0,%edx\ntest   %edx,%edx\nsete   %al\nretq\nmov    $0x0,%eax\nretq"
    },
    {
        "task_id": 56,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     53 <func0+0x53>\nadd    $0x1,%rdi\nxor    %edx,%edx\njmp    2f <func0+0x2f>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x3e,%al\njne    24 <func0+0x24>\nsub    $0x1,%edx\ncmp    $0xffffffff,%edx\nje     50 <func0+0x50>\nmovzbl (%rdi),%eax\nadd    $0x1,%rdi\ntest   %al,%al\nje     41 <func0+0x41>\ncmp    $0x3c,%al\njne    18 <func0+0x18>\nmovzbl (%rdi),%eax\nadd    $0x1,%rdi\nadd    $0x1,%edx\ntest   %al,%al\njne    2f <func0+0x2f>\ntest   %edx,%edx\nsete   %al\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %eax,%eax\nretq\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 56,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     53 <func0+0x53>\nadd    $0x1,%rdi\nxor    %edx,%edx\njmp    2f <func0+0x2f>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x3e,%al\njne    24 <func0+0x24>\nsub    $0x1,%edx\ncmp    $0xffffffff,%edx\nje     50 <func0+0x50>\nmovzbl (%rdi),%eax\nadd    $0x1,%rdi\ntest   %al,%al\nje     41 <func0+0x41>\ncmp    $0x3c,%al\njne    18 <func0+0x18>\nmovzbl (%rdi),%eax\nadd    $0x1,%rdi\nadd    $0x1,%edx\ntest   %al,%al\njne    2f <func0+0x2f>\ntest   %edx,%edx\nsete   %al\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %eax,%eax\nretq\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 57,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmovl   $0x1,-0x4(%rbp)\njmp    a1 <func0+0xa1>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\ncomiss %xmm1,%xmm0\njbe    61 <func0+0x61>\nmovl   $0x1,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm1\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncomiss %xmm1,%xmm0\njbe    9d <func0+0x9d>\nmovl   $0x1,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     25 <func0+0x25>\nmov    -0xc(%rbp),%edx\nmov    -0x8(%rbp),%eax\nadd    %edx,%eax\ncmp    $0x2,%eax\njne    c1 <func0+0xc1>\nmov    $0x0,%eax\njmp    c6 <func0+0xc6>\nmov    $0x1,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 57,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    4a <func0+0x4a>\nmov    %rdi,%rax\nlea    -0x2(%rsi),%edx\nlea    0x4(%rdi,%rdx,4),%rdi\nmov    $0x0,%ecx\nmov    $0x0,%edx\nmov    $0x1,%esi\nmovss  0x4(%rax),%xmm0\nmovss  (%rax),%xmm1\nucomiss %xmm1,%xmm0\ncmova  %esi,%edx\nucomiss %xmm0,%xmm1\ncmova  %esi,%ecx\nadd    $0x4,%rax\ncmp    %rdi,%rax\njne    23 <func0+0x23>\nadd    %ecx,%edx\ncmp    $0x2,%edx\nsetne  %al\nretq\nmov    $0x0,%ecx\nmov    $0x0,%edx\njmp    41 <func0+0x41>"
    },
    {
        "task_id": 57,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    50 <func0+0x50>\nlea    -0x2(%rsi),%eax\nxor    %edx,%edx\nmov    $0x1,%ecx\nlea    0x4(%rdi,%rax,4),%rsi\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmovss  0x4(%rdi),%xmm0\nmovss  (%rdi),%xmm1\nucomiss %xmm1,%xmm0\ncmova  %ecx,%eax\nucomiss %xmm0,%xmm1\ncmova  %ecx,%edx\nadd    $0x4,%rdi\ncmp    %rsi,%rdi\njne    20 <func0+0x20>\nadd    %edx,%eax\ncmp    $0x2,%eax\nsetne  %al\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 57,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    a0 <func0+0xa0>\ncmp    $0x3,%esi\njle    a6 <func0+0xa6>\nlea    -0x4(%rsi),%eax\nmovss  (%rdi),%xmm0\nmov    $0x3,%r8d\nxor    %ecx,%ecx\nshr    %eax\nxor    %edx,%edx\nmov    $0x1,%r9d\nlea    0x5(%rax,%rax,1),%r10\nmovss  -0x8(%rdi,%r8,4),%xmm1\nmovslq %r8d,%rax\nucomiss %xmm0,%xmm1\ncmova  %r9d,%edx\nucomiss %xmm1,%xmm0\nmovss  -0x4(%rdi,%r8,4),%xmm0\ncmova  %r9d,%ecx\nucomiss %xmm1,%xmm0\ncmova  %r9d,%edx\nucomiss %xmm0,%xmm1\ncmova  %r9d,%ecx\nadd    $0x2,%r8\ncmp    %r10,%r8\njne    34 <func0+0x34>\nmov    $0x1,%r8d\nmovss  (%rdi,%rax,4),%xmm0\nmovss  -0x4(%rdi,%rax,4),%xmm1\nucomiss %xmm1,%xmm0\ncmova  %r8d,%edx\nucomiss %xmm0,%xmm1\ncmova  %r8d,%ecx\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     70 <func0+0x70>\nadd    %ecx,%edx\ncmp    $0x2,%edx\nsetne  %al\nretq\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nretq\nmov    $0x1,%eax\nxor    %ecx,%ecx\nxor    %edx,%edx\njmp    6a <func0+0x6a>"
    },
    {
        "task_id": 58,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %ecx,-0x30(%rbp)\nmov    %r8,-0x40(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  2f <func0+0x2f>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmpq   11f <func0+0x11f>\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    93 <func0+0x93>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    8f <func0+0x8f>\nmovl   $0x1,-0x10(%rbp)\njmp    9b <func0+0x9b>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     56 <func0+0x56>\ncmpl   $0x0,-0x10(%rbp)\njne    11b <func0+0x11b>\nmovl   $0x0,-0x18(%rbp)\njmp    113 <func0+0x113>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x38(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    10f <func0+0x10f>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x20(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x20(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\njmp    11b <func0+0x11b>\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     aa <func0+0xaa>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     46 <func0+0x46>\nmovl   $0x0,-0x1c(%rbp)\njmpq   1f8 <func0+0x1f8>\nmovl   $0x0,-0x18(%rbp)\njmpq   1e2 <func0+0x1e2>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    1de <func0+0x1de>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x18(%rbp)\nmov    -0x20(%rbp),%eax\nsub    -0x1c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x18(%rbp)\njl     143 <func0+0x143>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x20(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x1c(%rbp)\njl     137 <func0+0x137>\nmov    -0x40(%rbp),%rax\nmov    -0x20(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 58,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r14\nmov    %esi,%r12d\nmov    %rdx,%r13\nmov    %ecx,%ebp\nmov    %r8,%rbx\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncallq  26 <func0+0x26>\ntest   %r12d,%r12d\njle    dd <func0+0xdd>\nmov    %r14,%rdi\nlea    -0x1(%r12),%edx\nlea    0x4(%r14,%rdx,4),%r10\nmov    %r13,%r11\nlea    -0x1(%rbp),%edx\nlea    0x4(%r13,%rdx,4),%r8\nmov    $0x0,%r9d\nlea    0x4(%rax),%r12\njmp    66 <func0+0x66>\nmovslq %r9d,%rdx\nmov    %ecx,(%rax,%rdx,4)\nlea    0x1(%r9),%r9d\nadd    $0x4,%rdi\ncmp    %r10,%rdi\nje     9d <func0+0x9d>\ntest   %r9d,%r9d\njle    85 <func0+0x85>\nmov    (%rdi),%ecx\nmov    %rax,%rdx\nlea    -0x1(%r9),%esi\nlea    (%r12,%rsi,4),%rsi\ncmp    %ecx,(%rdx)\nje     5d <func0+0x5d>\nadd    $0x4,%rdx\ncmp    %rsi,%rdx\njne    78 <func0+0x78>\ntest   %ebp,%ebp\njle    5d <func0+0x5d>\nmov    (%rdi),%ecx\nmov    %r11,%rdx\ncmp    (%rdx),%ecx\nje     53 <func0+0x53>\nadd    $0x4,%rdx\ncmp    %r8,%rdx\njne    8e <func0+0x8e>\njmp    5d <func0+0x5d>\nlea    -0x1(%r9),%r8d\ntest   %r8d,%r8d\njle    e3 <func0+0xe3>\nlea    0x4(%rax),%r10\njmp    cb <func0+0xcb>\nadd    $0x4,%rdx\ncmp    %rdx,%rdi\nje     c5 <func0+0xc5>\nmov    (%rdx),%ecx\nmov    0x4(%rdx),%esi\ncmp    %esi,%ecx\njle    ac <func0+0xac>\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\njmp    ac <func0+0xac>\nsub    $0x1,%r8d\nje     e3 <func0+0xe3>\ntest   %r8d,%r8d\njle    c5 <func0+0xc5>\nmov    %rax,%rdx\nlea    -0x1(%r8),%ecx\nlea    (%r10,%rcx,4),%rdi\njmp    b5 <func0+0xb5>\nmov    $0x0,%r9d\nmov    %r9d,(%rbx)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq"
    },
    {
        "task_id": 58,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\nmov    %rdi,%r14\nmovslq %esi,%rdi\npush   %r13\nmov    %rdi,%r13\nshl    $0x2,%rdi\npush   %r12\nmov    %ecx,%r12d\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %r8,%rbx\ncallq  27 <func0+0x27>\ntest   %r13d,%r13d\njle    111 <func0+0x111>\nlea    -0x1(%r13),%edx\nmov    %r14,%r10\nlea    0x4(%rax),%r13\nxor    %r8d,%r8d\nlea    0x4(%r14,%rdx,4),%rcx\nlea    -0x1(%r12),%edx\nlea    0x4(%rbp,%rdx,4),%r11\nnopl   (%rax)\ntest   %r8d,%r8d\nje     d8 <func0+0xd8>\nlea    -0x1(%r8),%edx\nmov    (%r10),%edi\nmov    %rax,%rsi\nlea    0x0(%r13,%rdx,4),%r9\njmp    79 <func0+0x79>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rsi\ncmp    %r9,%rsi\nje     d8 <func0+0xd8>\ncmp    %edi,(%rsi)\njne    70 <func0+0x70>\nadd    $0x4,%r10\ncmp    %rcx,%r10\njne    50 <func0+0x50>\nlea    -0x1(%r8),%ecx\ntest   %ecx,%ecx\njle    c7 <func0+0xc7>\nlea    0x4(%rax),%r10\nnopw   0x0(%rax,%rax,1)\nsub    $0x1,%ecx\nmov    %rax,%rdx\nmov    %rcx,%r9\nlea    (%r10,%rcx,4),%rdi\nnopl   (%rax)\nmov    (%rdx),%ecx\nmov    0x4(%rdx),%esi\ncmp    %esi,%ecx\njle    b6 <func0+0xb6>\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nadd    $0x4,%rdx\ncmp    %rdx,%rdi\njne    a8 <func0+0xa8>\nmov    %r9d,%ecx\ntest   %r9d,%r9d\njne    98 <func0+0x98>\nmov    %r8d,(%rbx)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nnopl   0x0(%rax,%rax,1)\ntest   %r12d,%r12d\njle    7d <func0+0x7d>\nmov    (%r10),%edi\nmov    %rbp,%rsi\njmp    f1 <func0+0xf1>\nnopl   (%rax)\nadd    $0x4,%rsi\ncmp    %rsi,%r11\nje     7d <func0+0x7d>\ncmp    (%rsi),%edi\njne    e8 <func0+0xe8>\nmovslq %r8d,%rdx\nadd    $0x4,%r10\nadd    $0x1,%r8d\nmov    %edi,(%rax,%rdx,4)\ncmp    %rcx,%r10\njne    50 <func0+0x50>\njmpq   86 <func0+0x86>\nxor    %r8d,%r8d\nmov    %r8d,(%rbx)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq"
    },
    {
        "task_id": 58,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\nmov    %rdi,%r14\nmovslq %esi,%rdi\npush   %r13\nmov    %rdi,%r13\nshl    $0x2,%rdi\npush   %r12\nmov    %ecx,%r12d\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %r8,%rbx\ncallq  27 <func0+0x27>\ntest   %r13d,%r13d\njle    111 <func0+0x111>\nlea    -0x1(%r13),%edx\nmov    %r14,%r10\nlea    0x4(%rax),%r13\nxor    %r8d,%r8d\nlea    0x4(%r14,%rdx,4),%rcx\nlea    -0x1(%r12),%edx\nlea    0x4(%rbp,%rdx,4),%r11\nnopl   (%rax)\ntest   %r8d,%r8d\nje     d8 <func0+0xd8>\nlea    -0x1(%r8),%edx\nmov    (%r10),%edi\nmov    %rax,%rsi\nlea    0x0(%r13,%rdx,4),%r9\njmp    79 <func0+0x79>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rsi\ncmp    %r9,%rsi\nje     d8 <func0+0xd8>\ncmp    %edi,(%rsi)\njne    70 <func0+0x70>\nadd    $0x4,%r10\ncmp    %rcx,%r10\njne    50 <func0+0x50>\nlea    -0x1(%r8),%ecx\ntest   %ecx,%ecx\njle    c7 <func0+0xc7>\nlea    0x4(%rax),%r10\nnopw   0x0(%rax,%rax,1)\nsub    $0x1,%ecx\nmov    %rax,%rdx\nmov    %rcx,%r9\nlea    (%r10,%rcx,4),%rdi\nnopl   (%rax)\nmov    (%rdx),%ecx\nmov    0x4(%rdx),%esi\ncmp    %esi,%ecx\njle    b6 <func0+0xb6>\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nadd    $0x4,%rdx\ncmp    %rdx,%rdi\njne    a8 <func0+0xa8>\nmov    %r9d,%ecx\ntest   %r9d,%r9d\njne    98 <func0+0x98>\nmov    %r8d,(%rbx)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nnopl   0x0(%rax,%rax,1)\ntest   %r12d,%r12d\njle    7d <func0+0x7d>\nmov    (%r10),%edi\nmov    %rbp,%rsi\njmp    f1 <func0+0xf1>\nnopl   (%rax)\nadd    $0x4,%rsi\ncmp    %rsi,%r11\nje     7d <func0+0x7d>\ncmp    (%rsi),%edi\njne    e8 <func0+0xe8>\nmovslq %r8d,%rdx\nadd    $0x4,%r10\nadd    $0x1,%r8d\nmov    %edi,(%rax,%rdx,4)\ncmp    %rcx,%r10\njne    50 <func0+0x50>\njmpq   86 <func0+0x86>\nxor    %r8d,%r8d\nmov    %r8d,(%rbx)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq"
    },
    {
        "task_id": 59,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x2,-0x4(%rbp)\njmp    37 <func0+0x37>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    33 <func0+0x33>\nmov    -0x14(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njg     14 <func0+0x14>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    1e <func0+0x1e>\nmov    -0x14(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 59,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x2,%ecx\ncmp    $0x3,%edi\njg     1d <func0+0x1d>\nmov    %edi,%eax\nretq\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njg     e <func0+0xe>\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    11 <func0+0x11>\ncmp    %ecx,%edi\njle    11 <func0+0x11>\nmov    %edi,%eax\ncltd\nidiv   %ecx\nmov    %eax,%esi\nmov    %eax,%edi\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    11 <func0+0x11>\ncmp    %ecx,%esi\njg     2a <func0+0x2a>\njmp    11 <func0+0x11>"
    },
    {
        "task_id": 59,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%r8d\nmov    $0x2,%ecx\ncmp    $0x3,%edi\njle    4a <func0+0x4a>\nnopl   0x0(%rax)\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     38 <func0+0x38>\njmp    3d <func0+0x3d>\nnopl   0x0(%rax)\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ncltd\nmov    %eax,%r8d\nidiv   %ecx\ntest   %edx,%edx\njne    3d <func0+0x3d>\ncmp    %ecx,%r8d\njg     28 <func0+0x28>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %r8d,%eax\njle    18 <func0+0x18>\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 59,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%r8d\nmov    $0x2,%ecx\ncmp    $0x3,%edi\njle    4a <func0+0x4a>\nnopl   0x0(%rax)\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     38 <func0+0x38>\njmp    3d <func0+0x3d>\nnopl   0x0(%rax)\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ncltd\nmov    %eax,%r8d\nidiv   %ecx\ntest   %edx,%edx\njne    3d <func0+0x3d>\ncmp    %ecx,%r8d\njg     28 <func0+0x28>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %r8d,%eax\njle    18 <func0+0x18>\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 60,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x1,%eax\nimul   -0x4(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\npop    %rbp\nretq"
    },
    {
        "task_id": 60,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    0x1(%rdi),%eax\nimul   %eax,%edi\nmov    %edi,%eax\nshr    $0x1f,%eax\nadd    %edi,%eax\nsar    %eax\nretq"
    },
    {
        "task_id": 60,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    0x1(%rdi),%eax\nimul   %eax,%edi\nmov    %edi,%eax\nshr    $0x1f,%eax\nadd    %edi,%eax\nsar    %eax\nretq"
    },
    {
        "task_id": 60,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    0x1(%rdi),%eax\nimul   %eax,%edi\nmov    %edi,%eax\nshr    $0x1f,%eax\nadd    %edi,%eax\nsar    %eax\nretq"
    },
    {
        "task_id": 61,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    62 <func0+0x62>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x28,%al\njne    39 <func0+0x39>\naddl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x29,%al\njne    51 <func0+0x51>\nsubl   $0x1,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njns    5e <func0+0x5e>\nmov    $0x0,%eax\njmp    80 <func0+0x80>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  74 <func0+0x74>\ncmp    %rax,%rbx\njb     21 <func0+0x21>\ncmpl   $0x0,-0x18(%rbp)\nsete   %al\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 61,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%rsi\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nmov    %rsi,%rdx\nlea    -0x1(%rsi,%rcx,1),%rsi\nmov    $0x0,%eax\njmp    3a <func0+0x3a>\ncmp    $0x29,%cl\nsete   %cl\nmovzbl %cl,%ecx\nsub    %ecx,%eax\nadd    $0x1,%rdx\ntest   %eax,%eax\njs     52 <func0+0x52>\ncmp    %rsi,%rdx\nje     4c <func0+0x4c>\nmovzbl (%rdx),%ecx\ncmp    $0x28,%cl\njne    27 <func0+0x27>\nadd    $0x1,%eax\njmp    32 <func0+0x32>\ntest   %eax,%eax\nsete   %al\nretq\nmov    $0x0,%eax\nretq"
    },
    {
        "task_id": 61,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncallq  d <func0+0xd>\nmov    %rbx,%rdi\nxor    %ecx,%ecx\nadd    %rbx,%rax\njmp    31 <func0+0x31>\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    $0x29,%dl\njne    2d <func0+0x2d>\nsub    $0x1,%ecx\ncmp    $0xffffffff,%ecx\nje     50 <func0+0x50>\nadd    $0x1,%rdi\ncmp    %rax,%rdi\nje     48 <func0+0x48>\nmovzbl (%rdi),%edx\ncmp    $0x28,%dl\njne    20 <func0+0x20>\nadd    $0x1,%ecx\njmp    2d <func0+0x2d>\nnopl   0x0(%rax,%rax,1)\ntest   %ecx,%ecx\npop    %rbx\nsete   %al\nretq\nnop\nxor    %eax,%eax\npop    %rbx\nretq"
    },
    {
        "task_id": 61,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncallq  d <func0+0xd>\nmov    %rbx,%rdi\nxor    %ecx,%ecx\nadd    %rbx,%rax\njmp    31 <func0+0x31>\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    $0x29,%dl\njne    2d <func0+0x2d>\nsub    $0x1,%ecx\ncmp    $0xffffffff,%ecx\nje     50 <func0+0x50>\nadd    $0x1,%rdi\ncmp    %rax,%rdi\nje     48 <func0+0x48>\nmovzbl (%rdi),%edx\ncmp    $0x28,%dl\njne    20 <func0+0x20>\nadd    $0x1,%ecx\njmp    2d <func0+0x2d>\nnopl   0x0(%rax,%rax,1)\ntest   %ecx,%ecx\npop    %rbx\nsete   %al\nretq\nnop\nxor    %eax,%eax\npop    %rbx\nretq"
    },
    {
        "task_id": 62,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x1,-0x4(%rbp)\njmp    59 <func0+0x59>\ncvtsi2ssl -0x4(%rbp),%xmm1\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmulss  %xmm1,%xmm0\nmovss  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1c <func0+0x1c>\nnop\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 62,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    31 <func0+0x31>\nlea    -0x2(%rsi),%ecx\nadd    $0x2,%rcx\nmov    $0x1,%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmulss  (%rdi,%rax,4),%xmm0\nmovss  %xmm0,-0x4(%rdx,%rax,4)\nadd    $0x1,%rax\ncmp    %rcx,%rax\njne    15 <func0+0x15>\nretq"
    },
    {
        "task_id": 62,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    34 <func0+0x34>\nlea    -0x2(%rsi),%ecx\nmov    $0x1,%eax\nadd    $0x2,%rcx\nnopl   (%rax)\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmulss  (%rdi,%rax,4),%xmm0\nmovss  %xmm0,-0x4(%rdx,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%rcx\njne    18 <func0+0x18>\nretq"
    },
    {
        "task_id": 62,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    11c <func0+0x11c>\nlea    0x4(%rdi),%r8\nlea    0x10(%rdx),%rcx\ncmp    %rcx,%r8\nlea    0x14(%rdi),%rcx\nlea    -0x2(%rsi),%eax\nsetae  %r8b\ncmp    %rcx,%rdx\nsetae  %cl\nor     %cl,%r8b\nje     f0 <func0+0xf0>\ncmp    $0x2,%eax\njbe    f0 <func0+0xf0>\nlea    -0x1(%rsi),%r8d\nmovdqa 0x0(%rip),%xmm1\n00\nmovdqa 0x0(%rip),%xmm2\n00\nxor    %eax,%eax\nmov    %r8d,%ecx\nshr    $0x2,%ecx\nshl    $0x4,%rcx\nnopl   0x0(%rax,%rax,1)\nmovups 0x4(%rdi,%rax,1),%xmm3\nmovdqa %xmm1,%xmm0\npaddd  %xmm2,%xmm1\ncvtdq2ps %xmm0,%xmm0\nmulps  %xmm3,%xmm0\nmovups %xmm0,(%rdx,%rax,1)\nadd    $0x10,%rax\ncmp    %rcx,%rax\njne    60 <func0+0x60>\nmov    %r8d,%eax\nand    $0xfffffffc,%eax\nlea    0x1(%rax),%ecx\ncmp    %eax,%r8d\nje     11c <func0+0x11c>\nmovslq %ecx,%r8\npxor   %xmm0,%xmm0\ncvtsi2ss %ecx,%xmm0\nmulss  (%rdi,%r8,4),%xmm0\nlea    0x2(%rax),%ecx\nmovss  %xmm0,-0x4(%rdx,%r8,4)\ncmp    %ecx,%esi\njle    11c <func0+0x11c>\nmovslq %ecx,%r8\npxor   %xmm0,%xmm0\nadd    $0x3,%eax\ncvtsi2ss %ecx,%xmm0\nmulss  (%rdi,%r8,4),%xmm0\nmovss  %xmm0,-0x4(%rdx,%r8,4)\ncmp    %eax,%esi\njle    11c <func0+0x11c>\nmovslq %eax,%rcx\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmulss  (%rdi,%rcx,4),%xmm0\nmovss  %xmm0,-0x4(%rdx,%rcx,4)\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\nlea    0x2(%rax),%rcx\nmov    $0x1,%eax\nnopl   0x0(%rax)\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmulss  (%rdi,%rax,4),%xmm0\nmovss  %xmm0,-0x4(%rdx,%rax,4)\nadd    $0x1,%rax\ncmp    %rcx,%rax\njne    100 <func0+0x100>\nretq"
    },
    {
        "task_id": 63,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x1c0,%rsp\nmov    %edi,-0x1b4(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x1a0(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x32,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x0,-0x19c(%rbp)\n00 00 00\nmovl   $0x1,-0x198(%rbp)\n00 00 00\nmovl   $0x3,-0x1a4(%rbp)\n00 00 00\njmp    ab <func0+0xab>\nmov    -0x1a4(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%edx\nmov    -0x1a4(%rbp),%eax\nsub    $0x2,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0x1a4(%rbp),%eax\nsub    $0x3,%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0x1a4(%rbp),%eax\ncltq\nmov    %edx,-0x1a0(%rbp,%rax,4)\naddl   $0x1,-0x1a4(%rbp)\nmov    -0x1a4(%rbp),%eax\ncmp    -0x1b4(%rbp),%eax\njle    5b <func0+0x5b>\nmov    -0x1b4(%rbp),%eax\ncltq\nmov    -0x1a0(%rbp,%rax,4),%eax\nmov    -0x8(%rbp),%rsi\nxor    %fs:0x28,%rsi\n00 00\nje     dc <func0+0xdc>\ncallq  dc <func0+0xdc>\nleaveq\nretq"
    },
    {
        "task_id": 63,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x1a8,%rsp\nmov    %edi,%esi\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x198(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nmov    $0x32,%ecx\nrep stos %rax,%es:(%rdi)\nmovl   $0x1,0x8(%rsp)\n00\ncmp    $0x2,%esi\njle    57 <func0+0x57>\nmov    %rsp,%rax\nlea    -0x3(%rsi),%edx\nlea    0x4(%rsp,%rdx,4),%rcx\nmov    0x4(%rax),%edx\nadd    0x8(%rax),%edx\nadd    (%rax),%edx\nmov    %edx,0xc(%rax)\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    43 <func0+0x43>\nmovslq %esi,%rsi\nmov    (%rsp,%rsi,4),%eax\nmov    0x198(%rsp),%rdi\n00\nxor    %fs:0x28,%rdi\n00 00\njne    78 <func0+0x78>\nadd    $0x1a8,%rsp\nretq\ncallq  7d <func0+0x7d>"
    },
    {
        "task_id": 63,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x1a8,%rsp\nmovslq %edi,%r8\nmov    $0x32,%ecx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x198(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%rdi\nrep stos %rax,%es:(%rdi)\nmovabs $0x100000000,%rax\n00 00 00\nmov    %rax,0x4(%rsp)\ncmp    $0x2,%r8d\njle    78 <func0+0x78>\nlea    -0x3(%r8),%edx\nlea    0x4(%rsp),%rax\nxor    %esi,%esi\nlea    0x8(%rsp,%rdx,4),%rdi\nmov    $0x1,%edx\njmp    68 <func0+0x68>\nnopl   0x0(%rax,%rax,1)\n00\nmov    0x4(%rax),%edx\nmov    (%rax),%ecx\nmov    -0x4(%rax),%esi\nadd    %ecx,%edx\nadd    $0x4,%rax\nadd    %esi,%edx\nmov    %edx,0x4(%rax)\ncmp    %rax,%rdi\njne    60 <func0+0x60>\nmov    0x198(%rsp),%rdi\n00\nxor    %fs:0x28,%rdi\n00 00\nmov    (%rsp,%r8,4),%eax\njne    97 <func0+0x97>\nadd    $0x1a8,%rsp\nretq\ncallq  9c <func0+0x9c>"
    },
    {
        "task_id": 63,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x1a8,%rsp\nmovslq %edi,%rsi\nmov    $0x32,%ecx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x198(%rsp)\n00\nxor    %eax,%eax\nmov    %rsp,%r9\nmov    %r9,%rdi\nrep stos %rax,%es:(%rdi)\nmovabs $0x100000000,%rax\n00 00 00\nmov    %rax,0x4(%rsp)\ncmp    $0x2,%esi\njle    b7 <func0+0xb7>\nlea    -0x1(%rsi),%r11d\ncmp    $0x5,%esi\njle    d5 <func0+0xd5>\nmov    (%rsp),%r8d\nlea    0xc(%rsp),%rdi\nmov    $0x1,%edx\nxor    %eax,%eax\nmov    $0x3,%ecx\nlea    (%rdx,%rax,1),%r10d\nadd    $0xc,%rdi\nadd    %r10d,%r8d\nlea    (%r8,%rdx,1),%r10d\nmov    %r8d,-0xc(%rdi)\nadd    %r10d,%eax\nlea    (%r8,%rax,1),%r10d\nmov    %eax,-0x8(%rdi)\nadd    %r10d,%edx\nmov    %ecx,%r10d\nadd    $0x3,%ecx\nadd    $0x4,%r10d\nmov    %edx,-0x4(%rdi)\ncmp    %r10d,%r11d\njg     65 <func0+0x65>\nmovslq %ecx,%rax\nlea    (%r9,%rax,4),%rax\nxchg   %ax,%ax\nmov    -0x4(%rax),%edx\nadd    $0x1,%ecx\nadd    -0x8(%rax),%edx\nadd    $0x4,%rax\nadd    -0x10(%rax),%edx\nmov    %edx,-0x4(%rax)\ncmp    %ecx,%esi\njge    a0 <func0+0xa0>\nmov    0x198(%rsp),%rdi\n00\nxor    %fs:0x28,%rdi\n00 00\nmov    (%rsp,%rsi,4),%eax\njne    dc <func0+0xdc>\nadd    $0x1a8,%rsp\nretq\nmov    $0x3,%ecx\njmp    97 <func0+0x97>\ncallq  e1 <func0+0xe1>"
    },
    {
        "task_id": 64,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  2e <func0+0x2e>\nmov    %eax,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    68 <func0+0x68>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncallq  5b <func0+0x5b>\ntest   %rax,%rax\nje     64 <func0+0x64>\naddl   $0x1,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     3a <func0+0x3a>\ncmpl   $0x0,-0xc(%rbp)\njle    a8 <func0+0xa8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x79,%al\nje     a4 <func0+0xa4>\nmov    -0xc(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x59,%al\njne    a8 <func0+0xa8>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nleaveq\nretq"
    },
    {
        "task_id": 64,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r15\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%r12\ntest   %r12d,%r12d\njle    8a <func0+0x8a>\nmov    %r15,%rbx\nlea    -0x1(%r12),%eax\nlea    0x1(%r15,%rax,1),%r14\nmov    $0x0,%ebp\nlea    0x0(%rip),%r13\nmovsbl (%rbx),%esi\nmov    %r13,%rdi\ncallq  53 <func0+0x53>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebp\nadd    $0x1,%rbx\ncmp    %r14,%rbx\njne    48 <func0+0x48>\nmovslq %r12d,%r12\nmovzbl -0x1(%r15,%r12,1),%eax\nand    $0xffffffdf,%eax\ncmp    $0x59,%al\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebp\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    $0x0,%ebp\njmp    79 <func0+0x79>"
    },
    {
        "task_id": 64,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ncallq  1a <func0+0x1a>\ntest   %eax,%eax\njle    88 <func0+0x88>\nmov    %rax,%r13\nlea    -0x1(%rax),%eax\nmov    %r14,%rbx\nxor    %r15d,%r15d\nlea    0x1(%r14,%rax,1),%r12\nlea    0x0(%rip),%rbp\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmovsbl (%rbx),%esi\nmov    %rbp,%rdi\ncallq  4b <func0+0x4b>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r15d\nadd    $0x1,%rbx\ncmp    %r12,%rbx\njne    40 <func0+0x40>\nmovslq %r13d,%r13\nmovzbl -0x1(%r14,%r13,1),%eax\nand    $0xffffffdf,%eax\ncmp    $0x59,%al\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%r15d\nadd    $0x8,%rsp\nmov    %r15d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   (%rax)\nxor    %r15d,%r15d\njmp    73 <func0+0x73>"
    },
    {
        "task_id": 64,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ncallq  1a <func0+0x1a>\ntest   %eax,%eax\njle    88 <func0+0x88>\nmov    %rax,%r13\nlea    -0x1(%rax),%eax\nmov    %r14,%rbx\nxor    %r15d,%r15d\nlea    0x1(%r14,%rax,1),%r12\nlea    0x0(%rip),%rbp\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmovsbl (%rbx),%esi\nmov    %rbp,%rdi\ncallq  4b <func0+0x4b>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r15d\nadd    $0x1,%rbx\ncmp    %r12,%rbx\njne    40 <func0+0x40>\nmovslq %r13d,%r13\nmovzbl -0x1(%r14,%r13,1),%eax\nand    $0xffffffdf,%eax\ncmp    $0x59,%al\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%r15d\nadd    $0x8,%rsp\nmov    %r15d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   (%rax)\nxor    %r15d,%r15d\njmp    73 <func0+0x73>"
    },
    {
        "task_id": 65,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %edi,-0x54(%rbp)\nmov    %esi,-0x58(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x54(%rbp),%eax\nmov    %eax,%edx\nlea    0x0(%rip),%rsi\nlea    0x0(%rip),%rdi\nmov    $0x0,%eax\ncallq  3e <func0+0x3e>\nlea    0x0(%rip),%rdi\ncallq  4a <func0+0x4a>\nmov    %eax,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    -0x58(%rbp),%eax\njge    c6 <func0+0xc6>\nmovl   $0x0,-0x48(%rbp)\njmp    b3 <func0+0xb3>\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmov    %al,-0x49(%rbp)\nmov    -0x44(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x48(%rbp),%eax\ncltq\nlea    0x0(%rip),%rdx\nmovzbl (%rax,%rdx,1),%edx\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(%rip),%rcx\nmov    %dl,(%rax,%rcx,1)\nmov    -0x44(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x48(%rbp),%eax\ncltq\nlea    0x0(%rip),%rcx\nmovzbl -0x49(%rbp),%edx\nmov    %dl,(%rax,%rcx,1)\naddl   $0x1,-0x48(%rbp)\nmov    -0x44(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x48(%rbp)\njl     5e <func0+0x5e>\njmp    126 <func0+0x126>\nmov    -0x44(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x58(%rbp),%eax\ncltq\nsub    %rax,%rdx\nlea    0x0(%rip),%rax\nadd    %rax,%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  ed <func0+0xed>\nmov    -0x58(%rbp),%eax\ncltq\nmovb   $0x0,-0x40(%rbp,%rax,1)\nmov    -0x44(%rbp),%eax\nsub    -0x58(%rbp),%eax\nmovslq %eax,%rdx\nlea    -0x40(%rbp),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  113 <func0+0x113>\nlea    -0x40(%rbp),%rax\nmov    %rax,%rsi\nlea    0x0(%rip),%rdi\ncallq  126 <func0+0x126>\nlea    0x0(%rip),%rax\nmov    -0x8(%rbp),%rcx\nxor    %fs:0x28,%rcx\n00 00\nje     141 <func0+0x141>\ncallq  141 <func0+0x141>\nleaveq\nretq"
    },
    {
        "task_id": 65,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x40,%rsp\nmov    %edi,%r8d\nmov    %esi,%ebp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nlea    0x0(%rip),%rcx\nmov    $0x32,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rdi\ncallq  42 <func0+0x42>\nlea    0x0(%rip),%rdi\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%rbx\ncmp    %ebp,%ebx\njge    ce <func0+0xce>\nmov    %ebx,%r8d\nshr    $0x1f,%r8d\nadd    %ebx,%r8d\nsar    %r8d\ncmp    $0x1,%ebx\njle    aa <func0+0xaa>\nmovslq %ebx,%rdx\nlea    0x0(%rip),%rax\nadd    %rax,%rdx\nmov    $0x0,%eax\nlea    0x0(%rip),%rcx\nmovzbl (%rcx,%rax,1),%esi\nmovzbl -0x1(%rdx),%edi\nmov    %dil,(%rcx,%rax,1)\nmov    %sil,-0x1(%rdx)\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %eax,%r8d\njg     8d <func0+0x8d>\nmov    0x38(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    11d <func0+0x11d>\nlea    0x0(%rip),%rax\nadd    $0x40,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nmovslq %ebx,%rsi\nmovslq %ebp,%r14\nsub    %r14,%rsi\nlea    0x0(%rip),%r12\nadd    %r12,%rsi\nmov    %rsp,%r13\nmov    $0x32,%edx\nmov    %r13,%rdi\ncallq  f1 <func0+0xf1>\nmovb   $0x0,(%rsp,%r14,1)\nsub    %ebp,%ebx\nmovslq %ebx,%rdx\nmov    $0x32,%ecx\nmov    %r12,%rsi\nmov    %r13,%rdi\ncallq  10b <func0+0x10b>\nmov    $0x32,%edx\nmov    %r13,%rsi\nmov    %r12,%rdi\ncallq  11b <func0+0x11b>\njmp    aa <func0+0xaa>\ncallq  122 <func0+0x122>"
    },
    {
        "task_id": 65,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %edi,%r8d\nmov    $0x32,%edx\nlea    0x0(%rip),%rcx\npush   %rbp\nlea    0x0(%rip),%rdi\nmov    %esi,%ebp\nmov    $0x1,%esi\npush   %rbx\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\ncallq  3e <func0+0x3e>\nlea    0x0(%rip),%rcx\nmov    %rcx,%rsi\nmov    %rcx,%rbx\nmov    (%rbx),%edx\nadd    $0x4,%rbx\nlea    -0x1010101(%rdx),%eax\nnot    %edx\nand    %edx,%eax\nand    $0x80808080,%eax\nje     4b <func0+0x4b>\nmov    %eax,%edx\nshr    $0x10,%edx\ntest   $0x8080,%eax\ncmove  %edx,%eax\nlea    0x2(%rbx),%rdx\ncmove  %rdx,%rbx\nmov    %eax,%edi\nadd    %al,%dil\nsbb    $0x3,%rbx\nsub    %rcx,%rbx\nmovslq %ebx,%rcx\ncmp    %ebp,%ebx\njge    e8 <func0+0xe8>\nsar    %ebx\nje     c2 <func0+0xc2>\nlea    0x0(%rip),%rax\nlea    -0x1(%rbx),%edi\nlea    0x1(%rax),%rdx\nlea    -0x1(%rsi,%rcx,1),%rcx\nadd    %rdx,%rdi\nnopl   0x0(%rax)\nmovzbl (%rcx),%esi\nmovzbl (%rax),%edx\nadd    $0x1,%rax\nsub    $0x1,%rcx\nmov    %sil,-0x1(%rax)\nmov    %dl,0x1(%rcx)\ncmp    %rdi,%rax\njne    a8 <func0+0xa8>\nmov    0x38(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    138 <func0+0x138>\nadd    $0x40,%rsp\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\nretq\nnopw   0x0(%rax,%rax,1)\nmovslq %ebp,%r12\nmov    %rbx,%rax\nmov    %rsp,%r8\nmov    $0x32,%edx\nsub    %r12,%rax\nmov    %r8,%rdi\nsub    %ebp,%ebx\nadd    %rax,%rsi\ncallq  106 <func0+0x106>\nmovslq %ebx,%rdx\nmov    $0x32,%ecx\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\nmovb   $0x0,(%rsp,%r12,1)\ncallq  122 <func0+0x122>\nmov    $0x32,%edx\nlea    0x0(%rip),%rdi\nmov    %rax,%rsi\ncallq  136 <func0+0x136>\njmp    c2 <func0+0xc2>\ncallq  13d <func0+0x13d>"
    },
    {
        "task_id": 65,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %edi,%r8d\nmov    $0x32,%edx\nlea    0x0(%rip),%rcx\npush   %rbp\nlea    0x0(%rip),%rdi\nmov    %esi,%ebp\nmov    $0x1,%esi\npush   %rbx\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\ncallq  3e <func0+0x3e>\nlea    0x0(%rip),%rcx\nmov    %rcx,%rsi\nmov    %rcx,%rbx\nmov    (%rbx),%edx\nadd    $0x4,%rbx\nlea    -0x1010101(%rdx),%eax\nnot    %edx\nand    %edx,%eax\nand    $0x80808080,%eax\nje     4b <func0+0x4b>\nmov    %eax,%edx\nshr    $0x10,%edx\ntest   $0x8080,%eax\ncmove  %edx,%eax\nlea    0x2(%rbx),%rdx\ncmove  %rdx,%rbx\nmov    %eax,%edi\nadd    %al,%dil\nsbb    $0x3,%rbx\nsub    %rcx,%rbx\nmovslq %ebx,%rcx\ncmp    %ebp,%ebx\njge    e8 <func0+0xe8>\nsar    %ebx\nje     c2 <func0+0xc2>\nlea    0x0(%rip),%rax\nlea    -0x1(%rbx),%edi\nlea    0x1(%rax),%rdx\nlea    -0x1(%rsi,%rcx,1),%rcx\nadd    %rdx,%rdi\nnopl   0x0(%rax)\nmovzbl (%rcx),%esi\nmovzbl (%rax),%edx\nadd    $0x1,%rax\nsub    $0x1,%rcx\nmov    %sil,-0x1(%rax)\nmov    %dl,0x1(%rcx)\ncmp    %rdi,%rax\njne    a8 <func0+0xa8>\nmov    0x38(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    138 <func0+0x138>\nadd    $0x40,%rsp\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\nretq\nnopw   0x0(%rax,%rax,1)\nmovslq %ebp,%r12\nmov    %rbx,%rax\nmov    %rsp,%r8\nmov    $0x32,%edx\nsub    %r12,%rax\nmov    %r8,%rdi\nsub    %ebp,%ebx\nadd    %rax,%rsi\ncallq  106 <func0+0x106>\nmovslq %ebx,%rdx\nmov    $0x32,%ecx\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\nmovb   $0x0,(%rsp,%r12,1)\ncallq  122 <func0+0x122>\nmov    $0x32,%edx\nlea    0x0(%rip),%rdi\nmov    %rax,%rsi\ncallq  136 <func0+0x136>\njmp    c2 <func0+0xc2>\ncallq  13d <func0+0x13d>"
    },
    {
        "task_id": 66,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    5e <func0+0x5e>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x40,%al\njle    5a <func0+0x5a>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5a,%al\njg     5a <func0+0x5a>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1c <func0+0x1c>\nmov    -0x8(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 66,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     31 <func0+0x31>\nadd    $0x1,%rdi\nmov    $0x0,%edx\nlea    -0x41(%rax),%ecx\nmovsbl %al,%eax\nadd    %edx,%eax\ncmp    $0x1a,%cl\ncmovb  %eax,%edx\nadd    $0x1,%rdi\nmovzbl -0x1(%rdi),%eax\ntest   %al,%al\njne    14 <func0+0x14>\nmov    %edx,%eax\nretq\nmov    $0x0,%edx\njmp    2e <func0+0x2e>"
    },
    {
        "task_id": 66,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovsbl (%rdi),%eax\ntest   %al,%al\nje     38 <func0+0x38>\nadd    $0x1,%rdi\nxor    %r8d,%r8d\nnopw   0x0(%rax,%rax,1)\nlea    -0x41(%rax),%edx\nadd    %r8d,%eax\ncmp    $0x1a,%dl\ncmovb  %eax,%r8d\nmovsbl (%rdi),%eax\nadd    $0x1,%rdi\ntest   %al,%al\njne    18 <func0+0x18>\nmov    %r8d,%eax\nretq\nnopl   0x0(%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 66,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovsbl (%rdi),%eax\ntest   %al,%al\nje     38 <func0+0x38>\nadd    $0x1,%rdi\nxor    %r8d,%r8d\nnopw   0x0(%rax,%rax,1)\nlea    -0x41(%rax),%edx\nadd    %r8d,%eax\ncmp    $0x1a,%dl\ncmovb  %eax,%r8d\nmovsbl (%rdi),%eax\nadd    $0x1,%rdi\ntest   %al,%al\njne    18 <func0+0x18>\nmov    %r8d,%eax\nretq\nnopl   0x0(%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 67,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %esi,-0x4c(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x2c(%rbp)\n00\nmovw   $0x0,-0x24(%rbp)\nmovq   $0x0,-0x22(%rbp)\n00\nmovw   $0x0,-0x1a(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmovl   $0x0,-0x30(%rbp)\njmpq   f2 <func0+0xf2>\ncallq  5e <func0+0x5e>\nmov    (%rax),%rax\nmov    -0x30(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x48(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovsbq %dl,%rdx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x800,%eax\ntest   %eax,%eax\nje     d4 <func0+0xd4>\ncmpl   $0x0,-0x38(%rbp)\njne    b2 <func0+0xb2>\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x34(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x34(%rbp)\nmovzbl (%rcx),%edx\ncltq\nmov    %dl,-0x2c(%rbp,%rax,1)\njmp    ee <func0+0xee>\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x34(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x34(%rbp)\nmovzbl (%rcx),%edx\ncltq\nmov    %dl,-0x22(%rbp,%rax,1)\njmp    ee <func0+0xee>\ncmpl   $0x0,-0x38(%rbp)\njne    ee <func0+0xee>\ncmpl   $0x0,-0x34(%rbp)\njle    ee <func0+0xee>\nmovl   $0x1,-0x38(%rbp)\nmovl   $0x0,-0x34(%rbp)\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    59 <func0+0x59>\nlea    -0x2c(%rbp),%rax\nmov    %rax,%rdi\ncallq  116 <func0+0x116>\nmov    -0x4c(%rbp),%edx\nmov    %edx,%ebx\nsub    %eax,%ebx\nlea    -0x22(%rbp),%rax\nmov    %rax,%rdi\ncallq  129 <func0+0x129>\nsub    %eax,%ebx\nmov    %ebx,%eax\nmov    -0x18(%rbp),%rsi\nxor    %fs:0x28,%rsi\n00 00\nje     141 <func0+0x141>\ncallq  141 <func0+0x141>\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 67,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x20,%rsp\nmov    %esi,%r12d\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmovq   $0x0,0x4(%rsp)\n00 00\nmovw   $0x0,0xc(%rsp)\nmovq   $0x0,0xe(%rsp)\n00 00\nmovw   $0x0,0x16(%rsp)\nmovzbl (%rdi),%ebx\ntest   %bl,%bl\nje     b3 <func0+0xb3>\nmov    %rdi,%rbp\ncallq  4e <func0+0x4e>\nmov    (%rax),%rsi\nlea    0x1(%rbp),%rdi\nmov    $0x0,%edx\nmov    $0x0,%eax\nmov    $0x0,%r9d\nmov    $0x1,%r8d\njmp    98 <func0+0x98>\nmovslq %edx,%rcx\nmov    %bl,0xe(%rsp,%rcx,1)\nlea    0x1(%rdx),%edx\njmp    8c <func0+0x8c>\ntest   %eax,%eax\njne    8c <func0+0x8c>\ntest   %edx,%edx\nsetg   %cl\ntest   %cl,%cl\ncmovne %r9d,%edx\ncmovne %r8d,%eax\nadd    $0x1,%rdi\nmovzbl -0x1(%rdi),%ebx\ntest   %bl,%bl\nje     b3 <func0+0xb3>\nmovsbq %bl,%rcx\ntestb  $0x8,0x1(%rsi,%rcx,2)\nje     79 <func0+0x79>\ntest   %eax,%eax\njne    6d <func0+0x6d>\nmovslq %edx,%rcx\nmov    %bl,0x4(%rsp,%rcx,1)\nlea    0x1(%rdx),%edx\njmp    8c <func0+0x8c>\nlea    0x4(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncallq  c7 <func0+0xc7>\nsub    %eax,%r12d\nlea    0xe(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncallq  de <func0+0xde>\nsub    %eax,%r12d\nmov    %r12d,%eax\nmov    0x18(%rsp),%rsi\nxor    %fs:0x28,%rsi\n00 00\njne    fd <func0+0xfd>\nadd    $0x20,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nretq\ncallq  102 <func0+0x102>"
    },
    {
        "task_id": 67,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nxor    %edx,%edx\nmov    %esi,%r12d\npush   %rbp\npush   %rbx\nsub    $0x20,%rsp\nmovzbl (%rdi),%ebx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nxor    %eax,%eax\nmov    %dx,0x16(%rsp)\nmovq   $0x0,0x4(%rsp)\n00 00\nmov    %ax,0xc(%rsp)\nmovq   $0x0,0xe(%rsp)\n00 00\ntest   %bl,%bl\nje     ae <func0+0xae>\nmov    %rdi,%rbp\ncallq  4e <func0+0x4e>\nlea    0x1(%rbp),%rdi\nxor    %edx,%edx\nxor    %r9d,%r9d\nmov    (%rax),%rsi\nmov    $0x1,%r8d\nxor    %eax,%eax\njmp    85 <func0+0x85>\nnopl   0x0(%rax)\nmovslq %edx,%rcx\ntest   %eax,%eax\njne    f8 <func0+0xf8>\nmov    %bl,0x4(%rsp,%rcx,1)\nadd    $0x1,%edx\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\nje     ae <func0+0xae>\nmovsbq %bl,%rcx\ntestb  $0x8,0x1(%rsi,%rcx,2)\njne    68 <func0+0x68>\ntest   %eax,%eax\njne    7a <func0+0x7a>\ntest   %edx,%edx\nsetg   %cl\ntest   %cl,%cl\ncmovne %r9d,%edx\ncmovne %r8d,%eax\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\njne    85 <func0+0x85>\nxor    %esi,%esi\nlea    0x4(%rsp),%rdi\nmov    $0xa,%edx\ncallq  bf <func0+0xbf>\nxor    %esi,%esi\nlea    0xe(%rsp),%rdi\nmov    $0xa,%edx\nsub    %eax,%r12d\ncallq  d3 <func0+0xd3>\nsub    %eax,%r12d\nmov    0x18(%rsp),%rsi\nxor    %fs:0x28,%rsi\n00 00\nmov    %r12d,%eax\njne    104 <func0+0x104>\nadd    $0x20,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nretq\nnopw   0x0(%rax,%rax,1)\nmov    %bl,0xe(%rsp,%rcx,1)\nadd    $0x1,%edx\njmpq   7a <func0+0x7a>\ncallq  109 <func0+0x109>"
    },
    {
        "task_id": 67,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nxor    %edx,%edx\nmov    %esi,%r12d\npush   %rbp\npush   %rbx\nsub    $0x20,%rsp\nmovzbl (%rdi),%ebx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nxor    %eax,%eax\nmov    %dx,0x16(%rsp)\nmovq   $0x0,0x4(%rsp)\n00 00\nmov    %ax,0xc(%rsp)\nmovq   $0x0,0xe(%rsp)\n00 00\ntest   %bl,%bl\nje     ae <func0+0xae>\nmov    %rdi,%rbp\ncallq  4e <func0+0x4e>\nlea    0x1(%rbp),%rdi\nxor    %edx,%edx\nxor    %r9d,%r9d\nmov    (%rax),%rsi\nmov    $0x1,%r8d\nxor    %eax,%eax\njmp    85 <func0+0x85>\nnopl   0x0(%rax)\nmovslq %edx,%rcx\ntest   %eax,%eax\njne    f8 <func0+0xf8>\nmov    %bl,0x4(%rsp,%rcx,1)\nadd    $0x1,%edx\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\nje     ae <func0+0xae>\nmovsbq %bl,%rcx\ntestb  $0x8,0x1(%rsi,%rcx,2)\njne    68 <func0+0x68>\ntest   %eax,%eax\njne    7a <func0+0x7a>\ntest   %edx,%edx\nsetg   %cl\ntest   %cl,%cl\ncmovne %r9d,%edx\ncmovne %r8d,%eax\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\njne    85 <func0+0x85>\nxor    %esi,%esi\nlea    0x4(%rsp),%rdi\nmov    $0xa,%edx\ncallq  bf <func0+0xbf>\nxor    %esi,%esi\nlea    0xe(%rsp),%rdi\nmov    $0xa,%edx\nsub    %eax,%r12d\ncallq  d3 <func0+0xd3>\nsub    %eax,%r12d\nmov    0x18(%rsp),%rsi\nxor    %fs:0x28,%rsi\n00 00\nmov    %r12d,%eax\njne    104 <func0+0x104>\nadd    $0x20,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nretq\nnopw   0x0(%rax,%rax,1)\nmov    %bl,0xe(%rsp,%rcx,1)\nadd    $0x1,%edx\njmpq   7a <func0+0x7a>\ncallq  109 <func0+0x109>"
    },
    {
        "task_id": 68,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x7fffffff,-0xc(%rbp)\nmovl   $0xffffffff,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    8b <func0+0x8b>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    87 <func0+0x87>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njg     68 <func0+0x68>\ncmpl   $0xffffffff,-0x8(%rbp)\njne    87 <func0+0x87>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     2a <func0+0x2a>\ncmpl   $0xffffffff,-0x8(%rbp)\njne    a0 <func0+0xa0>\nmov    $0x0,%eax\njmp    ba <func0+0xba>\nmov    -0x28(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x28(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x28(%rbp),%rax\npop    %rbp\nretq"
    },
    {
        "task_id": 68,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    57 <func0+0x57>\nlea    -0x1(%rsi),%r10d\nmov    $0x0,%ecx\nmov    $0xffffffff,%r9d\nmov    $0x7fffffff,%eax\njmp    2f <func0+0x2f>\nmov    %r8d,%r9d\nmov    %esi,%eax\nlea    0x1(%rcx),%rsi\ncmp    %rcx,%r10\nje     47 <func0+0x47>\nmov    %rsi,%rcx\nmov    %ecx,%r8d\nmov    (%rdi,%rcx,4),%esi\ntest   $0x1,%sil\njne    23 <func0+0x23>\ncmp    $0xffffffff,%r9d\nje     1e <func0+0x1e>\ncmp    %eax,%esi\njl     1e <func0+0x1e>\njmp    23 <func0+0x23>\ncmp    $0xffffffff,%r9d\nje     5d <func0+0x5d>\nmov    %eax,(%rdx)\nmov    %r9d,0x4(%rdx)\nmov    %rdx,%rax\nretq\nmov    $0x0,%eax\nretq\nmov    $0x0,%eax\nretq"
    },
    {
        "task_id": 68,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    60 <func0+0x60>\nlea    -0x1(%rsi),%r10d\nxor    %ecx,%ecx\nmov    $0xffffffff,%r9d\nmov    $0x7fffffff,%eax\njmp    23 <func0+0x23>\nnopl   0x0(%rax,%rax,1)\nmov    %rsi,%rcx\nmov    (%rdi,%rcx,4),%esi\nmov    %ecx,%r8d\ntest   $0x1,%sil\njne    3e <func0+0x3e>\ncmp    $0xffffffff,%r9d\nje     39 <func0+0x39>\ncmp    %eax,%esi\njge    3e <func0+0x3e>\nmov    %r8d,%r9d\nmov    %esi,%eax\nlea    0x1(%rcx),%rsi\ncmp    %r10,%rcx\njne    20 <func0+0x20>\ncmp    $0xffffffff,%r9d\nje     60 <func0+0x60>\nmov    %eax,(%rdx)\nmov    %rdx,%rax\nmov    %r9d,0x4(%rdx)\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 68,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    60 <func0+0x60>\nlea    -0x1(%rsi),%r10d\nxor    %ecx,%ecx\nmov    $0xffffffff,%r9d\nmov    $0x7fffffff,%eax\njmp    23 <func0+0x23>\nnopl   0x0(%rax,%rax,1)\nmov    %rsi,%rcx\nmov    (%rdi,%rcx,4),%esi\nmov    %ecx,%r8d\ntest   $0x1,%sil\njne    3e <func0+0x3e>\ncmp    $0xffffffff,%r9d\nje     39 <func0+0x39>\ncmp    %esi,%eax\njle    3e <func0+0x3e>\nmov    %r8d,%r9d\nmov    %esi,%eax\nlea    0x1(%rcx),%rsi\ncmp    %rcx,%r10\njne    20 <func0+0x20>\ncmp    $0xffffffff,%r9d\nje     60 <func0+0x60>\nmov    %eax,(%rdx)\nmov    %rdx,%rax\nmov    %r9d,0x4(%rdx)\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 69,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    $0x4,%esi\nmov    %rax,%rdi\ncallq  28 <func0+0x28>\nmov    %rax,-0x8(%rbp)\nmovl   $0xffffffff,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmpq   e8 <func0+0xe8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nadd    $0x1,%edx\nmov    %edx,(%rax)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njl     e4 <func0+0xe4>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njge    e4 <func0+0xe4>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     3f <func0+0x3f>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncallq  100 <func0+0x100>\nmov    -0x10(%rbp),%eax\nleaveq\nretq"
    },
    {
        "task_id": 69,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    %esi,%ebx\nlea    0x1(%rsi),%edi\nmovslq %edi,%rdi\nmov    $0x4,%esi\ncallq  1f <func0+0x1f>\nmov    %rax,%rdi\ntest   %ebx,%ebx\njle    5e <func0+0x5e>\nmov    %rbp,%rcx\nlea    -0x1(%rbx),%eax\nlea    0x4(%rbp,%rax,4),%rax\nmov    $0xffffffff,%ebx\njmp    41 <func0+0x41>\nadd    $0x4,%rcx\ncmp    %rax,%rcx\nje     63 <func0+0x63>\nmov    (%rcx),%esi\nmovslq %esi,%rdx\nlea    (%rdi,%rdx,4),%r8\nmov    (%r8),%edx\nadd    $0x1,%edx\nmov    %edx,(%r8)\ncmp    %edx,%esi\njg     38 <func0+0x38>\ncmp    %esi,%ebx\ncmovl  %esi,%ebx\njmp    38 <func0+0x38>\nmov    $0xffffffff,%ebx\ncallq  68 <func0+0x68>\nmov    %ebx,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 69,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %esi,%r12d\npush   %rbx\nmov    %rdi,%rbx\nlea    0x1(%rsi),%edi\nmov    $0x4,%esi\nmovslq %edi,%rdi\nsub    $0x8,%rsp\ncallq  21 <func0+0x21>\nmov    %rax,%r8\ntest   %r12d,%r12d\njle    80 <func0+0x80>\nlea    -0x1(%r12),%eax\nmov    %rbx,%rdi\nmov    $0xffffffff,%r12d\nlea    0x4(%rbx,%rax,4),%rax\nnopl   0x0(%rax)\nmovslq (%rdi),%rdx\nlea    (%r8,%rdx,4),%rsi\nmov    %rdx,%rcx\nmov    (%rsi),%ebx\nlea    0x1(%rbx),%edx\nmov    %edx,(%rsi)\ncmp    %edx,%ecx\njg     5c <func0+0x5c>\ncmp    %ecx,%r12d\ncmovl  %ecx,%r12d\nadd    $0x4,%rdi\ncmp    %rdi,%rax\njne    40 <func0+0x40>\nmov    %r8,%rdi\ncallq  6d <func0+0x6d>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %r12\nretq\nnopl   0x0(%rax,%rax,1)\n00\nmov    $0xffffffff,%r12d\njmp    65 <func0+0x65>"
    },
    {
        "task_id": 69,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %esi,%r12d\npush   %rbx\nmov    %rdi,%rbx\nlea    0x1(%rsi),%edi\nmov    $0x4,%esi\nmovslq %edi,%rdi\nsub    $0x8,%rsp\ncallq  21 <func0+0x21>\nmov    %rax,%r8\ntest   %r12d,%r12d\njle    80 <func0+0x80>\nlea    -0x1(%r12),%eax\nmov    %rbx,%rdi\nmov    $0xffffffff,%r12d\nlea    0x4(%rbx,%rax,4),%rax\nnopl   0x0(%rax)\nmovslq (%rdi),%rdx\nlea    (%r8,%rdx,4),%rsi\nmov    %rdx,%rcx\nmov    (%rsi),%ebx\nlea    0x1(%rbx),%edx\nmov    %edx,(%rsi)\ncmp    %edx,%ecx\njg     5c <func0+0x5c>\ncmp    %ecx,%r12d\ncmovl  %ecx,%r12d\nadd    $0x4,%rdi\ncmp    %rdi,%rax\njne    40 <func0+0x40>\nmov    %r8,%rdi\ncallq  6d <func0+0x6d>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %r12\nretq\nnopl   0x0(%rax,%rax,1)\n00\nmov    $0xffffffff,%r12d\njmp    65 <func0+0x65>"
    },
    {
        "task_id": 70,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmpq   d0 <func0+0xd0>\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmpq   c0 <func0+0xc0>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    bc <func0+0xbc>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     2d <func0+0x2d>\naddl   $0x1,-0x18(%rbp)\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x18(%rbp)\njl     1f <func0+0x1f>\nmovl   $0x0,-0x10(%rbp)\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmpq   1b0 <func0+0x1b0>\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njne    13e <func0+0x13e>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x8(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\njmp    1b0 <func0+0x1b0>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x8(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\nmov    -0xc(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x8(%rbp)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njle    fb <func0+0xfb>\nnop\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 70,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nlea    -0x1(%rsi),%r10d\ntest   %r10d,%r10d\njle    53 <func0+0x53>\nmov    %rdi,%r9\nlea    -0x2(%rsi),%ebx\nadd    $0x2,%rbx\nmov    $0x1,%r11d\njmp    49 <func0+0x49>\nadd    $0x1,%rax\ncmp    %eax,%esi\njle    3c <func0+0x3c>\nmov    (%r9),%ecx\nmov    (%rdi,%rax,4),%r8d\ncmp    %r8d,%ecx\njle    20 <func0+0x20>\nmov    %r8d,(%r9)\nmov    %ecx,(%rdi,%rax,4)\njmp    20 <func0+0x20>\nadd    $0x1,%r11\nadd    $0x4,%r9\ncmp    %rbx,%r11\nje     55 <func0+0x55>\ncmp    %r11d,%esi\njle    3c <func0+0x3c>\nmov    %r11,%rax\njmp    28 <func0+0x28>\njne    8c <func0+0x8c>\nmovslq %r10d,%rcx\nmov    $0x0,%eax\njmp    78 <func0+0x78>\nmov    (%rdi,%rax,4),%esi\nmov    %esi,(%rdx,%rax,8)\nmov    (%rdi,%rcx,4),%esi\nmov    %esi,0x4(%rdx,%rax,8)\nadd    $0x1,%rax\nsub    $0x1,%rcx\ncmp    %ecx,%eax\njg     8c <func0+0x8c>\nlea    (%rax,%rax,1),%esi\ncmp    %eax,%ecx\njne    5f <func0+0x5f>\nmovslq %eax,%r8\nmov    (%rdi,%r8,4),%eax\nmovslq %esi,%rsi\nmov    %eax,(%rdx,%rsi,4)\npop    %rbx\nretq"
    },
    {
        "task_id": 70,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    -0x1(%rsi),%r11d\npush   %rbx\ntest   %r11d,%r11d\njle    a5 <func0+0xa5>\nlea    -0x2(%rsi),%ebx\nmov    %rdi,%r9\nmov    $0x1,%r10d\nadd    $0x2,%rbx\nnopw   0x0(%rax,%rax,1)\nmov    %r10,%rax\ncmp    %r10d,%esi\njle    4a <func0+0x4a>\nmov    (%r9),%ecx\nmov    (%rdi,%rax,4),%r8d\ncmp    %r8d,%ecx\njle    42 <func0+0x42>\nmov    %r8d,(%r9)\nmov    %ecx,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     30 <func0+0x30>\nadd    $0x1,%r10\nadd    $0x4,%r9\ncmp    %rbx,%r10\njne    28 <func0+0x28>\nxor    %eax,%eax\nxor    %esi,%esi\njmp    7c <func0+0x7c>\nnopl   (%rax)\nmovslq %r11d,%r8\nadd    $0x1,%rax\nsub    $0x1,%r11d\nadd    $0x2,%esi\nmov    (%rdi,%r8,4),%r8d\nmov    %r8d,0x4(%rdx,%rcx,1)\ncmp    %eax,%r11d\njl     a3 <func0+0xa3>\nmovslq %esi,%rcx\nmov    (%rdi,%rax,4),%r9d\nlea    0x1(%rsi),%r10d\nshl    $0x2,%rcx\nlea    (%rdx,%rcx,1),%r8\nmov    %r9d,(%r8)\ncmp    %eax,%r11d\njne    60 <func0+0x60>\nadd    $0x1,%rax\nmov    %r10d,%esi\ncmp    %eax,%r11d\njge    7c <func0+0x7c>\npop    %rbx\nretq\nje     57 <func0+0x57>\npop    %rbx\nretq"
    },
    {
        "task_id": 70,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    -0x1(%rsi),%r11d\npush   %rbx\ntest   %r11d,%r11d\njle    ae <func0+0xae>\nlea    -0x2(%rsi),%ebx\nmov    %rdi,%r9\nmov    $0x1,%r10d\nadd    $0x2,%rbx\nnopw   0x0(%rax,%rax,1)\nmov    %r10,%rax\ncmp    %r10d,%esi\njle    4a <func0+0x4a>\nmov    (%r9),%ecx\nmov    (%rdi,%rax,4),%r8d\ncmp    %r8d,%ecx\njle    42 <func0+0x42>\nmov    %r8d,(%r9)\nmov    %ecx,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    %eax,%esi\njg     30 <func0+0x30>\nadd    $0x1,%r10\nadd    $0x4,%r9\ncmp    %r10,%rbx\njne    28 <func0+0x28>\nxor    %eax,%eax\nxor    %esi,%esi\nnopl   0x0(%rax,%rax,1)\nmovslq %esi,%rcx\nmov    (%rdi,%rax,4),%r9d\nlea    0x1(%rsi),%r10d\nshl    $0x2,%rcx\nlea    (%rdx,%rcx,1),%r8\nmov    %r9d,(%r8)\ncmp    %eax,%r11d\nje     a0 <func0+0xa0>\nlea    -0x1(%r11),%r8d\nmovslq %r11d,%r11\nadd    $0x1,%rax\nadd    $0x2,%esi\nmov    (%rdi,%r11,4),%r9d\nmov    %r9d,0x4(%rdx,%rcx,1)\ncmp    %eax,%r8d\njl     b0 <func0+0xb0>\nmov    %r8d,%r11d\njmp    60 <func0+0x60>\nnopl   0x0(%rax)\nadd    $0x1,%rax\ncmp    %eax,%r11d\njl     b0 <func0+0xb0>\nmov    %r10d,%esi\njmp    60 <func0+0x60>\nje     57 <func0+0x57>\npop    %rbx\nretq"
    },
    {
        "task_id": 71,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovss  %xmm0,-0x14(%rbp)\nmovss  %xmm1,-0x18(%rbp)\nmovss  %xmm2,-0x1c(%rbp)\nmovss  -0x14(%rbp),%xmm0\nmovaps %xmm0,%xmm1\naddss  -0x18(%rbp),%xmm1\nmovss  -0x1c(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njae    60 <func0+0x60>\nmovss  -0x14(%rbp),%xmm0\nmovaps %xmm0,%xmm1\naddss  -0x1c(%rbp),%xmm1\nmovss  -0x18(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njae    60 <func0+0x60>\nmovss  -0x18(%rbp),%xmm0\nmovaps %xmm0,%xmm1\naddss  -0x1c(%rbp),%xmm1\nmovss  -0x14(%rbp),%xmm0\ncomiss %xmm1,%xmm0\njb     6a <func0+0x6a>\nmovss  0x0(%rip),%xmm0\n00\njmp    e6 <func0+0xe6>\nmovss  -0x14(%rbp),%xmm0\naddss  -0x18(%rbp),%xmm0\naddss  -0x1c(%rbp),%xmm0\nmovss  0x0(%rip),%xmm1\n00\ndivss  %xmm1,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmovss  -0x8(%rbp),%xmm0\nsubss  -0x14(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  -0x8(%rbp),%xmm1\nmovss  -0x8(%rbp),%xmm0\nsubss  -0x18(%rbp),%xmm0\nmulss  %xmm0,%xmm1\nmovss  -0x8(%rbp),%xmm0\nsubss  -0x1c(%rbp),%xmm0\nmulss  %xmm1,%xmm0\ncallq  bd <func0+0xbd>\nmovd   %xmm0,%eax\nmov    %eax,-0x4(%rbp)\nmovss  -0x4(%rbp),%xmm1\nmovss  0x0(%rip),%xmm0\n00\nmulss  %xmm1,%xmm0\ncallq  da <func0+0xda>\nmovss  0x0(%rip),%xmm1\n00\ndivss  %xmm1,%xmm0\nleaveq\nretq"
    },
    {
        "task_id": 71,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovaps %xmm0,%xmm3\naddss  %xmm1,%xmm3\ncomiss %xmm3,%xmm2\njae    ac <func0+0xac>\nmovss  0x0(%rip),%xmm4\n00\nmovaps %xmm0,%xmm5\naddss  %xmm2,%xmm5\ncomiss %xmm5,%xmm1\njae    b4 <func0+0xb4>\nmovaps %xmm1,%xmm5\naddss  %xmm2,%xmm5\ncomiss %xmm5,%xmm0\njae    b4 <func0+0xb4>\nsub    $0x18,%rsp\naddss  %xmm2,%xmm3\nmulss  0x0(%rip),%xmm3\n00\nmovaps %xmm3,%xmm6\nsubss  %xmm0,%xmm6\nmovaps %xmm6,%xmm0\nmulss  %xmm3,%xmm0\nmovaps %xmm3,%xmm7\nsubss  %xmm1,%xmm7\nmulss  %xmm7,%xmm0\nsubss  %xmm2,%xmm3\nmulss  %xmm3,%xmm0\nmovaps %xmm0,%xmm6\nsqrtss %xmm6,%xmm6\nmovss  %xmm6,0xc(%rsp)\npxor   %xmm1,%xmm1\nucomiss %xmm0,%xmm1\nja     a5 <func0+0xa5>\nmovss  0x0(%rip),%xmm0\n00\nmulss  0xc(%rsp),%xmm0\ncallq  92 <func0+0x92>\nmovaps %xmm0,%xmm4\ndivss  0x0(%rip),%xmm4\n00\nmovaps %xmm4,%xmm0\nadd    $0x18,%rsp\nretq\ncallq  aa <func0+0xaa>\njmp    7f <func0+0x7f>\nmovss  0x0(%rip),%xmm4\n00\nmovaps %xmm4,%xmm0\nretq"
    },
    {
        "task_id": 71,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovaps %xmm0,%xmm3\nmovss  0x0(%rip),%xmm5\n00\naddss  %xmm1,%xmm3\ncomiss %xmm3,%xmm2\njae    a0 <func0+0xa0>\nmovaps %xmm0,%xmm4\naddss  %xmm2,%xmm4\ncomiss %xmm4,%xmm1\njae    a0 <func0+0xa0>\nmovaps %xmm1,%xmm4\naddss  %xmm2,%xmm4\ncomiss %xmm4,%xmm0\njae    a0 <func0+0xa0>\naddss  %xmm2,%xmm3\nsub    $0x18,%rsp\nmulss  0x0(%rip),%xmm3\n00\nmovaps %xmm3,%xmm6\nmovaps %xmm3,%xmm7\nsubss  %xmm0,%xmm6\nsubss  %xmm1,%xmm7\nmovaps %xmm6,%xmm0\nmulss  %xmm3,%xmm0\nsubss  %xmm2,%xmm3\npxor   %xmm2,%xmm2\nmulss  %xmm7,%xmm0\nmulss  %xmm3,%xmm0\nucomiss %xmm0,%xmm2\nmovaps %xmm0,%xmm1\nsqrtss %xmm1,%xmm1\nja     a4 <func0+0xa4>\nmovss  0x0(%rip),%xmm0\n00\nmulss  %xmm1,%xmm0\ncallq  86 <func0+0x86>\nmovaps %xmm0,%xmm5\ndivss  0x0(%rip),%xmm5\n00\nadd    $0x18,%rsp\nmovaps %xmm5,%xmm0\nretq\nnopl   0x0(%rax)\nmovaps %xmm5,%xmm0\nretq\nmovss  %xmm1,0xc(%rsp)\ncallq  af <func0+0xaf>\nmovss  0xc(%rsp),%xmm1\njmp    75 <func0+0x75>"
    },
    {
        "task_id": 71,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovaps %xmm0,%xmm3\nmovss  0x0(%rip),%xmm5\n00\naddss  %xmm1,%xmm3\ncomiss %xmm3,%xmm2\njae    a0 <func0+0xa0>\nmovaps %xmm0,%xmm4\naddss  %xmm2,%xmm4\ncomiss %xmm4,%xmm1\njae    a0 <func0+0xa0>\nmovaps %xmm1,%xmm4\naddss  %xmm2,%xmm4\ncomiss %xmm4,%xmm0\njae    a0 <func0+0xa0>\naddss  %xmm2,%xmm3\nsub    $0x18,%rsp\nmulss  0x0(%rip),%xmm3\n00\nmovaps %xmm3,%xmm6\nmovaps %xmm3,%xmm7\nsubss  %xmm0,%xmm6\nsubss  %xmm1,%xmm7\nmovaps %xmm6,%xmm0\nmulss  %xmm3,%xmm0\nsubss  %xmm2,%xmm3\npxor   %xmm2,%xmm2\nmulss  %xmm7,%xmm0\nmulss  %xmm3,%xmm0\nucomiss %xmm0,%xmm2\nmovaps %xmm0,%xmm1\nsqrtss %xmm1,%xmm1\nja     a4 <func0+0xa4>\nmovss  0x0(%rip),%xmm0\n00\nmulss  %xmm1,%xmm0\ncallq  86 <func0+0x86>\nmovaps %xmm0,%xmm5\ndivss  0x0(%rip),%xmm5\n00\nadd    $0x18,%rsp\nmovaps %xmm5,%xmm0\nretq\nnopl   0x0(%rax)\nmovaps %xmm5,%xmm0\nretq\nmovss  %xmm1,0xc(%rsp)\ncallq  af <func0+0xaf>\nmovss  0xc(%rsp),%xmm1\njmp    75 <func0+0x75>"
    },
    {
        "task_id": 72,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    9d <func0+0x9d>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\nje     62 <func0+0x62>\nmov    $0x0,%eax\njmpq   f0 <func0+0xf0>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nadd    %edx,%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x4(%rbp)\njl     22 <func0+0x22>\nmov    -0x1c(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    e7 <func0+0xe7>\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x20(%rbp),%eax\nsetle  %al\npop    %rbp\nretq"
    },
    {
        "task_id": 72,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %esi,%ebx\nshr    $0x1f,%ebx\nadd    %esi,%ebx\nsar    %ebx\ncmp    $0x1,%esi\njle    60 <func0+0x60>\nmov    %ebx,%r11d\nmovslq %esi,%rax\nlea    (%rdi,%rax,4),%r8\nmov    $0x0,%ecx\nmov    $0x0,%r10d\nmov    (%rdi,%rcx,4),%eax\nmov    -0x4(%r8),%r9d\ncmp    %r9d,%eax\njne    71 <func0+0x71>\nadd    %r9d,%eax\nadd    %eax,%r10d\nadd    $0x1,%rcx\nsub    $0x4,%r8\ncmp    %ecx,%r11d\njg     28 <func0+0x28>\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %eax,%esi\nand    $0x1,%esi\nsub    %eax,%esi\ncmp    $0x1,%esi\nje     68 <func0+0x68>\ncmp    %edx,%r10d\nsetle  %al\npop    %rbx\nretq\nmov    $0x0,%r10d\njmp    47 <func0+0x47>\nmovslq %ebx,%rbx\nadd    (%rdi,%rbx,4),%r10d\njmp    58 <func0+0x58>\nmov    $0x0,%eax\njmp    5e <func0+0x5e>"
    },
    {
        "task_id": 72,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%r10d\nshr    $0x1f,%r10d\nadd    %esi,%r10d\nsar    %r10d\ncmp    $0x1,%esi\njle    4d <func0+0x4d>\nlea    -0x1(%rsi),%eax\nxor    %r9d,%r9d\ncltq\nlea    (%rdi,%rax,4),%rcx\nxor    %eax,%eax\njmp    41 <func0+0x41>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nadd    $0x1,%rax\nlea    (%r9,%r8,2),%r9d\nsub    $0x4,%rcx\ncmp    %eax,%r10d\njle    50 <func0+0x50>\nmov    (%rdi,%rax,4),%r8d\ncmp    (%rcx),%r8d\nje     30 <func0+0x30>\nxor    %eax,%eax\nretq\nxor    %r9d,%r9d\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %eax,%esi\nand    $0x1,%esi\nsub    %eax,%esi\ncmp    $0x1,%esi\nje     70 <func0+0x70>\ncmp    %edx,%r9d\nsetle  %al\nretq\nnopl   0x0(%rax,%rax,1)\n00\nmovslq %r10d,%r10\nadd    (%rdi,%r10,4),%r9d\ncmp    %edx,%r9d\nsetle  %al\nretq"
    },
    {
        "task_id": 72,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%r10d\nshr    $0x1f,%r10d\nadd    %esi,%r10d\nsar    %r10d\ncmp    $0x1,%esi\njle    4d <func0+0x4d>\nlea    -0x1(%rsi),%eax\nxor    %r9d,%r9d\ncltq\nlea    (%rdi,%rax,4),%rcx\nxor    %eax,%eax\njmp    41 <func0+0x41>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nadd    $0x1,%rax\nlea    (%r9,%r8,2),%r9d\nsub    $0x4,%rcx\ncmp    %eax,%r10d\njle    50 <func0+0x50>\nmov    (%rdi,%rax,4),%r8d\ncmp    (%rcx),%r8d\nje     30 <func0+0x30>\nxor    %eax,%eax\nretq\nxor    %r9d,%r9d\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %eax,%esi\nand    $0x1,%esi\nsub    %eax,%esi\ncmp    $0x1,%esi\nje     70 <func0+0x70>\ncmp    %edx,%r9d\nsetle  %al\nretq\nnopl   0x0(%rax,%rax,1)\n00\nmovslq %r10d,%r10\nadd    (%rdi,%r10,4),%r9d\ncmp    %edx,%r9d\nsetle  %al\nretq"
    },
    {
        "task_id": 73,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    5d <func0+0x5d>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\nje     59 <func0+0x59>\naddl   $0x1,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x4(%rbp)\njl     1f <func0+0x1f>\nmov    -0x8(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 73,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%r8d\nshr    $0x1f,%r8d\nadd    %esi,%r8d\nsar    %r8d\ncmp    $0x1,%esi\njle    47 <func0+0x47>\nmovslq %esi,%rsi\nlea    (%rdi,%rsi,4),%rdx\nmov    $0x0,%eax\nmov    $0x0,%ecx\nmov    -0x4(%rdx),%esi\ncmp    %esi,(%rdi,%rax,4)\nsetne  %sil\nmovzbl %sil,%esi\nadd    %esi,%ecx\nadd    $0x1,%rax\nsub    $0x4,%rdx\ncmp    %eax,%r8d\njg     27 <func0+0x27>\nmov    %ecx,%eax\nretq\nmov    $0x0,%ecx\njmp    44 <func0+0x44>"
    },
    {
        "task_id": 73,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%r9d\nshr    $0x1f,%r9d\nadd    %esi,%r9d\nsar    %r9d\ncmp    $0x1,%esi\njle    50 <func0+0x50>\nsub    $0x1,%esi\nxor    %eax,%eax\nxor    %r8d,%r8d\nmovslq %esi,%rsi\nlea    (%rdi,%rsi,4),%rdx\nnopl   (%rax)\nmov    (%rdx),%esi\nxor    %ecx,%ecx\ncmp    %esi,(%rdi,%rax,4)\nsetne  %cl\nadd    $0x1,%rax\nsub    $0x4,%rdx\nadd    %ecx,%r8d\ncmp    %eax,%r9d\njg     28 <func0+0x28>\nmov    %r8d,%eax\nretq\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 73,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%r8d\nshr    $0x1f,%r8d\nadd    %esi,%r8d\nsar    %r8d\ncmp    $0x1,%esi\njle    f8 <func0+0xf8>\nlea    -0x1(%rsi),%r9d\ncmp    $0x7,%esi\njle    101 <func0+0x101>\nmov    %r8d,%ecx\nmovslq %r9d,%rdx\npxor   %xmm1,%xmm1\nmov    %rdi,%rax\nshr    $0x2,%ecx\nlea    -0xc(%rdi,%rdx,4),%rdx\npcmpeqd %xmm2,%xmm2\nshl    $0x4,%rcx\nadd    %rdi,%rcx\nnopw   0x0(%rax,%rax,1)\n00 00\nmovdqu (%rdx),%xmm3\nmovdqu (%rax),%xmm4\nadd    $0x10,%rax\nsub    $0x10,%rdx\npshufd $0x1b,%xmm3,%xmm0\npcmpeqd %xmm4,%xmm0\npandn  %xmm2,%xmm0\npsubd  %xmm0,%xmm1\ncmp    %rcx,%rax\njne    50 <func0+0x50>\nmovdqa %xmm1,%xmm0\nmov    %r8d,%edx\npsrldq $0x8,%xmm0\nand    $0xfffffffc,%edx\npaddd  %xmm0,%xmm1\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\ntest   $0x3,%r8b\nje     100 <func0+0x100>\nmov    %r9d,%ecx\nmovslq %edx,%rsi\nsub    %edx,%ecx\nmovslq %ecx,%rcx\nmov    (%rdi,%rcx,4),%ecx\ncmp    %ecx,(%rdi,%rsi,4)\nje     b6 <func0+0xb6>\nadd    $0x1,%eax\nlea    0x1(%rdx),%ecx\ncmp    %r8d,%ecx\njge    fa <func0+0xfa>\nmov    %r9d,%esi\nsub    %ecx,%esi\nmovslq %ecx,%rcx\nmovslq %esi,%rsi\nmov    (%rdi,%rcx,4),%ecx\ncmp    %ecx,(%rdi,%rsi,4)\nje     d4 <func0+0xd4>\nadd    $0x1,%eax\nadd    $0x2,%edx\ncmp    %r8d,%edx\njge    fa <func0+0xfa>\nsub    %edx,%r9d\nmovslq %edx,%rcx\nmovslq %r9d,%r9\nmov    (%rdi,%r9,4),%esi\ncmp    %esi,(%rdi,%rcx,4)\nje     fa <func0+0xfa>\nadd    $0x1,%eax\nretq\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nretq\nnopl   0x0(%rax,%rax,1)\nretq\nxor    %edx,%edx\nxor    %eax,%eax\njmp    a0 <func0+0xa0>"
    },
    {
        "task_id": 74,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %ecx,-0x20(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    5e <func0+0x5e>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncallq  50 <func0+0x50>\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     31 <func0+0x31>\nmovl   $0x0,-0xc(%rbp)\njmp    9c <func0+0x9c>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncallq  8e <func0+0x8e>\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     6f <func0+0x6f>\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njge    b2 <func0+0xb2>\nmov    -0x18(%rbp),%rax\njmp    c4 <func0+0xc4>\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njle    c0 <func0+0xc0>\nmov    -0x28(%rbp),%rax\njmp    c4 <func0+0xc4>\nmov    -0x18(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 74,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%r10\nmov    %ecx,%r11d\ntest   %esi,%esi\njle    93 <func0+0x93>\nmov    %rdi,%r8\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%rbx\nmov    $0x0,%r9d\nmov    $0xffffffffffffffff,%rsi\nmov    $0x0,%eax\nmov    (%r8),%rdi\nmov    %rsi,%rcx\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%r9,%rcx,1),%r9d\nadd    $0x8,%r8\ncmp    %rbx,%r8\njne    30 <func0+0x30>\ntest   %r11d,%r11d\njle    8b <func0+0x8b>\nmov    $0x0,%esi\nmov    $0x0,%r8d\nmov    $0xffffffffffffffff,%rbx\nmov    $0x0,%eax\nmov    (%rdx,%rsi,8),%rdi\nmov    %rbx,%rcx\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%r8,%rcx,1),%r8d\nadd    $0x1,%rsi\ncmp    %esi,%r11d\njg     65 <func0+0x65>\ncmp    %r8d,%r9d\ncmovle %r10,%rdx\nmov    %rdx,%rax\npop    %rbx\nretq\nmov    $0x0,%r8d\njmp    7f <func0+0x7f>\nmov    $0x0,%r9d\ntest   %ecx,%ecx\njg     4e <func0+0x4e>\nmov    %rdi,%rdx\njmp    86 <func0+0x86>"
    },
    {
        "task_id": 74,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\nmov    %rdx,%r13\npush   %r12\nmov    %ecx,%r12d\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %esi,%esi\njle    80 <func0+0x80>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %ebp,%ebp\nlea    0x8(%rdi,%rax,8),%r15\nnopl   0x0(%rax)\nmov    (%rbx),%rdi\nadd    $0x8,%rbx\ncallq  3c <func0+0x3c>\nadd    %eax,%ebp\ncmp    %rbx,%r15\njne    30 <func0+0x30>\ntest   %r12d,%r12d\njle    90 <func0+0x90>\nxor    %ebx,%ebx\nxor    %r15d,%r15d\nnopl   (%rax)\nmov    0x0(%r13,%rbx,8),%rdi\nadd    $0x1,%rbx\ncallq  5e <func0+0x5e>\nadd    %eax,%r15d\ncmp    %ebx,%r12d\njg     50 <func0+0x50>\ncmp    %r15d,%ebp\nmov    %r13,%rax\ncmovle %r14,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnop\nxor    %ebp,%ebp\ntest   %ecx,%ecx\njg     48 <func0+0x48>\nmov    %rdi,%rax\njmp    70 <func0+0x70>\nnopl   0x0(%rax,%rax,1)\nxor    %r15d,%r15d\njmp    66 <func0+0x66>"
    },
    {
        "task_id": 74,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\nmov    %rdx,%r13\npush   %r12\nmov    %ecx,%r12d\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %esi,%esi\njle    80 <func0+0x80>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %ebp,%ebp\nlea    0x8(%rdi,%rax,8),%r15\nnopl   0x0(%rax)\nmov    (%rbx),%rdi\nadd    $0x8,%rbx\ncallq  3c <func0+0x3c>\nadd    %eax,%ebp\ncmp    %rbx,%r15\njne    30 <func0+0x30>\ntest   %r12d,%r12d\njle    90 <func0+0x90>\nxor    %ebx,%ebx\nxor    %r15d,%r15d\nnopl   (%rax)\nmov    0x0(%r13,%rbx,8),%rdi\nadd    $0x1,%rbx\ncallq  5e <func0+0x5e>\nadd    %eax,%r15d\ncmp    %ebx,%r12d\njg     50 <func0+0x50>\ncmp    %r15d,%ebp\nmov    %r13,%rax\ncmovle %r14,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnop\nxor    %ebp,%ebp\ntest   %ecx,%ecx\njg     48 <func0+0x48>\nmov    %rdi,%rax\njmp    70 <func0+0x70>\nnopl   0x0(%rax,%rax,1)\nxor    %r15d,%r15d\njmp    66 <func0+0x66>"
    },
    {
        "task_id": 75,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\ncmpl   $0x1,-0x14(%rbp)\njg     18 <func0+0x18>\nmov    $0x0,%eax\njmp    66 <func0+0x66>\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x2,-0x4(%rbp)\njmp    47 <func0+0x47>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %eax,-0x14(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\nje     28 <func0+0x28>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    36 <func0+0x36>\ncmpl   $0x1,-0x14(%rbp)\njle    5c <func0+0x5c>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x3,-0x8(%rbp)\nsete   %al\nmovzbl %al,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 75,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x0,%eax\ncmp    $0x1,%edi\njle    58 <func0+0x58>\nmov    $0x2,%ecx\nmov    $0x0,%esi\ncmp    $0x3,%edi\njg     3c <func0+0x3c>\njmp    4c <func0+0x4c>\nmov    %edi,%eax\ncltd\nidiv   %ecx\nmov    %eax,%edi\nadd    $0x1,%esi\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1f <func0+0x1f>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njg     47 <func0+0x47>\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     1f <func0+0x1f>\njmp    30 <func0+0x30>\ncmp    $0x1,%edi\njle    4f <func0+0x4f>\nadd    $0x1,%esi\ncmp    $0x3,%esi\nsete   %al\nmovzbl %al,%eax\nretq"
    },
    {
        "task_id": 75,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ncmp    $0x1,%edi\njle    5a <func0+0x5a>\nmov    $0x2,%ecx\nxor    %esi,%esi\ncmp    $0x3,%edi\njle    64 <func0+0x64>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    41 <func0+0x41>\nnopl   0x0(%rax)\nmov    %edi,%eax\nadd    $0x1,%esi\ncltd\nidiv   %ecx\ncltd\nmov    %eax,%edi\nidiv   %ecx\ntest   %edx,%edx\nje     30 <func0+0x30>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njle    20 <func0+0x20>\ncmp    $0x1,%edi\njle    5b <func0+0x5b>\nxor    %eax,%eax\ncmp    $0x2,%esi\nsete   %al\nretq\nxor    %eax,%eax\ncmp    $0x3,%esi\nsete   %al\nretq\nretq"
    },
    {
        "task_id": 75,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ncmp    $0x1,%edi\njle    5a <func0+0x5a>\nmov    $0x2,%ecx\nxor    %esi,%esi\ncmp    $0x3,%edi\njle    64 <func0+0x64>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    41 <func0+0x41>\nnopl   0x0(%rax)\nmov    %edi,%eax\nadd    $0x1,%esi\ncltd\nidiv   %ecx\ncltd\nmov    %eax,%edi\nidiv   %ecx\ntest   %edx,%edx\nje     30 <func0+0x30>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njle    20 <func0+0x20>\ncmp    $0x1,%edi\njle    5b <func0+0x5b>\nxor    %eax,%eax\ncmp    $0x2,%esi\nsete   %al\nretq\nxor    %eax,%eax\ncmp    $0x3,%esi\nsete   %al\nretq\nretq"
    },
    {
        "task_id": 76,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    3b <func0+0x3b>\nmov    -0x8(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njne    2d <func0+0x2d>\nmov    $0x1,%eax\njmp    4e <func0+0x4e>\nmov    -0x8(%rbp),%eax\nimul   -0x18(%rbp),%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njg     49 <func0+0x49>\ncmpl   $0x63,-0x4(%rbp)\njle    1e <func0+0x1e>\nmov    $0x0,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 76,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    36 <func0+0x36>\ncmp    $0x1,%edi\nje     3c <func0+0x3c>\nmov    $0x0,%edx\nmov    $0x1,%eax\nimul   %esi,%eax\nadd    $0x1,%edx\ncmp    %eax,%edi\njl     30 <func0+0x30>\ncmp    $0x63,%edx\njg     30 <func0+0x30>\ncmp    %eax,%edi\njne    17 <func0+0x17>\nmov    $0x1,%eax\nretq\nmov    $0x0,%eax\nretq\nmov    $0x0,%eax\nretq\nmov    %edi,%eax\nretq"
    },
    {
        "task_id": 76,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    38 <func0+0x38>\ncmp    $0x1,%edi\nje     2b <func0+0x2b>\nxor    %edx,%edx\nmov    $0x1,%eax\nnopl   0x0(%rax)\nimul   %esi,%eax\nadd    $0x1,%edx\ncmp    %eax,%edi\njl     38 <func0+0x38>\ncmp    $0x63,%edx\njg     38 <func0+0x38>\ncmp    %eax,%edi\njne    18 <func0+0x18>\nmov    $0x1,%eax\nretq\nnopl   0x0(%rax)\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 76,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    38 <func0+0x38>\ncmp    $0x1,%edi\nje     2b <func0+0x2b>\nxor    %edx,%edx\nmov    $0x1,%eax\nnopl   0x0(%rax)\nimul   %esi,%eax\nadd    $0x1,%edx\ncmp    %eax,%edi\njl     38 <func0+0x38>\ncmp    $0x63,%edx\njg     38 <func0+0x38>\ncmp    %eax,%edi\njne    18 <func0+0x18>\nmov    $0x1,%eax\nretq\nnopl   0x0(%rax)\nxor    %eax,%eax\nretq"
    },
    {
        "task_id": 77,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    3a <func0+0x3a>\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\nimul   -0x4(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x14(%rbp),%eax\ncltd\nmov    %edx,%eax\nxor    -0x14(%rbp),%eax\nsub    %edx,%eax\ncmp    %eax,%ecx\njne    36 <func0+0x36>\nmov    $0x1,%eax\njmp    5a <func0+0x5a>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\nimul   -0x4(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x14(%rbp),%eax\ncltd\nmov    %edx,%eax\nxor    -0x14(%rbp),%eax\nsub    %edx,%eax\ncmp    %eax,%ecx\njle    14 <func0+0x14>\nmov    $0x0,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 77,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nsar    $0x1f,%eax\nmov    %eax,%ecx\nxor    %edi,%ecx\nsub    %eax,%ecx\ntest   %edi,%edi\nje     36 <func0+0x36>\nmov    $0x1,%edx\nmov    $0x1,%eax\ncmp    %eax,%ecx\nje     3c <func0+0x3c>\nadd    $0x1,%edx\nmov    %edx,%eax\nimul   %edx,%eax\nimul   %edx,%eax\ncmp    %ecx,%eax\njle    1d <func0+0x1d>\nmov    $0x0,%eax\nretq\nmov    $0x1,%eax\nretq\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 77,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nsar    $0x1f,%eax\nmov    %eax,%ecx\nxor    %edi,%ecx\nsub    %eax,%ecx\ntest   %edi,%edi\nje     40 <func0+0x40>\nmov    $0x1,%edx\nmov    $0x1,%eax\nnopl   (%rax)\ncmp    %eax,%ecx\nje     40 <func0+0x40>\nadd    $0x1,%edx\nmov    %edx,%eax\nimul   %edx,%eax\nimul   %edx,%eax\ncmp    %ecx,%eax\njle    20 <func0+0x20>\nxor    %eax,%eax\nretq\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 77,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nsar    $0x1f,%eax\nmov    %eax,%ecx\nxor    %edi,%ecx\nsub    %eax,%ecx\ntest   %edi,%edi\nje     40 <func0+0x40>\nmov    $0x1,%edx\nmov    $0x1,%eax\nnopl   (%rax)\ncmp    %eax,%ecx\nje     40 <func0+0x40>\nadd    $0x1,%edx\nmov    %edx,%eax\nimul   %edx,%eax\nimul   %edx,%eax\ncmp    %ecx,%eax\njle    20 <func0+0x20>\nxor    %eax,%eax\nretq\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 78,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    5a <func0+0x5a>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncallq  4d <func0+0x4d>\ntest   %rax,%rax\nje     56 <func0+0x56>\naddl   $0x1,-0x20(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  6c <func0+0x6c>\ncmp    %rax,%rbx\njb     2c <func0+0x2c>\nmov    -0x20(%rbp),%eax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 78,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rdx\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nmov    %rdx,%rbx\nlea    -0x1(%rdx,%rcx,1),%r12\nmov    $0x0,%ebp\nlea    0x0(%rip),%r13\ncmp    %r12,%rbx\nje     53 <func0+0x53>\nmovsbl (%rbx),%esi\nmov    %r13,%rdi\ncallq  46 <func0+0x46>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%ebp\nadd    $0x1,%rbx\njmp    36 <func0+0x36>\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 78,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nlea    0x0(%rip),%r13\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x8,%rsp\ncallq  20 <func0+0x20>\nlea    (%rbx,%rax,1),%rbp\njmp    47 <func0+0x47>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmovsbl (%rbx),%esi\nmov    %r13,%rdi\ncallq  3b <func0+0x3b>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r12d\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\njne    30 <func0+0x30>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 78,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x8,%rsp\ncallq  16 <func0+0x16>\ntest   %rax,%rax\nje     60 <func0+0x60>\nlea    (%rbx,%rax,1),%rbp\nxor    %r12d,%r12d\nlea    0x0(%rip),%r13\nnopl   0x0(%rax)\nmovsbl (%rbx),%esi\nmov    %r13,%rdi\ncallq  3b <func0+0x3b>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r12d\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\njne    30 <func0+0x30>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopw   0x0(%rax,%rax,1)\nadd    $0x8,%rsp\nxor    %r12d,%r12d\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 79,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmov    $0x40,%edi\ncallq  19 <func0+0x19>\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    2e <func0+0x2e>\nmov    $0x0,%eax\njmpq   167 <func0+0x167>\nmovl   $0x3e,-0x1c(%rbp)\nmov    -0x10(%rbp),%rax\nadd    $0x3f,%rax\nmovb   $0x0,(%rax)\ncmpl   $0x0,-0x24(%rbp)\njne    95 <func0+0x95>\nmov    -0x1c(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\njmp    9b <func0+0x9b>\nmov    -0x24(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\nlea    0x30(%rax),%ecx\nmov    -0x1c(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\nmov    -0x24(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x24(%rbp)\ncmpl   $0x0,-0x24(%rbp)\njg     5e <func0+0x5e>\nmov    -0x1c(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x62,(%rax)\nmov    -0x1c(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x1c(%rbp)\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x64,(%rax)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\nmov    $0x3e,%eax\nsub    -0x18(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x3,%eax\ncltq\nmov    %rax,%rdi\ncallq  eb <func0+0xeb>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    109 <func0+0x109>\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncallq  102 <func0+0x102>\nmov    $0x0,%eax\njmp    167 <func0+0x167>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  125 <func0+0x125>\nmov    -0x8(%rbp),%rax\nmov    $0xffffffffffffffff,%rcx\nmov    %rax,%rdx\nmov    $0x0,%eax\nmov    %rdx,%rdi\nrepnz scas %es:(%rdi),%al\nmov    %rcx,%rax\nnot    %rax\nlea    -0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovw   $0x6264,(%rax)\nmovb   $0x0,0x2(%rax)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncallq  163 <func0+0x163>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 79,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebx\nmov    $0x40,%edi\ncallq  14 <func0+0x14>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     d8 <func0+0xd8>\nmovb   $0x0,0x3f(%rax)\ntest   %ebx,%ebx\nje     5b <func0+0x5b>\nmov    $0x3d,%edx\nmov    $0x3e,%esi\njle    64 <func0+0x64>\nmov    %edx,%esi\nmov    %ebx,%ecx\nshr    $0x1f,%ecx\nlea    (%rbx,%rcx,1),%eax\nand    $0x1,%eax\nsub    %ecx,%eax\nadd    $0x30,%eax\nmov    %al,0x1(%rbp,%rdx,1)\nmov    %ebx,%eax\nadd    %ecx,%ebx\nsar    %ebx\nsub    $0x1,%rdx\ncmp    $0x1,%eax\njg     34 <func0+0x34>\njmp    64 <func0+0x64>\nmovb   $0x30,0x3e(%rax)\nmov    $0x3d,%esi\nlea    -0x1(%rsi),%eax\nmovslq %esi,%rsi\nmovb   $0x62,0x0(%rbp,%rsi,1)\nmovslq %eax,%r12\nadd    %rbp,%r12\nmovb   $0x64,(%r12)\nmov    $0x41,%edi\nsub    %eax,%edi\nmovslq %edi,%rdi\ncallq  89 <func0+0x89>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     ce <func0+0xce>\nmov    %r12,%rsi\nmov    %rax,%rdi\ncallq  9c <func0+0x9c>\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nmov    %rbx,%rdi\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rbx,%rcx,1),%rax\nmovw   $0x6264,(%rax)\nmovb   $0x0,0x2(%rax)\nmov    %rbp,%rdi\ncallq  c6 <func0+0xc6>\nmov    %rbx,%rax\npop    %rbx\npop    %rbp\npop    %r12\nretq\nmov    %rbp,%rdi\ncallq  d6 <func0+0xd6>\njmp    c6 <func0+0xc6>\nmov    %rax,%rbx\njmp    c6 <func0+0xc6>"
    },
    {
        "task_id": 79,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebx\nmov    $0x40,%edi\nsub    $0x8,%rsp\ncallq  1a <func0+0x1a>\ntest   %rax,%rax\nje     e5 <func0+0xe5>\nmovb   $0x0,0x3f(%rax)\nmov    %rax,%rbp\ntest   %ebx,%ebx\njne    90 <func0+0x90>\nmovb   $0x30,0x3e(%rax)\nmov    $0x5,%edi\nmov    $0x3c,%r13d\nmov    $0x3d,%eax\nadd    %rbp,%r13\nmovb   $0x62,0x0(%rbp,%rax,1)\nmovb   $0x64,0x0(%r13)\ncallq  54 <func0+0x54>\nmov    %rax,%r12\ntest   %rax,%rax\nje     73 <func0+0x73>\nmov    %r13,%rsi\nmov    %rax,%rdi\ncallq  67 <func0+0x67>\nmov    $0x6264,%edx\nmov    %dx,(%rax)\nmovb   $0x0,0x2(%rax)\nmov    %rbp,%rdi\ncallq  7b <func0+0x7b>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopl   0x0(%rax)\nmov    $0x3d,%eax\njle    d0 <func0+0xd0>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %ebx,%edx\nmov    %eax,%ecx\nand    $0x1,%edx\nadd    $0x30,%edx\nmov    %dl,0x1(%rbp,%rax,1)\nsub    $0x1,%rax\nsar    %ebx\njne    a0 <func0+0xa0>\nmovslq %ecx,%rax\nmov    $0x41,%edi\nsub    $0x1,%ecx\nsub    %ecx,%edi\nmovslq %ecx,%r13\nmovslq %edi,%rdi\njmpq   42 <func0+0x42>\nxchg   %ax,%ax\nmov    $0x4,%edi\nmov    $0x3d,%r13d\nmov    $0x3e,%eax\njmpq   42 <func0+0x42>\nxor    %r12d,%r12d\njmp    7b <func0+0x7b>"
    },
    {
        "task_id": 79,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebx\nmov    $0x40,%edi\nsub    $0x8,%rsp\ncallq  1a <func0+0x1a>\ntest   %rax,%rax\nje     e5 <func0+0xe5>\nmovb   $0x0,0x3f(%rax)\nmov    %rax,%rbp\ntest   %ebx,%ebx\njne    90 <func0+0x90>\nmovb   $0x30,0x3e(%rax)\nmov    $0x5,%edi\nmov    $0x3c,%r13d\nmov    $0x3d,%eax\nadd    %rbp,%r13\nmovb   $0x62,0x0(%rbp,%rax,1)\nmovb   $0x64,0x0(%r13)\ncallq  54 <func0+0x54>\nmov    %rax,%r12\ntest   %rax,%rax\nje     73 <func0+0x73>\nmov    %r13,%rsi\nmov    %rax,%rdi\ncallq  67 <func0+0x67>\nmov    $0x6264,%edx\nmov    %dx,(%rax)\nmovb   $0x0,0x2(%rax)\nmov    %rbp,%rdi\ncallq  7b <func0+0x7b>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopl   0x0(%rax)\nmov    $0x3d,%eax\njle    d0 <func0+0xd0>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %ebx,%edx\nmov    %eax,%ecx\nand    $0x1,%edx\nadd    $0x30,%edx\nmov    %dl,0x1(%rbp,%rax,1)\nsub    $0x1,%rax\nsar    %ebx\njne    a0 <func0+0xa0>\nmovslq %ecx,%rax\nmov    $0x41,%edi\nsub    $0x1,%ecx\nsub    %ecx,%edi\nmovslq %ecx,%r13\nmovslq %edi,%rdi\njmpq   42 <func0+0x42>\nxchg   %ax,%ax\nmov    $0x4,%edi\nmov    $0x3d,%r13d\nmov    $0x3e,%eax\njmpq   42 <func0+0x42>\nxor    %r12d,%r12d\njmp    7b <func0+0x7b>"
    },
    {
        "task_id": 80,
        "type": "O0",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  1d <func0+0x1d>\ncmp    $0x2,%rax\nja     2a <func0+0x2a>\nmov    $0x0,%eax\njmp    a8 <func0+0xa8>\nmovl   $0x2,-0x14(%rbp)\njmp    8c <func0+0x8c>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x14(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     81 <func0+0x81>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x14(%rbp),%eax\ncltq\nlea    -0x2(%rax),%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    88 <func0+0x88>\nmov    $0x0,%eax\njmp    a8 <func0+0xa8>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  9e <func0+0x9e>\ncmp    %rax,%rbx\njb     33 <func0+0x33>\nmov    $0x1,%eax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 80,
        "type": "O1",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%rdx\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nsub    $0x1,%rcx\ncmp    $0x2,%rcx\njbe    51 <func0+0x51>\nmov    %rdx,%rax\nlea    -0x2(%rdx,%rcx,1),%rcx\nmovzbl 0x2(%rax),%edx\ncmp    0x1(%rax),%dl\nje     46 <func0+0x46>\ncmp    (%rax),%dl\nje     4c <func0+0x4c>\nadd    $0x1,%rax\ncmp    %rcx,%rax\njne    2a <func0+0x2a>\nmov    $0x1,%eax\nretq\nmov    $0x0,%eax\nretq\nmov    $0x0,%eax\nretq"
    },
    {
        "task_id": 80,
        "type": "O2",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncallq  d <func0+0xd>\nxor    %r8d,%r8d\ncmp    $0x2,%rax\njbe    39 <func0+0x39>\nmov    %rbx,%rdi\nlea    -0x2(%rbx,%rax,1),%rdx\njmp    2d <func0+0x2d>\ncmp    (%rdi),%al\nje     36 <func0+0x36>\nadd    $0x1,%rdi\ncmp    %rdx,%rdi\nje     40 <func0+0x40>\nmovzbl 0x2(%rdi),%eax\ncmp    0x1(%rdi),%al\njne    20 <func0+0x20>\nxor    %r8d,%r8d\nmov    %r8d,%eax\npop    %rbx\nretq\nxchg   %ax,%ax\nmov    $0x1,%r8d\npop    %rbx\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 80,
        "type": "O3",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncallq  d <func0+0xd>\nxor    %r8d,%r8d\ncmp    $0x2,%rax\njbe    39 <func0+0x39>\nmov    %rbx,%rdi\nlea    -0x2(%rbx,%rax,1),%rdx\njmp    2d <func0+0x2d>\ncmp    (%rdi),%al\nje     36 <func0+0x36>\nadd    $0x1,%rdi\ncmp    %rdx,%rdi\nje     40 <func0+0x40>\nmovzbl 0x2(%rdi),%eax\ncmp    0x1(%rdi),%al\njne    20 <func0+0x20>\nxor    %r8d,%r8d\nmov    %r8d,%eax\npop    %rbx\nretq\nxchg   %ax,%ax\nmov    $0x1,%r8d\npop    %rbx\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 81,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncallq  24 <func0+0x24>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmpq   3bc <func0+0x3bc>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\njb     7d <func0+0x7d>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\njmpq   3b8 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\njbe    c6 <func0+0xc6>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\njmpq   3b8 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\njbe    10f <func0+0x10f>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\njmpq   3b8 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\njbe    158 <func0+0x158>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\njmpq   3b8 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\njbe    1a1 <func0+0x1a1>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\njmpq   3b8 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\njbe    1ea <func0+0x1ea>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\njmpq   3b8 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\njbe    233 <func0+0x233>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\njmpq   3b8 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\njbe    27c <func0+0x27c>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\njmpq   3b8 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\njbe    2c5 <func0+0x2c5>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\njmpq   3b8 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\njbe    30e <func0+0x30e>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\njmpq   3b8 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\njbe    354 <func0+0x354>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\njmp    3b8 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncomisd 0x0(%rip),%xmm0\n00\njbe    39a <func0+0x39a>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\njmp    3b8 <func0+0x3b8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x0(%rip),%rdx\nmov    %rdx,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     34 <func0+0x34>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 81,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nmov    %esi,%ebp\nmovslq %esi,%rdi\nshl    $0x3,%rdi\ncallq  1b <func0+0x1b>\ntest   %ebp,%ebp\njle    186 <func0+0x186>\nlea    -0x1(%rbp),%esi\nmov    $0x0,%edx\nmovsd  0x0(%rip),%xmm1\n00\nmovsd  0x0(%rip),%xmm2\n00\nmovsd  0x0(%rip),%xmm3\n00\njmp    66 <func0+0x66>\ncomisd %xmm2,%xmm0\njbe    82 <func0+0x82>\nlea    0x0(%rip),%rcx\nmov    %rcx,(%rax,%rdx,8)\nlea    0x1(%rdx),%rcx\ncmp    %rsi,%rdx\nje     186 <func0+0x186>\nmov    %rcx,%rdx\npxor   %xmm0,%xmm0\ncvtss2sd (%rbx,%rdx,4),%xmm0\ncomisd %xmm1,%xmm0\njb     45 <func0+0x45>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmp    56 <func0+0x56>\ncomisd %xmm3,%xmm0\njbe    95 <func0+0x95>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmp    56 <func0+0x56>\ncomisd 0x0(%rip),%xmm0\n00\njbe    ac <func0+0xac>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmp    56 <func0+0x56>\ncomisd 0x0(%rip),%xmm0\n00\njbe    c3 <func0+0xc3>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmp    56 <func0+0x56>\ncomisd 0x0(%rip),%xmm0\n00\njbe    dd <func0+0xdd>\nlea    0x0(%rip),%rcx\nmov    %rcx,(%rax,%rdx,8)\njmpq   56 <func0+0x56>\ncomisd 0x0(%rip),%xmm0\n00\njbe    f7 <func0+0xf7>\nlea    0x0(%rip),%rcx\nmov    %rcx,(%rax,%rdx,8)\njmpq   56 <func0+0x56>\ncomisd 0x0(%rip),%xmm0\n00\njbe    111 <func0+0x111>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   56 <func0+0x56>\ncomisd 0x0(%rip),%xmm0\n00\njbe    12b <func0+0x12b>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   56 <func0+0x56>\ncomisd 0x0(%rip),%xmm0\n00\njbe    145 <func0+0x145>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   56 <func0+0x56>\ncomisd 0x0(%rip),%xmm0\n00\njbe    15f <func0+0x15f>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   56 <func0+0x56>\nmovsd  0x0(%rip),%xmm4\n00\ncomisd %xmm4,%xmm0\nlea    0x0(%rip),%rcx\nlea    0x0(%rip),%rdi\ncmovbe %rdi,%rcx\nmov    %rcx,(%rax,%rdx,8)\njmpq   56 <func0+0x56>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 81,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%rbp\nshl    $0x3,%rdi\nsub    $0x8,%rsp\ncallq  1c <func0+0x1c>\ntest   %ebp,%ebp\njle    80 <func0+0x80>\nmovsd  0x0(%rip),%xmm1\n00\nmovsd  0x0(%rip),%xmm2\n00\nlea    -0x1(%rbp),%esi\nxor    %edx,%edx\nmovsd  0x0(%rip),%xmm3\n00\njmp    57 <func0+0x57>\nnop\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\nlea    0x1(%rdx),%rcx\ncmp    %rdx,%rsi\nje     80 <func0+0x80>\nmov    %rcx,%rdx\npxor   %xmm0,%xmm0\ncvtss2sd (%rbx,%rdx,4),%xmm0\ncomisd %xmm1,%xmm0\njae    40 <func0+0x40>\ncomisd %xmm2,%xmm0\njbe    90 <func0+0x90>\nlea    0x0(%rip),%rcx\nmov    %rcx,(%rax,%rdx,8)\nlea    0x1(%rdx),%rcx\ncmp    %rdx,%rsi\njne    54 <func0+0x54>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\ncomisd %xmm3,%xmm0\njbe    a8 <func0+0xa8>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmp    4b <func0+0x4b>\nnopl   0x0(%rax,%rax,1)\ncomisd 0x0(%rip),%xmm0\n00\njbe    c0 <func0+0xc0>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmp    4b <func0+0x4b>\nnop\ncomisd 0x0(%rip),%xmm0\n00\njbe    e0 <func0+0xe0>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\nnopw   0x0(%rax,%rax,1)\ncomisd 0x0(%rip),%xmm0\n00\nja     108 <func0+0x108>\ncomisd 0x0(%rip),%xmm0\n00\njbe    118 <func0+0x118>\nlea    0x0(%rip),%rcx\nmov    %rcx,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\nnopl   0x0(%rax)\nlea    0x0(%rip),%rcx\nmov    %rcx,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\ncomisd 0x0(%rip),%xmm0\n00\nja     13c <func0+0x13c>\ncomisd 0x0(%rip),%xmm0\n00\njbe    14c <func0+0x14c>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\ncomisd 0x0(%rip),%xmm0\n00\njbe    166 <func0+0x166>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\ncomisd 0x0(%rip),%xmm0\n00\njbe    180 <func0+0x180>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\nmovsd  0x0(%rip),%xmm4\n00\nlea    0x0(%rip),%rcx\nlea    0x0(%rip),%rdi\ncomisd %xmm4,%xmm0\ncmovbe %rdi,%rcx\nmov    %rcx,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>"
    },
    {
        "task_id": 81,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%rbp\nshl    $0x3,%rdi\nsub    $0x8,%rsp\ncallq  1c <func0+0x1c>\ntest   %ebp,%ebp\njle    80 <func0+0x80>\nmovsd  0x0(%rip),%xmm1\n00\nmovsd  0x0(%rip),%xmm2\n00\nlea    -0x1(%rbp),%esi\nxor    %edx,%edx\nmovsd  0x0(%rip),%xmm3\n00\njmp    57 <func0+0x57>\nnop\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\nlea    0x1(%rdx),%rcx\ncmp    %rdx,%rsi\nje     80 <func0+0x80>\nmov    %rcx,%rdx\npxor   %xmm0,%xmm0\ncvtss2sd (%rbx,%rdx,4),%xmm0\ncomisd %xmm1,%xmm0\njae    40 <func0+0x40>\ncomisd %xmm2,%xmm0\njbe    90 <func0+0x90>\nlea    0x0(%rip),%rcx\nmov    %rcx,(%rax,%rdx,8)\nlea    0x1(%rdx),%rcx\ncmp    %rdx,%rsi\njne    54 <func0+0x54>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\ncomisd %xmm3,%xmm0\njbe    a8 <func0+0xa8>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmp    4b <func0+0x4b>\nnopl   0x0(%rax,%rax,1)\ncomisd 0x0(%rip),%xmm0\n00\njbe    c0 <func0+0xc0>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmp    4b <func0+0x4b>\nnop\ncomisd 0x0(%rip),%xmm0\n00\njbe    e0 <func0+0xe0>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\nnopw   0x0(%rax,%rax,1)\ncomisd 0x0(%rip),%xmm0\n00\nja     108 <func0+0x108>\ncomisd 0x0(%rip),%xmm0\n00\njbe    118 <func0+0x118>\nlea    0x0(%rip),%rcx\nmov    %rcx,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\nnopl   0x0(%rax)\nlea    0x0(%rip),%rcx\nmov    %rcx,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\ncomisd 0x0(%rip),%xmm0\n00\nja     13c <func0+0x13c>\ncomisd 0x0(%rip),%xmm0\n00\njbe    14c <func0+0x14c>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\ncomisd 0x0(%rip),%xmm0\n00\njbe    166 <func0+0x166>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\ncomisd 0x0(%rip),%xmm0\n00\njbe    180 <func0+0x180>\nlea    0x0(%rip),%rdi\nmov    %rdi,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>\nmovsd  0x0(%rip),%xmm4\n00\nlea    0x0(%rip),%rcx\nlea    0x0(%rip),%rdi\ncomisd %xmm4,%xmm0\ncmovbe %rdi,%rcx\nmov    %rcx,(%rax,%rdx,8)\njmpq   4b <func0+0x4b>"
    },
    {
        "task_id": 82,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  1c <func0+0x1c>\nmov    %eax,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njg     2c <func0+0x2c>\nmov    $0x0,%eax\njmp    5d <func0+0x5d>\nmovl   $0x2,-0x8(%rbp)\njmp    4d <func0+0x4d>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    49 <func0+0x49>\nmov    $0x0,%eax\njmp    5d <func0+0x5d>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x4(%rbp)\njge    35 <func0+0x35>\nmov    $0x1,%eax\nleaveq\nretq"
    },
    {
        "task_id": 82,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nsub    $0x1,%rcx\nmov    %ecx,%esi\ncmp    $0x1,%ecx\njle    49 <func0+0x49>\ncmp    $0x3,%ecx\njle    50 <func0+0x50>\ntest   $0x1,%cl\nje     56 <func0+0x56>\nmov    $0x2,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njg     4a <func0+0x4a>\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    2f <func0+0x2f>\nmov    $0x0,%eax\nretq\nmov    $0x1,%eax\nretq\nmov    $0x1,%eax\nretq\nmov    $0x0,%eax\nretq"
    },
    {
        "task_id": 82,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x8,%rsp\ncallq  d <func0+0xd>\nxor    %r8d,%r8d\ncmp    $0x1,%eax\njle    4b <func0+0x4b>\ncmp    $0x3,%eax\njle    45 <func0+0x45>\ntest   $0x1,%al\nje     4b <func0+0x4b>\nmov    %eax,%esi\nmov    $0x2,%ecx\njmp    39 <func0+0x39>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     58 <func0+0x58>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njle    30 <func0+0x30>\nmov    $0x1,%r8d\nmov    %r8d,%eax\nadd    $0x8,%rsp\nretq\nnopl   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\nadd    $0x8,%rsp\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 82,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x8,%rsp\ncallq  d <func0+0xd>\nxor    %r8d,%r8d\ncmp    $0x1,%eax\njle    4b <func0+0x4b>\ncmp    $0x3,%eax\njle    45 <func0+0x45>\ntest   $0x1,%al\nje     4b <func0+0x4b>\nmov    %eax,%esi\nmov    $0x2,%ecx\njmp    39 <func0+0x39>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     58 <func0+0x58>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njle    30 <func0+0x30>\nmov    $0x1,%r8d\nmov    %r8d,%eax\nadd    $0x8,%rsp\nretq\nnopl   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\nadd    $0x8,%rsp\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 83,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     18 <func0+0x18>\nmov    $0x0,%eax\njmp    53 <func0+0x53>\ncmpl   $0x1,-0x14(%rbp)\njne    25 <func0+0x25>\nmov    $0x1,%eax\njmp    53 <func0+0x53>\nmovl   $0x12,-0x8(%rbp)\nmovl   $0x2,-0x4(%rbp)\njmp    48 <func0+0x48>\nmov    -0x8(%rbp),%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     35 <func0+0x35>\nmov    -0x8(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 83,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x0,%eax\ntest   %edi,%edi\njle    35 <func0+0x35>\nmov    %edi,%eax\ncmp    $0x1,%edi\nje     35 <func0+0x35>\ncmp    $0x2,%edi\njle    30 <func0+0x30>\nmov    $0x2,%edx\nmov    $0x12,%eax\nlea    (%rax,%rax,4),%eax\nadd    %eax,%eax\nadd    $0x1,%edx\ncmp    %edx,%edi\njne    23 <func0+0x23>\nretq\nmov    $0x12,%eax\nretq"
    },
    {
        "task_id": 83,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ntest   %edi,%edi\njle    3d <func0+0x3d>\nmov    $0x1,%eax\ncmp    $0x1,%edi\nje     3d <func0+0x3d>\ncmp    $0x2,%edi\nje     38 <func0+0x38>\nmov    $0x2,%edx\nmov    $0x12,%eax\nnopl   0x0(%rax,%rax,1)\nlea    (%rax,%rax,4),%eax\nadd    $0x1,%edx\nadd    %eax,%eax\ncmp    %edx,%edi\njne    28 <func0+0x28>\nretq\nnopl   (%rax)\nmov    $0x12,%eax\nretq"
    },
    {
        "task_id": 83,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ntest   %edi,%edi\njle    3d <func0+0x3d>\nmov    $0x1,%eax\ncmp    $0x1,%edi\nje     3d <func0+0x3d>\ncmp    $0x2,%edi\nje     38 <func0+0x38>\nmov    $0x2,%edx\nmov    $0x12,%eax\nnopl   0x0(%rax,%rax,1)\nlea    (%rax,%rax,4),%eax\nadd    $0x1,%edx\nadd    %eax,%eax\ncmp    %edx,%edi\njne    28 <func0+0x28>\nretq\nnopl   (%rax)\nmov    $0x12,%eax\nretq"
    },
    {
        "task_id": 84,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %edi,-0x34(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x34(%rbp),%edx\nlea    -0xe(%rbp),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncallq  39 <func0+0x39>\nmovl   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    60 <func0+0x60>\nmov    -0x24(%rbp),%eax\ncltq\nmovzbl -0xe(%rbp,%rax,1),%eax\nmovsbl %al,%eax\nsub    $0x30,%eax\nadd    %eax,-0x28(%rbp)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nmovzbl -0xe(%rbp,%rax,1),%eax\ntest   %al,%al\njne    49 <func0+0x49>\nmov    $0x21,%edi\ncallq  78 <func0+0x78>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x20(%rbp)\ncmpl   $0x0,-0x28(%rbp)\njne    d8 <func0+0xd8>\nmov    -0x20(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x20(%rbp)\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\njmp    de <func0+0xde>\nmov    -0x28(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\nlea    0x30(%rax),%ecx\nmov    -0x20(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x20(%rbp)\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\nmov    -0x28(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x28(%rbp)\ncmpl   $0x0,-0x28(%rbp)\njg     a1 <func0+0xa1>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0x1c(%rbp)\njmp    14c <func0+0x14c>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x29(%rbp)\nmov    -0x20(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\nmov    -0x20(%rbp),%eax\nsub    -0x1c(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x29(%rbp),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x1c(%rbp)\njl     f7 <func0+0xf7>\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rsi\nxor    %fs:0x28,%rsi\n00 00\nje     175 <func0+0x175>\ncallq  175 <func0+0x175>\nleaveq\nretq"
    },
    {
        "task_id": 84,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nsub    $0x10,%rsp\nmov    %edi,%r8d\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nlea    0x2(%rsp),%rdi\nlea    0x0(%rip),%rcx\nmov    $0x6,%edx\nmov    $0x1,%esi\ncallq  37 <func0+0x37>\nmovzbl 0x2(%rsp),%eax\ntest   %al,%al\nje     100 <func0+0x100>\nlea    0x2(%rsp),%rdx\nmov    $0x0,%ebx\nmovsbl %al,%eax\nlea    -0x30(%rbx,%rax,1),%ebx\nadd    $0x1,%rdx\nmovzbl (%rdx),%eax\ntest   %al,%al\njne    4e <func0+0x4e>\nmov    $0x21,%edi\ncallq  6a <func0+0x6a>\ntest   %ebx,%ebx\nje     10a <func0+0x10a>\nmov    $0x1,%ecx\nmov    $0x0,%edx\njle    112 <func0+0x112>\nmov    %ecx,%edi\nmov    %ebx,%esi\nshr    $0x1f,%esi\nlea    (%rbx,%rsi,1),%edx\nand    $0x1,%edx\nsub    %esi,%edx\nadd    $0x30,%edx\nmov    %dl,-0x1(%rax,%rcx,1)\nmov    %ebx,%esi\nmov    %ebx,%edx\nshr    $0x1f,%edx\nadd    %edx,%ebx\nsar    %ebx\nadd    $0x1,%rcx\ncmp    $0x1,%esi\njg     82 <func0+0x82>\nmovslq %edi,%rdx\nmovb   $0x0,(%rax,%rdx,1)\nmov    %edi,%r8d\nshr    $0x1f,%r8d\nadd    %edi,%r8d\nsar    %r8d\ncmp    $0x1,%edi\njle    ea <func0+0xea>\nlea    -0x1(%rax,%rdx,1),%rcx\nmov    $0x0,%edx\nmovzbl (%rax,%rdx,1),%esi\nmovzbl (%rcx),%edi\nmov    %dil,(%rax,%rdx,1)\nmov    %sil,(%rcx)\nadd    $0x1,%rdx\nsub    $0x1,%rcx\ncmp    %edx,%r8d\njg     cf <func0+0xcf>\nmov    0x8(%rsp),%rdi\nxor    %fs:0x28,%rdi\n00 00\njne    11b <func0+0x11b>\nadd    $0x10,%rsp\npop    %rbx\nretq\nmov    $0x21,%edi\ncallq  10a <func0+0x10a>\nmovb   $0x30,(%rax)\nmov    $0x1,%edx\nmovslq %edx,%rdx\nmovb   $0x0,(%rax,%rdx,1)\njmp    ea <func0+0xea>\ncallq  120 <func0+0x120>"
    },
    {
        "task_id": 84,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%r8d\nlea    0x0(%rip),%rcx\nmov    $0x6,%edx\nmov    $0x1,%esi\nsub    $0x10,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nlea    0x2(%rsp),%rbx\nmov    %rbx,%rdi\ncallq  3a <func0+0x3a>\nmovsbl 0x2(%rsp),%eax\ntest   %al,%al\nje     f0 <func0+0xf0>\nmov    %rbx,%rdx\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nadd    $0x1,%rdx\nlea    -0x30(%rbx,%rax,1),%ebx\nmovsbl (%rdx),%eax\ntest   %al,%al\njne    50 <func0+0x50>\nmov    $0x21,%edi\ncallq  69 <func0+0x69>\ntest   %ebx,%ebx\nje     fa <func0+0xfa>\nmov    $0x1,%edx\njle    106 <func0+0x106>\nnopl   0x0(%rax)\nmov    %ebx,%ecx\nmov    %edx,%esi\nand    $0x1,%ecx\nadd    $0x30,%ecx\nmov    %cl,-0x1(%rax,%rdx,1)\nadd    $0x1,%rdx\nsar    %ebx\njne    80 <func0+0x80>\nmovslq %esi,%rdi\nsar    %esi\nmovb   $0x0,(%rax,%rdi,1)\nje     d3 <func0+0xd3>\nlea    -0x2(%rax,%rdi,1),%r8\nsub    $0x1,%esi\nlea    -0x1(%rax,%rdi,1),%rdx\nmov    %rax,%rcx\nsub    %rsi,%r8\nnopl   0x0(%rax)\nmovzbl (%rcx),%esi\nmovzbl (%rdx),%edi\nsub    $0x1,%rdx\nadd    $0x1,%rcx\nmov    %dil,-0x1(%rcx)\nmov    %sil,0x1(%rdx)\ncmp    %rdx,%r8\njne    b8 <func0+0xb8>\nmov    0x8(%rsp),%rbx\nxor    %fs:0x28,%rbx\n00 00\njne    10b <func0+0x10b>\nadd    $0x10,%rsp\npop    %rbx\nretq\nnopl   0x0(%rax)\nmov    $0x21,%edi\ncallq  fa <func0+0xfa>\nmovb   $0x30,(%rax)\nlea    0x1(%rax),%rdx\nmovb   $0x0,(%rdx)\njmp    d3 <func0+0xd3>\nmov    %rax,%rdx\njmp    101 <func0+0x101>\ncallq  110 <func0+0x110>"
    },
    {
        "task_id": 84,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%r8d\nlea    0x0(%rip),%rcx\nmov    $0x6,%edx\nmov    $0x1,%esi\nsub    $0x10,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nlea    0x2(%rsp),%rdi\ncallq  37 <func0+0x37>\nmovsbl 0x2(%rsp),%ebx\ntest   %bl,%bl\nje     110 <func0+0x110>\nmovsbl 0x3(%rsp),%eax\nsub    $0x30,%ebx\ntest   %al,%al\nje     7b <func0+0x7b>\nlea    -0x30(%rbx,%rax,1),%ebx\nmovsbl 0x4(%rsp),%eax\ntest   %al,%al\nje     7b <func0+0x7b>\nlea    -0x30(%rbx,%rax,1),%ebx\nmovsbl 0x5(%rsp),%eax\ntest   %al,%al\nje     7b <func0+0x7b>\nlea    -0x30(%rbx,%rax,1),%ebx\nmovsbl 0x6(%rsp),%eax\ntest   %al,%al\nje     7b <func0+0x7b>\nlea    -0x30(%rbx,%rax,1),%ebx\nmov    $0x21,%edi\ncallq  85 <func0+0x85>\ntest   %ebx,%ebx\nje     11a <func0+0x11a>\nmov    $0x1,%edx\njle    126 <func0+0x126>\nnopl   0x0(%rax,%rax,1)\n00\nmov    %ebx,%ecx\nmov    %edx,%esi\nand    $0x1,%ecx\nadd    $0x30,%ecx\nmov    %cl,-0x1(%rax,%rdx,1)\nadd    $0x1,%rdx\nsar    %ebx\njne    a0 <func0+0xa0>\nmovslq %esi,%rdi\nsar    %esi\nmovb   $0x0,(%rax,%rdi,1)\nje     f3 <func0+0xf3>\nlea    -0x2(%rax,%rdi,1),%r8\nsub    $0x1,%esi\nlea    -0x1(%rax,%rdi,1),%rdx\nmov    %rax,%rcx\nsub    %rsi,%r8\nnopl   0x0(%rax)\nmovzbl (%rcx),%esi\nmovzbl (%rdx),%edi\nsub    $0x1,%rdx\nadd    $0x1,%rcx\nmov    %dil,-0x1(%rcx)\nmov    %sil,0x1(%rdx)\ncmp    %r8,%rdx\njne    d8 <func0+0xd8>\nmov    0x8(%rsp),%rbx\nxor    %fs:0x28,%rbx\n00 00\njne    12b <func0+0x12b>\nadd    $0x10,%rsp\npop    %rbx\nretq\nnopl   0x0(%rax)\nmov    $0x21,%edi\ncallq  11a <func0+0x11a>\nmovb   $0x30,(%rax)\nlea    0x1(%rax),%rdx\nmovb   $0x0,(%rdx)\njmp    f3 <func0+0xf3>\nmov    %rax,%rdx\njmp    121 <func0+0x121>\ncallq  130 <func0+0x130>"
    },
    {
        "task_id": 85,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    65 <func0+0x65>\nmov    -0x4(%rbp),%eax\nadd    %eax,%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    61 <func0+0x61>\nmov    -0x4(%rbp),%eax\nadd    %eax,%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\ncmp    %eax,-0x1c(%rbp)\njg     1f <func0+0x1f>\nmov    -0x8(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 85,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    35 <func0+0x35>\nlea    0x4(%rdi),%rax\nsub    $0x2,%esi\nshr    %esi\nmov    %esi,%esi\nlea    0xc(%rdi,%rsi,8),%rdi\nmov    $0x0,%edx\nmov    (%rax),%ecx\nlea    (%rdx,%rcx,1),%esi\ntest   $0x1,%cl\ncmove  %esi,%edx\nadd    $0x8,%rax\ncmp    %rdi,%rax\njne    1e <func0+0x1e>\nmov    %edx,%eax\nretq\nmov    $0x0,%edx\njmp    32 <func0+0x32>"
    },
    {
        "task_id": 85,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    40 <func0+0x40>\nsub    $0x2,%esi\nlea    0x4(%rdi),%rax\nxor    %r8d,%r8d\nshr    %esi\nlea    0xc(%rdi,%rsi,8),%rsi\nnopw   0x0(%rax,%rax,1)\nmov    (%rax),%edx\nlea    (%r8,%rdx,1),%ecx\nand    $0x1,%edx\ncmove  %ecx,%r8d\nadd    $0x8,%rax\ncmp    %rsi,%rax\njne    20 <func0+0x20>\nmov    %r8d,%eax\nretq\nnopw   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 85,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    100 <func0+0x100>\nlea    -0x2(%rsi),%edx\ncmp    $0x7,%edx\njbe    103 <func0+0x103>\nshr    $0x3,%edx\npxor   %xmm2,%xmm2\nmovdqa 0x0(%rip),%xmm4\n00\nmov    %rdi,%rax\nmov    %edx,%ecx\nmovdqa %xmm2,%xmm3\nshl    $0x5,%rcx\nadd    %rdi,%rcx\nnopl   0x0(%rax,%rax,1)\n00\nmovdqu 0x4(%rax),%xmm1\nmovdqu 0x14(%rax),%xmm5\nadd    $0x20,%rax\nshufps $0x88,%xmm5,%xmm1\nmovdqa %xmm1,%xmm0\npand   %xmm4,%xmm0\npcmpeqd %xmm3,%xmm0\npand   %xmm1,%xmm0\npaddd  %xmm0,%xmm2\ncmp    %rcx,%rax\njne    40 <func0+0x40>\nmovdqa %xmm2,%xmm0\nlea    0x0(,%rdx,4),%ecx\nshl    $0x3,%edx\npsrldq $0x8,%xmm0\npaddd  %xmm0,%xmm2\nmovdqa %xmm2,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm2\nmovd   %xmm2,%eax\nmovslq %edx,%rdx\nmov    0x4(%rdi,%rdx,4),%edx\nlea    (%rax,%rdx,1),%r8d\nand    $0x1,%edx\nlea    0x2(%rcx,%rcx,1),%edx\nlea    0x1(%rdx),%ecx\ncmove  %r8d,%eax\ncmp    %ecx,%esi\njle    102 <func0+0x102>\nmovslq %edx,%rcx\nmov    0x4(%rdi,%rcx,4),%ecx\nlea    (%rax,%rcx,1),%r8d\nand    $0x1,%ecx\nlea    0x2(%rdx),%ecx\ncmove  %r8d,%eax\nlea    0x3(%rdx),%r8d\ncmp    %r8d,%esi\njle    102 <func0+0x102>\nmovslq %ecx,%rcx\nmov    0x4(%rdi,%rcx,4),%ecx\nlea    (%rax,%rcx,1),%r8d\nand    $0x1,%ecx\nlea    0x4(%rdx),%ecx\ncmove  %r8d,%eax\nadd    $0x5,%edx\ncmp    %edx,%esi\njle    102 <func0+0x102>\nmovslq %ecx,%rcx\nmov    0x4(%rdi,%rcx,4),%edx\nlea    (%rax,%rdx,1),%ecx\nand    $0x1,%edx\ncmove  %ecx,%eax\nretq\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nretq\nxor    %ecx,%ecx\nxor    %eax,%eax\nxor    %edx,%edx\njmp    93 <func0+0x93>"
    },
    {
        "task_id": 86,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x78(%rbp),%rax\nmov    %rax,%rdi\ncallq  2b <func0+0x2b>\nmov    %eax,-0x4c(%rbp)\nmov    -0x4c(%rbp),%eax\nadd    $0x2,%eax\ncltq\nmov    %rax,%rdi\ncallq  3e <func0+0x3e>\nmov    %rax,-0x48(%rbp)\nmovl   $0x0,-0x64(%rbp)\nmovl   $0x0,-0x60(%rbp)\nmovl   $0x0,-0x5c(%rbp)\njmpq   179 <func0+0x179>\nmov    -0x5c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     88 <func0+0x88>\nmov    -0x5c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    155 <func0+0x155>\nmovl   $0x0,-0x58(%rbp)\njmp    f1 <func0+0xf1>\nmov    -0x58(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x54(%rbp)\njmp    e5 <func0+0xe5>\nmov    -0x58(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%edx\nmov    -0x54(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\ncmp    %al,%dl\njle    e1 <func0+0xe1>\nmov    -0x58(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\nmov    %al,-0x65(%rbp)\nmov    -0x54(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%edx\nmov    -0x58(%rbp),%eax\ncltq\nmov    %dl,-0x40(%rbp,%rax,1)\nmov    -0x54(%rbp),%eax\ncltq\nmovzbl -0x65(%rbp),%edx\nmov    %dl,-0x40(%rbp,%rax,1)\naddl   $0x1,-0x54(%rbp)\nmov    -0x54(%rbp),%eax\ncmp    -0x60(%rbp),%eax\njl     9c <func0+0x9c>\naddl   $0x1,-0x58(%rbp)\nmov    -0x60(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x58(%rbp)\njl     91 <func0+0x91>\ncmpl   $0x0,-0x64(%rbp)\njle    118 <func0+0x118>\nmov    -0x64(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x64(%rbp)\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x20,(%rax)\nmovl   $0x0,-0x50(%rbp)\njmp    144 <func0+0x144>\nmov    -0x64(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x64(%rbp)\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x50(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x50(%rbp)\nmov    -0x50(%rbp),%eax\ncmp    -0x60(%rbp),%eax\njl     121 <func0+0x121>\nmovl   $0x0,-0x60(%rbp)\njmp    175 <func0+0x175>\nmov    -0x5c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x78(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x60(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x60(%rbp)\nmovzbl (%rcx),%edx\ncltq\nmov    %dl,-0x40(%rbp,%rax,1)\naddl   $0x1,-0x5c(%rbp)\nmov    -0x5c(%rbp),%eax\ncmp    -0x4c(%rbp),%eax\njle    5c <func0+0x5c>\nmov    -0x64(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x48(%rbp),%rax\nmov    -0x8(%rbp),%rsi\nxor    %fs:0x28,%rsi\n00 00\nje     1ad <func0+0x1ad>\ncallq  1ad <func0+0x1ad>\nleaveq\nretq"
    },
    {
        "task_id": 86,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,%rbx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nmov    $0xffffffffffffffff,%rcx\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%rbp\nlea    0x1(%rcx),%edi\nmovslq %edi,%rdi\ncallq  40 <func0+0x40>\nmov    %rax,%r11\ntest   %ebp,%ebp\njs     12b <func0+0x12b>\nmov    %rbx,%r10\nmov    %ebp,%ebp\nlea    0x1(%rbx,%rbp,1),%rbp\nmov    $0x0,%r9d\nmov    $0x0,%ebx\nmov    $0x0,%r12d\nmov    %rsp,%r13\njmpq   10e <func0+0x10e>\ncmp    $0x1,%r9d\njle    c3 <func0+0xc3>\nmov    %rsp,%rsi\nlea    -0x1(%r9),%r15d\nmov    %r15d,%r14d\nmov    $0x0,%r8d\njmp    aa <func0+0xaa>\nadd    $0x1,%rax\ncmp    %rdi,%rax\nje     a1 <func0+0xa1>\nmovzbl (%rsi),%edx\nmovzbl 0x1(%rax),%ecx\ncmp    %cl,%dl\njle    86 <func0+0x86>\nmov    %cl,(%rsi)\nmov    %dl,0x1(%rax)\njmp    86 <func0+0x86>\nadd    $0x1,%rsi\ncmp    %r14d,%r8d\nje     c3 <func0+0xc3>\nadd    $0x1,%r8d\ncmp    %r9d,%r8d\njge    a1 <func0+0xa1>\nmov    %r15d,%eax\nsub    %r8d,%eax\nlea    0x1(%rsi,%rax,1),%rdi\nmov    %rsi,%rax\njmp    8f <func0+0x8f>\ntest   %ebx,%ebx\njle    d2 <func0+0xd2>\nmovslq %ebx,%rax\nmovb   $0x20,(%r11,%rax,1)\nlea    0x1(%rbx),%ebx\ntest   %r9d,%r9d\njle    126 <func0+0x126>\nmovslq %ebx,%rdx\nmov    %r9d,%edi\nlea    -0x1(%r9),%eax\nlea    0x1(%rdx,%rax,1),%rsi\nmov    %rdx,%rax\nmov    %r13,%rcx\nsub    %rdx,%rcx\nmovzbl (%rcx,%rax,1),%edx\nmov    %dl,(%r11,%rax,1)\nadd    $0x1,%rax\ncmp    %rax,%rsi\njne    ef <func0+0xef>\nadd    %edi,%ebx\nmov    %r12d,%r9d\nadd    $0x1,%r10\ncmp    %rbp,%r10\nje     130 <func0+0x130>\nmovzbl (%r10),%eax\ntest   $0xdf,%al\nje     6e <func0+0x6e>\nmovslq %r9d,%rdx\nmov    %al,(%rsp,%rdx,1)\nlea    0x1(%r9),%r9d\njmp    105 <func0+0x105>\nmov    %r12d,%r9d\njmp    105 <func0+0x105>\nmov    $0x0,%ebx\nmovslq %ebx,%rbx\nmovb   $0x0,(%r11,%rbx,1)\nmov    0x38(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    15a <func0+0x15a>\nmov    %r11,%rax\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\ncallq  15f <func0+0x15f>"
    },
    {
        "task_id": 86,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\ncallq  28 <func0+0x28>\nlea    0x2(%rax),%edi\nmov    %rax,%rbx\nmovslq %edi,%rdi\ncallq  36 <func0+0x36>\nmov    %rax,%r10\ntest   %ebx,%ebx\njs     12a <func0+0x12a>\nmov    %ebx,%ebx\nmov    %rbp,%r9\nxor    %r8d,%r8d\nxor    %r11d,%r11d\nlea    0x1(%rbp,%rbx,1),%rbx\nmov    %rsp,%rbp\njmp    77 <func0+0x77>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmovslq %r8d,%rdx\nadd    $0x1,%r8d\nmov    %al,(%rsp,%rdx,1)\nadd    $0x1,%r9\ncmp    %rbx,%r9\nje     124 <func0+0x124>\nmovzbl (%r9),%eax\ntest   $0xdf,%al\njne    60 <func0+0x60>\nmov    %rbp,%rsi\nlea    -0x1(%r8),%r14d\nxor    %r12d,%r12d\ncmp    $0x1,%r8d\njle    d1 <func0+0xd1>\nnop\nadd    $0x1,%r12d\nlea    0x1(%rsi),%r13\ncmp    %r8d,%r12d\njge    c9 <func0+0xc9>\nmov    %r14d,%edi\nmov    %rsi,%rax\nsub    %r12d,%edi\nadd    %r13,%rdi\nnopl   0x0(%rax)\nmovzbl (%rsi),%edx\nmovzbl 0x1(%rax),%ecx\ncmp    %cl,%dl\njle    c0 <func0+0xc0>\nmov    %cl,(%rsi)\nmov    %dl,0x1(%rax)\nadd    $0x1,%rax\ncmp    %rdi,%rax\njne    b0 <func0+0xb0>\nmov    %r13,%rsi\ncmp    %r14d,%r12d\njne    90 <func0+0x90>\ntest   %r11d,%r11d\nje     e2 <func0+0xe2>\nmovslq %r11d,%rax\nadd    $0x1,%r11d\nmovb   $0x20,(%r10,%rax,1)\ntest   %r8d,%r8d\nje     6a <func0+0x6a>\nmovslq %r11d,%rax\nlea    -0x1(%r8),%edx\nmov    %rbp,%rcx\nlea    0x1(%rax,%rdx,1),%rsi\nsub    %rax,%rcx\nnopl   0x0(%rax)\nmovzbl (%rcx,%rax,1),%edx\nmov    %dl,(%r10,%rax,1)\nadd    $0x1,%rax\ncmp    %rax,%rsi\njne    100 <func0+0x100>\nadd    $0x1,%r9\nadd    %r8d,%r11d\nxor    %r8d,%r8d\ncmp    %rbx,%r9\njne    77 <func0+0x77>\nmovslq %r11d,%rax\nadd    %r10,%rax\nmovb   $0x0,(%rax)\nmov    0x38(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    14d <func0+0x14d>\nadd    $0x40,%rsp\nmov    %r10,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\ncallq  152 <func0+0x152>"
    },
    {
        "task_id": 86,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\ncallq  2a <func0+0x2a>\nlea    0x2(%rax),%edi\nmov    %rax,%rbx\nmovslq %edi,%rdi\ncallq  38 <func0+0x38>\nmov    %rax,%r14\ntest   %ebx,%ebx\njs     10b <func0+0x10b>\nmov    %ebx,%ebx\nxor    %r12d,%r12d\nmov    %rsp,%r15\nlea    0x1(%rbp,%rbx,1),%r13\nxor    %ebx,%ebx\njmp    6e <func0+0x6e>\nnopl   0x0(%rax)\nmovslq %ebx,%rdx\nadd    $0x1,%ebx\nmov    %al,(%rsp,%rdx,1)\nadd    $0x1,%rbp\ncmp    %r13,%rbp\nje     105 <func0+0x105>\nmovzbl 0x0(%rbp),%eax\ntest   $0xdf,%al\njne    58 <func0+0x58>\nmov    %r15,%rsi\nlea    -0x1(%rbx),%r10d\nxor    %r8d,%r8d\ncmp    $0x1,%ebx\njle    c9 <func0+0xc9>\nnopl   (%rax)\nadd    $0x1,%r8d\ncmp    %ebx,%r8d\njge    130 <func0+0x130>\nmov    %r10d,%edi\nlea    0x1(%rsi),%r9\nmov    %rsi,%rax\nsub    %r8d,%edi\nadd    %r9,%rdi\nnopl   (%rax)\nmovzbl (%rsi),%edx\nmovzbl 0x1(%rax),%ecx\ncmp    %cl,%dl\njle    b8 <func0+0xb8>\nmov    %cl,(%rsi)\nmov    %dl,0x1(%rax)\nadd    $0x1,%rax\ncmp    %rax,%rdi\njne    a8 <func0+0xa8>\nmov    %r9,%rsi\ncmp    %r8d,%r10d\njne    88 <func0+0x88>\ntest   %r12d,%r12d\nje     da <func0+0xda>\nmovslq %r12d,%rax\nadd    $0x1,%r12d\nmovb   $0x20,(%r14,%rax,1)\ntest   %ebx,%ebx\nje     61 <func0+0x61>\nmovslq %r12d,%rdi\nlea    -0x1(%rbx),%edx\nmov    %r15,%rsi\nadd    $0x1,%rbp\nadd    %r14,%rdi\nadd    $0x1,%rdx\nadd    %ebx,%r12d\nxor    %ebx,%ebx\ncallq  fc <func0+0xfc>\ncmp    %r13,%rbp\njne    6e <func0+0x6e>\nmovslq %r12d,%rax\nadd    %r14,%rax\nmovb   $0x0,(%rax)\nmov    0x38(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    142 <func0+0x142>\nadd    $0x48,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nlea    0x1(%rsi),%r9\nmov    %r9,%rsi\ncmp    %r8d,%r10d\njne    88 <func0+0x88>\njmp    c9 <func0+0xc9>\ncallq  147 <func0+0x147>"
    },
    {
        "task_id": 87,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(int[]){1,2,3,4,5,6}, (int[]){1,2,3,4,1,6}, (int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(int[]){0, 0}, (int[]){1, 4}, (int[]){1, 0}, (int[]){2, 5}, (int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %ecx,-0x40(%rbp)\nmov    %r8,-0x50(%rbp)\nmov    $0x320,%edi\ncallq  29 <func0+0x29>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmpq   100 <func0+0x100>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nsub    $0x1,%eax\nmov    %eax,-0x1c(%rbp)\njmpq   f2 <func0+0xf2>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x40(%rbp)\njne    ee <func0+0xee>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    $0x8,%edi\ncallq  ab <func0+0xab>\nmov    %rax,(%rbx)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x20(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x4(%rax),%rdx\nmov    -0x1c(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x24(%rbp)\nsubl   $0x1,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njns    61 <func0+0x61>\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     40 <func0+0x40>\nmov    -0x50(%rbp),%rax\nmov    -0x24(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 87,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(int[]){1,2,3,4,5,6}, (int[]){1,2,3,4,1,6}, (int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(int[]){0, 0}, (int[]){1, 4}, (int[]){1, 0}, (int[]){2, 5}, (int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,%r12\nmov    %esi,%ebx\nmov    %rdx,0x18(%rsp)\nmov    %ecx,%r13d\nmov    %r8,0x28(%rsp)\nmov    $0x320,%edi\ncallq  2e <func0+0x2e>\nmov    %rax,0x10(%rsp)\ntest   %ebx,%ebx\njle    c0 <func0+0xc0>\nlea    -0x1(%rbx),%eax\nmov    %rax,0x20(%rsp)\nmov    $0x0,%r15d\nmov    $0x0,%r14d\njmp    9e <func0+0x9e>\nmov    $0x8,%edi\ncallq  5b <func0+0x5b>\nmovslq %r14d,%rdx\nmov    0x10(%rsp),%rcx\nmov    %rax,(%rcx,%rdx,8)\nmov    0x8(%rsp),%esi\nmov    %esi,(%rax)\nmov    %ebx,0x4(%rax)\nadd    $0x1,%r14d\nsub    $0x1,%ebx\nsub    $0x4,%rbp\ncmp    $0xffffffff,%ebx\nje     8c <func0+0x8c>\nmov    (%r12),%rax\ncmp    %r13d,(%rax,%rbp,1)\njne    74 <func0+0x74>\njmp    51 <func0+0x51>\nlea    0x1(%r15),%rax\nadd    $0x8,%r12\ncmp    0x20(%rsp),%r15\nje     c6 <func0+0xc6>\nmov    %rax,%r15\nmov    %r15d,0x8(%rsp)\nmov    0x18(%rsp),%rax\nmov    (%rax,%r15,4),%eax\nmov    %eax,0xc(%rsp)\nmov    %eax,%ebx\nsub    $0x1,%ebx\njs     8c <func0+0x8c>\nmovslq %ebx,%rbp\nshl    $0x2,%rbp\njmp    80 <func0+0x80>\nmov    $0x0,%r14d\nmov    0x28(%rsp),%rax\nmov    %r14d,(%rax)\nmov    0x10(%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 87,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(int[]){1,2,3,4,5,6}, (int[]){1,2,3,4,1,6}, (int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(int[]){0, 0}, (int[]){1, 4}, (int[]){1, 0}, (int[]){2, 5}, (int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %ecx,%r13d\npush   %r12\npush   %rbp\npush   %rbx\nmov    %esi,%ebx\nsub    $0x38,%rsp\nmov    %rdi,0x20(%rsp)\nmov    $0x320,%edi\nmov    %rdx,0x10(%rsp)\nmov    %r8,0x28(%rsp)\ncallq  30 <func0+0x30>\nmov    %rax,0x8(%rsp)\ntest   %ebx,%ebx\njle    c8 <func0+0xc8>\nlea    -0x1(%rbx),%eax\nxor    %r14d,%r14d\nxor    %r15d,%r15d\nmov    %rax,0x18(%rsp)\nnopl   0x0(%rax,%rax,1)\nmov    0x10(%rsp),%rax\nmov    %r14d,%ebx\nmov    (%rax,%r14,4),%eax\nmov    %eax,%edx\nmov    %eax,0x4(%rsp)\nsub    $0x1,%edx\njs     b8 <func0+0xb8>\nmov    0x20(%rsp),%rax\nmovslq %edx,%r12\nmov    (%rax,%r14,8),%rbp\njmp    81 <func0+0x81>\nnopl   (%rax)\nsub    $0x1,%r12\ntest   %r12d,%r12d\njs     b8 <func0+0xb8>\ncmp    %r13d,0x0(%rbp,%r12,4)\njne    78 <func0+0x78>\nmov    $0x8,%edi\ncallq  92 <func0+0x92>\nmov    0x8(%rsp),%rcx\nmovslq %r15d,%rdi\nadd    $0x1,%r15d\nmov    %r12d,0x4(%rax)\nsub    $0x1,%r12\nmov    %rax,(%rcx,%rdi,8)\nmov    %ebx,(%rax)\ntest   %r12d,%r12d\njns    81 <func0+0x81>\nnopl   0x0(%rax)\nlea    0x1(%r14),%rax\ncmp    %r14,0x18(%rsp)\nje     cb <func0+0xcb>\nmov    %rax,%r14\njmp    50 <func0+0x50>\nxor    %r15d,%r15d\nmov    0x28(%rsp),%rax\nmov    %r15d,(%rax)\nmov    0x8(%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 87,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(int[]){1,2,3,4,5,6}, (int[]){1,2,3,4,1,6}, (int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(int[]){0, 0}, (int[]){1, 4}, (int[]){1, 0}, (int[]){2, 5}, (int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %ecx,%r13d\npush   %r12\npush   %rbp\npush   %rbx\nmov    %esi,%ebx\nsub    $0x38,%rsp\nmov    %rdi,0x20(%rsp)\nmov    $0x320,%edi\nmov    %rdx,0x10(%rsp)\nmov    %r8,0x28(%rsp)\ncallq  30 <func0+0x30>\nmov    %rax,0x8(%rsp)\ntest   %ebx,%ebx\njle    c8 <func0+0xc8>\nlea    -0x1(%rbx),%eax\nxor    %r14d,%r14d\nxor    %r15d,%r15d\nmov    %rax,0x18(%rsp)\nnopl   0x0(%rax,%rax,1)\nmov    0x10(%rsp),%rax\nmov    %r14d,%ebx\nmov    (%rax,%r14,4),%eax\nmov    %eax,%edx\nmov    %eax,0x4(%rsp)\nsub    $0x1,%edx\njs     b8 <func0+0xb8>\nmov    0x20(%rsp),%rax\nmovslq %edx,%r12\nmov    (%rax,%r14,8),%rbp\njmp    81 <func0+0x81>\nnopl   (%rax)\nsub    $0x1,%r12\ntest   %r12d,%r12d\njs     b8 <func0+0xb8>\ncmp    %r13d,0x0(%rbp,%r12,4)\njne    78 <func0+0x78>\nmov    $0x8,%edi\ncallq  92 <func0+0x92>\nmov    0x8(%rsp),%rcx\nmovslq %r15d,%rdi\nadd    $0x1,%r15d\nmov    %r12d,0x4(%rax)\nsub    $0x1,%r12\nmov    %rax,(%rcx,%rdi,8)\nmov    %ebx,(%rax)\ntest   %r12d,%r12d\njns    81 <func0+0x81>\nnopl   0x0(%rax)\nlea    0x1(%r14),%rax\ncmp    %r14,0x18(%rsp)\nje     cb <func0+0xcb>\nmov    %rax,%r14\njmp    50 <func0+0x50>\nxor    %r15d,%r15d\nmov    0x28(%rsp),%rax\nmov    %r15d,(%rax)\nmov    0x8(%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 88,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (int[]){}, 0));\n    free(result);\n\n    func0((int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (int[]){5}, 1));\n    free(result);\n\n    func0((int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (int[]){1, 2}, 2));\n    free(result);\n\n    func0((int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %rcx,-0x40(%rbp)\nmov    -0x40(%rbp),%rax\nmov    -0x2c(%rbp),%edx\nmov    %edx,(%rax)\ncmpl   $0x0,-0x2c(%rbp)\njne    3a <func0+0x3a>\nmov    -0x38(%rbp),%rax\nmovq   $0x0,(%rax)\njmpq   256 <func0+0x256>\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  4b <func0+0x4b>\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    6b <func0+0x6b>\nmov    $0x1,%edi\ncallq  6b <func0+0x6b>\nmovl   $0x0,-0x18(%rbp)\njmp    a5 <func0+0xa5>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     74 <func0+0x74>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nadd    %eax,%edx\nmov    %edx,%eax\nsar    $0x1f,%eax\nshr    $0x1f,%eax\nadd    %eax,%edx\nand    $0x1,%edx\nsub    %eax,%edx\nmov    %edx,%eax\ncmp    $0x1,%eax\nsete   %al\nmovzbl %al,%eax\nmov    %eax,-0xc(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmpq   247 <func0+0x247>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x10(%rbp)\njmpq   237 <func0+0x237>\ncmpl   $0x0,-0xc(%rbp)\nje     1a4 <func0+0x1a4>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%ecx\nmovslq %ecx,%rcx\nshl    $0x2,%rcx\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    233 <func0+0x233>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nlea    (%rax,%rdx,1),%rcx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\njmpq   233 <func0+0x233>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%ecx\nmovslq %ecx,%rcx\nshl    $0x2,%rcx\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    233 <func0+0x233>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nlea    (%rax,%rdx,1),%rcx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     102 <func0+0x102>\naddl   $0x1,-0x14(%rbp)\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x14(%rbp)\njl     f4 <func0+0xf4>\nleaveq\nretq"
    },
    {
        "task_id": 88,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (int[]){}, 0));\n    free(result);\n\n    func0((int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (int[]){5}, 1));\n    free(result);\n\n    func0((int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (int[]){1, 2}, 2));\n    free(result);\n\n    func0((int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdx,%rbx\nmov    %esi,(%rcx)\ntest   %esi,%esi\njne    29 <func0+0x29>\nmovq   $0x0,(%rdx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nmov    %rdi,%r12\nmov    %esi,%ebp\nmovslq %esi,%r13\nshl    $0x2,%r13\nmov    %r13,%rdi\ncallq  3d <func0+0x3d>\nmov    %rax,(%rbx)\ntest   %rax,%rax\nje     a4 <func0+0xa4>\ntest   %ebp,%ebp\njle    6c <func0+0x6c>\nlea    -0x1(%rbp),%eax\nlea    0x4(,%rax,4),%rsi\n00\nmov    $0x0,%eax\nmov    (%r12,%rax,1),%ecx\nmov    (%rbx),%rdx\nmov    %ecx,(%rdx,%rax,1)\nadd    $0x4,%rax\ncmp    %rsi,%rax\njne    59 <func0+0x59>\nmov    (%r12),%eax\nadd    -0x4(%r12,%r13,1),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nlea    (%rax,%rdx,1),%r9d\nand    $0x1,%r9d\nsub    %edx,%r9d\ncmp    $0x1,%ebp\njle    1e <func0+0x1e>\nlea    -0x1(%rbp),%r13d\nmov    %r13d,%r12d\nmov    $0x0,%edi\nmov    $0x0,%r11d\nmov    $0x0,%r10d\njmp    100 <func0+0x100>\nmov    $0x1,%edi\ncallq  ae <func0+0xae>\nmov    (%rbx),%rdx\nlea    (%rdx,%rdi,1),%rsi\nmov    (%rsi),%ecx\nmov    (%rdx,%rax,1),%edx\ncmp    %edx,%ecx\njle    c6 <func0+0xc6>\nmov    %edx,(%rsi)\nmov    (%rbx),%rdx\nmov    %ecx,(%rdx,%rax,1)\nadd    $0x4,%rax\ncmp    %r8,%rax\nje     ef <func0+0xef>\ncmp    $0x1,%r9d\nje     ae <func0+0xae>\nmov    (%rbx),%rdx\nlea    (%rdx,%rdi,1),%rsi\nmov    (%rsi),%ecx\nmov    (%rdx,%rax,1),%edx\ncmp    %edx,%ecx\njge    c6 <func0+0xc6>\nmov    %edx,(%rsi)\nmov    (%rbx),%rdx\nmov    %ecx,(%rdx,%rax,1)\njmp    c6 <func0+0xc6>\nadd    $0x1,%r11\nadd    $0x4,%rdi\ncmp    %r12d,%r10d\nje     1e <func0+0x1e>\nadd    $0x1,%r10d\ncmp    %r10d,%ebp\njle    ef <func0+0xef>\nlea    0x4(%rdi),%rax\nmov    %r13d,%edx\nsub    %r10d,%edx\nlea    0x2(%r11,%rdx,1),%r8\nshl    $0x2,%r8\njmp    cf <func0+0xcf>"
    },
    {
        "task_id": 88,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (int[]){}, 0));\n    free(result);\n\n    func0((int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (int[]){5}, 1));\n    free(result);\n\n    func0((int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (int[]){1, 2}, 2));\n    free(result);\n\n    func0((int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\nmov    %rdx,%r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %esi,(%rcx)\ntest   %esi,%esi\njne    30 <func0+0x30>\nmovq   $0x0,(%rdx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopl   0x0(%rax)\nmovslq %esi,%r13\nmov    %rdi,%rbp\nmov    %esi,%ebx\nshl    $0x2,%r13\nmov    %r13,%rdi\ncallq  44 <func0+0x44>\nmov    %rax,(%r12)\ntest   %rax,%rax\nje     f8 <func0+0xf8>\nlea    -0x1(%rbx),%esi\nxor    %edx,%edx\ntest   %ebx,%ebx\njle    73 <func0+0x73>\nnopw   0x0(%rax,%rax,1)\nmov    0x0(%rbp,%rdx,4),%ecx\nmov    %ecx,(%rax,%rdx,4)\nmov    %rdx,%rcx\nadd    $0x1,%rdx\ncmp    %rsi,%rcx\njne    60 <func0+0x60>\nmov    0x0(%rbp),%edx\nadd    -0x4(%rbp,%r13,1),%edx\nmov    %edx,%ecx\nshr    $0x1f,%ecx\nlea    (%rdx,%rcx,1),%esi\nand    $0x1,%esi\nsub    %ecx,%esi\ncmp    $0x1,%ebx\njle    1e <func0+0x1e>\nlea    -0x2(%rbx),%r10d\nmov    %rax,%r8\nmov    $0x1,%r9d\nadd    $0x2,%r10\nxchg   %ax,%ax\nmov    %r9,%rdx\ncmp    %r9d,%ebx\njg     c2 <func0+0xc2>\njmp    e0 <func0+0xe0>\nnopw   0x0(%rax,%rax,1)\ncmp    %edi,%ecx\njge    ba <func0+0xba>\nmov    %edi,(%r8)\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %edx,%ebx\njle    e0 <func0+0xe0>\nmov    (%r8),%ecx\nmov    (%rax,%rdx,4),%edi\ncmp    $0x1,%esi\njne    b0 <func0+0xb0>\ncmp    %edi,%ecx\njg     b4 <func0+0xb4>\nadd    $0x1,%rdx\ncmp    %edx,%ebx\njg     c2 <func0+0xc2>\nnopl   0x0(%rax)\nadd    $0x1,%r9\nadd    $0x4,%r8\ncmp    %r9,%r10\njne    a0 <func0+0xa0>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nmov    $0x1,%edi\ncallq  102 <func0+0x102>"
    },
    {
        "task_id": 88,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (int[]){}, 0));\n    free(result);\n\n    func0((int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (int[]){5}, 1));\n    free(result);\n\n    func0((int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (int[]){1, 2}, 2));\n    free(result);\n\n    func0((int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\nmov    %rdx,%r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %esi,(%rcx)\ntest   %esi,%esi\njne    30 <func0+0x30>\nmovq   $0x0,(%rdx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopl   0x0(%rax)\nmovslq %esi,%r13\nmov    %rdi,%rbp\nmov    %esi,%ebx\nshl    $0x2,%r13\nmov    %r13,%rdi\ncallq  44 <func0+0x44>\nmov    %rax,(%r12)\nmov    %rax,%rdi\ntest   %rax,%rax\nje     105 <func0+0x105>\ntest   %ebx,%ebx\njle    6e <func0+0x6e>\nlea    -0x1(%rbx),%eax\nmov    %rbp,%rsi\nlea    0x4(,%rax,4),%rdx\n00\ncallq  6b <func0+0x6b>\nmov    %rax,%rdi\nmov    0x0(%rbp),%eax\nadd    -0x4(%rbp,%r13,1),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nlea    (%rax,%rdx,1),%r9d\nand    $0x1,%r9d\nsub    %edx,%r9d\ncmp    $0x1,%ebx\njle    1e <func0+0x1e>\nlea    -0x2(%rbx),%r10d\nmov    %rdi,%rsi\nmov    $0x1,%r8d\nadd    $0x2,%r10\nnopl   0x0(%rax)\ncmp    %r8d,%ebx\njle    c6 <func0+0xc6>\nmov    %r8,%rax\ncmp    $0x1,%r9d\nje     e0 <func0+0xe0>\nxchg   %ax,%ax\nmov    (%rsi),%edx\nmov    (%rdi,%rax,4),%ecx\ncmp    %edx,%ecx\njle    be <func0+0xbe>\nmov    %ecx,(%rsi)\nmov    %edx,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    %eax,%ebx\njg     b0 <func0+0xb0>\nadd    $0x1,%r8\nadd    $0x4,%rsi\ncmp    %r8,%r10\njne    a0 <func0+0xa0>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nxchg   %ax,%ax\nmov    (%rsi),%edx\nmov    (%rdi,%rax,4),%ecx\ncmp    %ecx,%edx\njle    ee <func0+0xee>\nmov    %ecx,(%rsi)\nmov    %edx,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    %eax,%ebx\njg     e0 <func0+0xe0>\nadd    $0x1,%r8\nadd    $0x4,%rsi\ncmp    %r8,%r10\njne    a0 <func0+0xa0>\njmp    d3 <func0+0xd3>\nmov    $0x1,%edi\ncallq  10f <func0+0x10f>"
    },
    {
        "task_id": 89,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    6e <func0+0x6e>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nlea    -0x5d(%rax),%edx\nmovslq %edx,%rax\nimul   $0x4ec4ec4f,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%ecx\nsar    $0x3,%ecx\nmov    %edx,%eax\nsar    $0x1f,%eax\nsub    %eax,%ecx\nmov    %ecx,%eax\nimul   $0x1a,%eax,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nadd    $0x61,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x4(%rbp),%edx\nmov    %dl,(%rax)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    19 <func0+0x19>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 89,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     4a <func0+0x4a>\nmov    $0x0,%ecx\nmovsbl %al,%eax\nsub    $0x5d,%eax\nmovslq %eax,%rdx\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x23,%rdx\nmov    %eax,%r8d\nsar    $0x1f,%r8d\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%eax\nadd    $0x61,%eax\nmov    %al,(%rsi,%rcx,1)\nadd    $0x1,%rcx\nmovzbl (%rdi,%rcx,1),%eax\ntest   %al,%al\njne    10 <func0+0x10>\nmovb   $0x0,(%rsi,%rcx,1)\nretq\nmov    $0x0,%ecx\njmp    45 <func0+0x45>"
    },
    {
        "task_id": 89,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovsbl (%rdi),%eax\ntest   %al,%al\nje     45 <func0+0x45>\nxor    %ecx,%ecx\nnopl   (%rax)\nsub    $0x5d,%eax\nmovslq %eax,%rdx\nmov    %eax,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%eax\nadd    $0x61,%eax\nmov    %al,(%rsi,%rcx,1)\nadd    $0x1,%rcx\nmovsbl (%rdi,%rcx,1),%eax\ntest   %al,%al\njne    10 <func0+0x10>\nadd    %rcx,%rsi\nmovb   $0x0,(%rsi)\nretq"
    },
    {
        "task_id": 89,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovsbl (%rdi),%eax\ntest   %al,%al\nje     45 <func0+0x45>\nxor    %ecx,%ecx\nnopl   (%rax)\nsub    $0x5d,%eax\nmovslq %eax,%rdx\nmov    %eax,%r8d\nimul   $0x4ec4ec4f,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x23,%rdx\nsub    %r8d,%edx\nimul   $0x1a,%edx,%edx\nsub    %edx,%eax\nadd    $0x61,%eax\nmov    %al,(%rsi,%rcx,1)\nadd    $0x1,%rcx\nmovsbl (%rdi,%rcx,1),%eax\ntest   %al,%al\njne    10 <func0+0x10>\nadd    %rcx,%rsi\nmovb   $0x0,(%rsi)\nretq"
    },
    {
        "task_id": 90,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0x1,-0x1c(%rbp)\njg     1f <func0+0x1f>\nmov    $0xffffffff,%eax\njmpq   e7 <func0+0xe7>\nmovl   $0x7fffffff,-0xc(%rbp)\nmovl   $0x7fffffff,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmpq   c8 <func0+0xc8>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    75 <func0+0x75>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\njmp    c4 <func0+0xc4>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x8(%rbp)\njle    c4 <func0+0xc4>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\nje     c4 <func0+0xc4>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     39 <func0+0x39>\ncmpl   $0x7fffffff,-0x8(%rbp)\njne    e4 <func0+0xe4>\nmov    $0xffffffff,%eax\njmp    e7 <func0+0xe7>\nmov    -0x8(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 90,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    4e <func0+0x4e>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%edx\nlea    0x4(%rdi,%rdx,4),%rdi\nmov    $0x7fffffff,%esi\nmov    $0x7fffffff,%ecx\njmp    2d <func0+0x2d>\nmov    %ecx,%esi\nmov    %edx,%ecx\nadd    $0x4,%rax\ncmp    %rdi,%rax\nje     3c <func0+0x3c>\nmov    (%rax),%edx\ncmp    %ecx,%edx\njl     20 <func0+0x20>\nje     24 <func0+0x24>\ncmp    %esi,%edx\ncmovl  %edx,%esi\njmp    24 <func0+0x24>\ncmp    $0x7fffffff,%esi\nje     47 <func0+0x47>\nmov    %esi,%eax\nretq\nmov    $0xffffffff,%esi\njmp    44 <func0+0x44>\nmov    $0xffffffff,%esi\njmp    44 <func0+0x44>"
    },
    {
        "task_id": 90,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    53 <func0+0x53>\nlea    -0x1(%rsi),%eax\nmov    $0x7fffffff,%r8d\nmov    $0x7fffffff,%edx\nlea    0x4(%rdi,%rax,4),%rcx\njmp    32 <func0+0x32>\nxchg   %ax,%ax\nje     29 <func0+0x29>\ncmp    %r8d,%eax\ncmovl  %eax,%r8d\nadd    $0x4,%rdi\ncmp    %rcx,%rdi\nje     46 <func0+0x46>\nmov    (%rdi),%eax\ncmp    %edx,%eax\njge    20 <func0+0x20>\nadd    $0x4,%rdi\nmov    %edx,%r8d\nmov    %eax,%edx\ncmp    %rcx,%rdi\njne    32 <func0+0x32>\ncmp    $0x7fffffff,%r8d\nje     53 <func0+0x53>\nmov    %r8d,%eax\nretq\nmov    $0xffffffff,%r8d\njmp    4f <func0+0x4f>"
    },
    {
        "task_id": 90,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    53 <func0+0x53>\nlea    -0x1(%rsi),%eax\nmov    $0x7fffffff,%r8d\nmov    $0x7fffffff,%edx\nlea    0x4(%rdi,%rax,4),%rcx\njmp    32 <func0+0x32>\nxchg   %ax,%ax\nje     29 <func0+0x29>\ncmp    %r8d,%eax\ncmovl  %eax,%r8d\nadd    $0x4,%rdi\ncmp    %rdi,%rcx\nje     46 <func0+0x46>\nmov    (%rdi),%eax\ncmp    %eax,%edx\njle    20 <func0+0x20>\nadd    $0x4,%rdi\nmov    %edx,%r8d\nmov    %eax,%edx\ncmp    %rdi,%rcx\njne    32 <func0+0x32>\ncmp    $0x7fffffff,%r8d\nje     53 <func0+0x53>\nmov    %r8d,%eax\nretq\nmov    $0xffffffff,%r8d\njmp    4f <func0+0x4f>"
    },
    {
        "task_id": 91,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmpq   14d <func0+0x14d>\ncallq  36 <func0+0x36>\nmov    (%rax),%rax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovsbq %dl,%rdx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x2000,%eax\ntest   %eax,%eax\nje     73 <func0+0x73>\ncmpl   $0x0,-0xc(%rbp)\nje     73 <func0+0x73>\nmovl   $0x0,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x49,%al\njne    96 <func0+0x96>\ncmpl   $0x0,-0x10(%rbp)\nje     96 <func0+0x96>\nmovl   $0x1,-0xc(%rbp)\njmp    ce <func0+0xce>\ncallq  9b <func0+0x9b>\nmov    (%rax),%rax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovsbq %dl,%rdx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x2000,%eax\ntest   %eax,%eax\njne    ce <func0+0xce>\nmovl   $0x0,-0xc(%rbp)\ncallq  d3 <func0+0xd3>\nmov    (%rax),%rax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovsbq %dl,%rdx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x2000,%eax\ntest   %eax,%eax\njne    106 <func0+0x106>\nmovl   $0x0,-0x10(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2e,%al\nje     142 <func0+0x142>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x3f,%al\nje     142 <func0+0x142>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x21,%al\njne    149 <func0+0x149>\nmovl   $0x1,-0x10(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    31 <func0+0x31>\nmov    -0x8(%rbp),%eax\nleaveq\nretq"
    },
    {
        "task_id": 91,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%ebx\nmov    $0x0,%ebp\ntest   %bl,%bl\nje     bd <func0+0xbd>\nmov    %rdi,%rbp\ncallq  22 <func0+0x22>\nmov    (%rax),%r9\nmovsbq %bl,%rax\nmovzwl (%r9,%rax,2),%eax\nand    $0x2000,%ax\nlea    0x1(%rbp),%rdi\nmov    $0x1,%edx\nmov    $0x0,%ebp\nmov    $0x0,%esi\nmov    $0x0,%r8d\nmovabs $0x8000400200000000,%r11\n40 00 80\nmov    $0x1,%r10d\njmp    61 <func0+0x61>\nadd    $0x1,%rdi\ntest   %edx,%edx\nje     6a <func0+0x6a>\ncmp    $0x49,%bl\nje     af <func0+0xaf>\ntest   %ax,%ax\ncmove  %r8d,%esi\ncmove  %r8d,%edx\ncmp    $0x3f,%bl\nja     88 <func0+0x88>\nmov    %r11,%rax\nmov    %ebx,%ecx\nshr    %cl,%rax\ntest   $0x1,%al\ncmovne %r10d,%edx\nmovzbl (%rdi),%ebx\ntest   %bl,%bl\nje     bd <func0+0xbd>\nmovsbq %bl,%rax\nmovzwl (%r9,%rax,2),%eax\nand    $0x2000,%ax\ntest   %esi,%esi\nje     5d <func0+0x5d>\ntest   %ax,%ax\nje     5d <func0+0x5d>\nadd    $0x1,%ebp\nmov    $0x0,%esi\njmp    5d <func0+0x5d>\nmov    $0x1,%esi\ntest   %ax,%ax\ncmove  %r8d,%edx\njmp    88 <func0+0x88>\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 91,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%ebx\ntest   %bl,%bl\nje     b0 <func0+0xb0>\nmov    %rdi,%rbp\ncallq  1d <func0+0x1d>\nlea    0x1(%rbp),%rdi\nxor    %r8d,%r8d\nxor    %esi,%esi\nmov    (%rax),%r9\nmov    $0x1,%edx\nmov    $0x1,%r11d\nmovabs $0x8000400200000000,%r10\n40 00 80\njmp    6b <func0+0x6b>\ncmp    $0x1,%esi\nsbb    $0xffffffff,%r8d\ntest   %al,%al\njne    a0 <func0+0xa0>\nxor    %esi,%esi\ncmp    $0x3f,%bl\nja     60 <func0+0x60>\nmov    %r10,%rax\nmov    %ebx,%ecx\nshr    %cl,%rax\ntest   $0x1,%al\ncmovne %r11d,%edx\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\nje     95 <func0+0x95>\ncmp    $0x49,%bl\nmovsbq %bl,%rcx\nsete   %al\nand    %edx,%eax\ntestb  $0x20,0x1(%r9,%rcx,2)\njne    40 <func0+0x40>\nxor    %edx,%edx\ntest   %al,%al\nje     4b <func0+0x4b>\nmov    $0x1,%esi\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\njne    6b <func0+0x6b>\nadd    $0x8,%rsp\nmov    %r8d,%eax\npop    %rbx\npop    %rbp\nretq\nnop\nmov    $0x1,%edx\nmov    $0x1,%esi\njmp    8a <func0+0x8a>\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nxor    %r8d,%r8d\nmov    %r8d,%eax\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 91,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%ebx\ntest   %bl,%bl\nje     b0 <func0+0xb0>\nmov    %rdi,%rbp\ncallq  1d <func0+0x1d>\nlea    0x1(%rbp),%rdi\nxor    %r8d,%r8d\nxor    %esi,%esi\nmov    (%rax),%r9\nmov    $0x1,%edx\nmovabs $0x8000400200000000,%r11\n40 00 80\nmov    $0x1,%r10d\njmp    6b <func0+0x6b>\ncmp    $0x1,%esi\nsbb    $0xffffffff,%r8d\ntest   %al,%al\njne    a0 <func0+0xa0>\nxor    %esi,%esi\ncmp    $0x3f,%bl\nja     60 <func0+0x60>\nmov    %r11,%rax\nmov    %ebx,%ecx\nshr    %cl,%rax\ntest   $0x1,%al\ncmovne %r10d,%edx\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\nje     95 <func0+0x95>\ncmp    $0x49,%bl\nmovsbq %bl,%rcx\nsete   %al\nand    %edx,%eax\ntestb  $0x20,0x1(%r9,%rcx,2)\njne    40 <func0+0x40>\nxor    %edx,%edx\ntest   %al,%al\nje     4b <func0+0x4b>\nmov    $0x1,%esi\nmovzbl (%rdi),%ebx\nadd    $0x1,%rdi\ntest   %bl,%bl\njne    6b <func0+0x6b>\nadd    $0x8,%rsp\nmov    %r8d,%eax\npop    %rbx\npop    %rbp\nretq\nnop\nmov    $0x1,%edx\nmov    $0x1,%esi\njmp    8a <func0+0x8a>\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nxor    %r8d,%r8d\nmov    %r8d,%eax\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 92,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovss  %xmm0,-0x4(%rbp)\nmovss  %xmm1,-0x8(%rbp)\nmovss  %xmm2,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\nmovd   %eax,%xmm0\ncallq  27 <func0+0x27>\nucomiss -0x4(%rbp),%xmm0\njp     33 <func0+0x33>\nucomiss -0x4(%rbp),%xmm0\nje     3d <func0+0x3d>\nmov    $0x0,%eax\njmpq   c9 <func0+0xc9>\nmov    -0x8(%rbp),%eax\nmovd   %eax,%xmm0\ncallq  49 <func0+0x49>\nucomiss -0x8(%rbp),%xmm0\njp     55 <func0+0x55>\nucomiss -0x8(%rbp),%xmm0\nje     5c <func0+0x5c>\nmov    $0x0,%eax\njmp    c9 <func0+0xc9>\nmov    -0xc(%rbp),%eax\nmovd   %eax,%xmm0\ncallq  68 <func0+0x68>\nucomiss -0xc(%rbp),%xmm0\njp     74 <func0+0x74>\nucomiss -0xc(%rbp),%xmm0\nje     7b <func0+0x7b>\nmov    $0x0,%eax\njmp    c9 <func0+0xc9>\nmovss  -0x4(%rbp),%xmm0\naddss  -0x8(%rbp),%xmm0\nucomiss -0xc(%rbp),%xmm0\njp     91 <func0+0x91>\nucomiss -0xc(%rbp),%xmm0\nje     bd <func0+0xbd>\nmovss  -0x4(%rbp),%xmm0\naddss  -0xc(%rbp),%xmm0\nucomiss -0x8(%rbp),%xmm0\njp     a7 <func0+0xa7>\nucomiss -0x8(%rbp),%xmm0\nje     bd <func0+0xbd>\nmovss  -0x8(%rbp),%xmm0\naddss  -0xc(%rbp),%xmm0\nucomiss -0x4(%rbp),%xmm0\njp     c4 <func0+0xc4>\nucomiss -0x4(%rbp),%xmm0\njne    c4 <func0+0xc4>\nmov    $0x1,%eax\njmp    c9 <func0+0xc9>\nmov    $0x0,%eax\nleaveq\nretq"
    },
    {
        "task_id": 92,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x18,%rsp\nmovss  %xmm1,0x4(%rsp)\nmovss  %xmm2,0xc(%rsp)\nmovss  %xmm0,0x8(%rsp)\ncallq  1f <func0+0x1f>\nmovss  0x8(%rsp),%xmm3\nucomiss %xmm3,%xmm0\njp     bf <func0+0xbf>\njne    bf <func0+0xbf>\nmovss  0x4(%rsp),%xmm0\ncallq  3f <func0+0x3f>\nmovss  0x4(%rsp),%xmm4\nucomiss %xmm4,%xmm0\njp     c9 <func0+0xc9>\njne    c9 <func0+0xc9>\nmovss  0xc(%rsp),%xmm0\ncallq  57 <func0+0x57>\nmovss  0xc(%rsp),%xmm5\nucomiss %xmm5,%xmm0\njp     d0 <func0+0xd0>\njne    d0 <func0+0xd0>\nmovss  0x8(%rsp),%xmm0\naddss  0x4(%rsp),%xmm0\nucomiss %xmm5,%xmm0\njnp    ad <func0+0xad>\nmovss  0x8(%rsp),%xmm0\naddss  0xc(%rsp),%xmm0\nucomiss 0x4(%rsp),%xmm0\njnp    b6 <func0+0xb6>\nmovss  0x4(%rsp),%xmm0\naddss  0xc(%rsp),%xmm0\nmovss  0x8(%rsp),%xmm6\nucomiss %xmm6,%xmm0\nsetnp  %al\nmovzbl %al,%eax\nmov    $0x0,%edx\ncmovne %edx,%eax\njmp    c4 <func0+0xc4>\njne    75 <func0+0x75>\nmov    $0x1,%eax\njmp    c4 <func0+0xc4>\njne    88 <func0+0x88>\nmov    $0x1,%eax\njmp    c4 <func0+0xc4>\nmov    $0x0,%eax\nadd    $0x18,%rsp\nretq\nmov    $0x0,%eax\njmp    c4 <func0+0xc4>\nmov    $0x0,%eax\njmp    c4 <func0+0xc4>"
    },
    {
        "task_id": 92,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x18,%rsp\nmovss  %xmm1,0x4(%rsp)\nmovss  %xmm2,0xc(%rsp)\nmovss  %xmm0,0x8(%rsp)\ncallq  1f <func0+0x1f>\nucomiss 0x8(%rsp),%xmm0\njp     a0 <func0+0xa0>\njne    a0 <func0+0xa0>\nmovss  0x4(%rsp),%xmm0\ncallq  33 <func0+0x33>\nucomiss 0x4(%rsp),%xmm0\njp     a0 <func0+0xa0>\njne    a0 <func0+0xa0>\nmovss  0xc(%rsp),%xmm0\ncallq  47 <func0+0x47>\nmovss  0xc(%rsp),%xmm5\nucomiss %xmm5,%xmm0\njp     a0 <func0+0xa0>\njne    a0 <func0+0xa0>\nmovss  0x8(%rsp),%xmm0\naddss  0x4(%rsp),%xmm0\nucomiss %xmm5,%xmm0\njnp    b0 <func0+0xb0>\nmovss  0x8(%rsp),%xmm0\naddss  0xc(%rsp),%xmm0\nucomiss 0x4(%rsp),%xmm0\njnp    c0 <func0+0xc0>\nmovss  0x4(%rsp),%xmm0\naddss  0xc(%rsp),%xmm0\nxor    %eax,%eax\nmov    $0x0,%edx\nmovss  0x8(%rsp),%xmm6\nucomiss %xmm6,%xmm0\nsetnp  %al\ncmovne %edx,%eax\nadd    $0x18,%rsp\nretq\nnop\nxor    %eax,%eax\nadd    $0x18,%rsp\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\njne    65 <func0+0x65>\nmov    $0x1,%eax\nadd    $0x18,%rsp\nretq\nnopl   0x0(%rax)\nje     b2 <func0+0xb2>\njmp    78 <func0+0x78>"
    },
    {
        "task_id": 92,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x18,%rsp\nmovss  %xmm1,0x4(%rsp)\nmovss  %xmm2,0xc(%rsp)\nmovss  %xmm0,0x8(%rsp)\ncallq  1f <func0+0x1f>\nucomiss 0x8(%rsp),%xmm0\njp     a0 <func0+0xa0>\njne    a0 <func0+0xa0>\nmovss  0x4(%rsp),%xmm0\ncallq  33 <func0+0x33>\nucomiss 0x4(%rsp),%xmm0\njp     a0 <func0+0xa0>\njne    a0 <func0+0xa0>\nmovss  0xc(%rsp),%xmm0\ncallq  47 <func0+0x47>\nmovss  0xc(%rsp),%xmm5\nucomiss %xmm5,%xmm0\njp     a0 <func0+0xa0>\njne    a0 <func0+0xa0>\nmovss  0x8(%rsp),%xmm0\naddss  0x4(%rsp),%xmm0\nucomiss %xmm5,%xmm0\njnp    b0 <func0+0xb0>\nmovss  0x8(%rsp),%xmm0\naddss  0xc(%rsp),%xmm0\nucomiss 0x4(%rsp),%xmm0\njnp    c0 <func0+0xc0>\nmovss  0x4(%rsp),%xmm0\naddss  0xc(%rsp),%xmm0\nxor    %eax,%eax\nmov    $0x0,%edx\nmovss  0x8(%rsp),%xmm6\nucomiss %xmm6,%xmm0\nsetnp  %al\ncmovne %edx,%eax\nadd    $0x18,%rsp\nretq\nnop\nxor    %eax,%eax\nadd    $0x18,%rsp\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\njne    65 <func0+0x65>\nmov    $0x1,%eax\nadd    $0x18,%rsp\nretq\nnopl   0x0(%rax)\nje     b2 <func0+0xb2>\njmp    78 <func0+0x78>"
    },
    {
        "task_id": 93,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmpq   102 <func0+0x102>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x11(%rbp)\ncallq  43 <func0+0x43>\nmov    (%rax),%rax\nmovsbq -0x11(%rbp),%rdx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x200,%eax\ntest   %eax,%eax\nje     70 <func0+0x70>\nmovsbl -0x11(%rbp),%eax\nmov    %eax,%edi\ncallq  6b <func0+0x6b>\nmov    %al,-0x11(%rbp)\njmp    a0 <func0+0xa0>\ncallq  75 <func0+0x75>\nmov    (%rax),%rax\nmovsbq -0x11(%rbp),%rdx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x100,%eax\ntest   %eax,%eax\nje     a0 <func0+0xa0>\nmovsbl -0x11(%rbp),%eax\nmov    %eax,%edi\ncallq  9d <func0+0x9d>\nmov    %al,-0x11(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    d4 <func0+0xd4>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    %al,-0x11(%rbp)\njne    d0 <func0+0xd0>\ncmpl   $0x9,-0xc(%rbp)\njg     ea <func0+0xea>\nmovzbl -0x11(%rbp),%eax\nadd    $0x2,%eax\nmov    %al,-0x11(%rbp)\njmp    ea <func0+0xea>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    a9 <func0+0xa9>\njmp    eb <func0+0xeb>\nnop\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x11(%rbp),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    2b <func0+0x2b>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\nleaveq\nretq"
    },
    {
        "task_id": 93,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rsi,0x8(%rsp)\nmovzbl (%rdi),%ebx\ntest   %bl,%bl\nje     ac <func0+0xac>\nmov    %rdi,%r14\ncallq  2a <func0+0x2a>\nmov    %rax,%r15\nmov    $0x0,%r12d\nlea    0x0(%rip),%rbp\njmp    6f <func0+0x6f>\ntest   $0x1,%ah\nje     8d <func0+0x8d>\ncallq  46 <func0+0x46>\nmov    (%rax),%rax\nmovzbl (%rax,%r13,4),%ebx\njmp    8d <func0+0x8d>\nlea    0x2(%rbx),%eax\ncmp    $0xa,%ecx\ncmovl  %eax,%ebx\nmov    0x8(%rsp),%rax\nmov    %bl,(%rax,%r12,1)\nadd    $0x1,%r12\nmovzbl (%r14,%r12,1),%ebx\ntest   %bl,%bl\nje     b2 <func0+0xb2>\nmovsbq %bl,%r13\nmov    (%r15),%rax\nmovzwl (%rax,%r13,2),%eax\ntest   $0x2,%ah\nje     3c <func0+0x3c>\ncallq  85 <func0+0x85>\nmov    (%rax),%rax\nmovzbl (%rax,%r13,4),%ebx\nmov    $0x0,%eax\nmov    $0x61,%edx\nmov    %eax,%ecx\ncmp    %dl,%bl\nje     50 <func0+0x50>\nadd    $0x1,%rax\nmovzbl 0x0(%rbp,%rax,1),%edx\ntest   %dl,%dl\njne    97 <func0+0x97>\njmp    59 <func0+0x59>\nmov    $0x0,%r12d\nmov    0x8(%rsp),%rax\nmovb   $0x0,(%rax,%r12,1)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 93,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmovzbl (%rdi),%ebx\nmov    %rdi,0x8(%rsp)\ntest   %bl,%bl\nje     97 <func0+0x97>\ncallq  26 <func0+0x26>\nxor    %r14d,%r14d\nlea    0x0(%rip),%r13\nmov    %rax,%r12\nnopl   0x0(%rax,%rax,1)\nmov    (%r12),%rax\nmovsbq %bl,%r15\nmovzwl (%rax,%r15,2),%eax\ntest   $0x2,%ah\nje     b0 <func0+0xb0>\ncallq  4f <func0+0x4f>\nmov    (%rax),%rax\nmovzbl (%rax,%r15,4),%ebx\nxor    %eax,%eax\nmov    $0x61,%edx\njmp    6e <func0+0x6e>\nadd    $0x1,%rax\nmovzbl 0x0(%r13,%rax,1),%edx\ntest   %dl,%dl\nje     7d <func0+0x7d>\nmov    %eax,%ecx\ncmp    %dl,%bl\njne    60 <func0+0x60>\nlea    0x2(%rbx),%eax\ncmp    $0xa,%ecx\ncmovl  %eax,%ebx\nmov    0x8(%rsp),%rax\nmov    %bl,0x0(%rbp,%r14,1)\nadd    $0x1,%r14\nmovzbl (%rax,%r14,1),%ebx\ntest   %bl,%bl\njne    38 <func0+0x38>\nadd    %r14,%rbp\nmovb   $0x0,0x0(%rbp)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopw   0x0(%rax,%rax,1)\ntest   $0x1,%ah\nje     57 <func0+0x57>\ncallq  ba <func0+0xba>\nmov    (%rax),%rax\nmovzbl (%rax,%r15,4),%ebx\njmp    57 <func0+0x57>"
    },
    {
        "task_id": 93,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmovzbl (%rdi),%ebx\nmov    %rdi,0x8(%rsp)\ntest   %bl,%bl\nje     97 <func0+0x97>\ncallq  26 <func0+0x26>\nxor    %r14d,%r14d\nlea    0x0(%rip),%r13\nmov    %rax,%r12\nnopl   0x0(%rax,%rax,1)\nmov    (%r12),%rax\nmovsbq %bl,%r15\nmovzwl (%rax,%r15,2),%eax\ntest   $0x2,%ah\nje     b0 <func0+0xb0>\ncallq  4f <func0+0x4f>\nmov    (%rax),%rax\nmovzbl (%rax,%r15,4),%ebx\nxor    %eax,%eax\nmov    $0x61,%edx\njmp    6e <func0+0x6e>\nadd    $0x1,%rax\nmovzbl 0x0(%r13,%rax,1),%edx\ntest   %dl,%dl\nje     7d <func0+0x7d>\nmov    %eax,%ecx\ncmp    %dl,%bl\njne    60 <func0+0x60>\nlea    0x2(%rbx),%eax\ncmp    $0xa,%ecx\ncmovl  %eax,%ebx\nmov    0x8(%rsp),%rax\nmov    %bl,0x0(%rbp,%r14,1)\nadd    $0x1,%r14\nmovzbl (%rax,%r14,1),%ebx\ntest   %bl,%bl\njne    38 <func0+0x38>\nadd    %r14,%rbp\nmovb   $0x0,0x0(%rbp)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopw   0x0(%rax,%rax,1)\ntest   $0x1,%ah\nje     57 <func0+0x57>\ncallq  ba <func0+0xba>\nmov    (%rax),%rax\nmovzbl (%rax,%r15,4),%ebx\njmp    57 <func0+0x57>"
    },
    {
        "task_id": 94,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    91 <func0+0x91>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njle    8d <func0+0x8d>\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x2,-0x8(%rbp)\njmp    6f <func0+0x6f>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    6b <func0+0x6b>\nmovl   $0x0,-0xc(%rbp)\njmp    7a <func0+0x7a>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x4(%rbp)\njge    55 <func0+0x55>\ncmpl   $0x0,-0xc(%rbp)\nje     8d <func0+0x8d>\nmov    -0x4(%rbp),%eax\ncmp    %eax,-0x18(%rbp)\ncmovge -0x18(%rbp),%eax\nmov    %eax,-0x18(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     26 <func0+0x26>\njmp    e6 <func0+0xe6>\nmov    -0x18(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%edx\nsar    $0x2,%edx\nmov    %ecx,%eax\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\nadd    %edx,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nmov    %eax,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njg     9b <func0+0x9b>\nmov    -0x14(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 94,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    4f <func0+0x4f>\nmov    %rdi,%r8\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r9\nmov    $0x0,%edi\njmp    6b <func0+0x6b>\ntest   %edi,%edi\njle    56 <func0+0x56>\nmov    $0x0,%ecx\nmovslq %edi,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edi,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,4),%edx\nadd    %edx,%edx\nmov    %edi,%esi\nsub    %edx,%esi\nadd    %esi,%ecx\nmov    %edi,%edx\nmov    %eax,%edi\ncmp    $0x9,%edx\njg     23 <func0+0x23>\nmov    %ecx,%eax\nretq\nmov    $0x0,%ecx\njmp    4c <func0+0x4c>\nmov    $0x0,%ecx\njmp    4c <func0+0x4c>\ncmp    %esi,%edi\ncmovl  %esi,%edi\nadd    $0x4,%r8\ncmp    %r9,%r8\nje     1a <func0+0x1a>\nmov    (%r8),%esi\ncmp    $0x1,%esi\njle    62 <func0+0x62>\ncmp    $0x3,%esi\njle    5d <func0+0x5d>\ntest   $0x1,%sil\nje     62 <func0+0x62>\nmov    $0x2,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njg     5d <func0+0x5d>\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    83 <func0+0x83>\njmp    62 <func0+0x62>"
    },
    {
        "task_id": 94,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    a1 <func0+0xa1>\nlea    -0x1(%rsi),%eax\nxor    %r8d,%r8d\nlea    0x4(%rdi,%rax,4),%r9\njmp    29 <func0+0x29>\nnopl   0x0(%rax)\nadd    $0x4,%rdi\ncmp    %r9,%rdi\nje     70 <func0+0x70>\nmov    (%rdi),%esi\ncmp    $0x1,%esi\njle    20 <func0+0x20>\ncmp    $0x3,%esi\njle    5d <func0+0x5d>\ntest   $0x1,%sil\nje     20 <func0+0x20>\nmov    $0x2,%ecx\njmp    51 <func0+0x51>\nnopw   0x0(%rax,%rax,1)\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     20 <func0+0x20>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njle    48 <func0+0x48>\ncmp    %esi,%r8d\ncmovl  %esi,%r8d\nadd    $0x4,%rdi\ncmp    %r9,%rdi\njne    29 <func0+0x29>\nnopl   (%rax)\nxor    %r9d,%r9d\ntest   %r8d,%r8d\nje     9d <func0+0x9d>\nmov    $0xcccccccd,%ecx\nnopl   (%rax)\nmov    %r8d,%eax\nimul   %rcx,%rax\nshr    $0x23,%rax\nlea    (%rax,%rax,4),%edx\nadd    %edx,%edx\nsub    %edx,%r8d\nadd    %r8d,%r9d\nmov    %eax,%r8d\ntest   %eax,%eax\njne    80 <func0+0x80>\nmov    %r9d,%eax\nretq\nxor    %r9d,%r9d\nmov    %r9d,%eax\nretq"
    },
    {
        "task_id": 94,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    a1 <func0+0xa1>\nlea    -0x1(%rsi),%eax\nxor    %r8d,%r8d\nlea    0x4(%rdi,%rax,4),%r9\njmp    29 <func0+0x29>\nnopl   0x0(%rax)\nadd    $0x4,%rdi\ncmp    %r9,%rdi\nje     70 <func0+0x70>\nmov    (%rdi),%esi\ncmp    $0x1,%esi\njle    20 <func0+0x20>\ncmp    $0x3,%esi\njle    5d <func0+0x5d>\ntest   $0x1,%sil\nje     20 <func0+0x20>\nmov    $0x2,%ecx\njmp    51 <func0+0x51>\nnopw   0x0(%rax,%rax,1)\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     20 <func0+0x20>\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %esi,%eax\njle    48 <func0+0x48>\ncmp    %esi,%r8d\ncmovl  %esi,%r8d\nadd    $0x4,%rdi\ncmp    %r9,%rdi\njne    29 <func0+0x29>\nnopl   (%rax)\nxor    %r9d,%r9d\ntest   %r8d,%r8d\nje     9d <func0+0x9d>\nmov    $0xcccccccd,%ecx\nnopl   (%rax)\nmov    %r8d,%eax\nimul   %rcx,%rax\nshr    $0x23,%rax\nlea    (%rax,%rax,4),%edx\nadd    %edx,%edx\nsub    %edx,%r8d\nadd    %r8d,%r9d\nmov    %eax,%r8d\ntest   %eax,%eax\njne    80 <func0+0x80>\nmov    %r9d,%eax\nretq\nxor    %r9d,%r9d\nmov    %r9d,%eax\nretq"
    },
    {
        "task_id": 95,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\ncmpl   $0x0,-0x2c(%rbp)\njne    23 <func0+0x23>\nmov    $0x0,%eax\njmpq   150 <func0+0x150>\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmpq   13f <func0+0x13f>\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmpq   123 <func0+0x123>\ncallq  68 <func0+0x68>\nmov    (%rax),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovzbl %dl,%edx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\njne    9d <func0+0x9d>\nmov    $0x0,%eax\njmpq   150 <func0+0x150>\ncallq  a2 <func0+0xa2>\nmov    (%rax),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovzbl %dl,%edx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x100,%eax\ntest   %eax,%eax\nje     d4 <func0+0xd4>\nmovl   $0x1,-0x14(%rbp)\ncallq  d9 <func0+0xd9>\nmov    (%rax),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovzbl %dl,%edx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x200,%eax\ntest   %eax,%eax\nje     10b <func0+0x10b>\nmovl   $0x1,-0x18(%rbp)\nmov    -0x14(%rbp),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\ncmp    $0x2,%eax\njne    11f <func0+0x11f>\nmov    $0x0,%eax\njmp    150 <func0+0x150>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    63 <func0+0x63>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     3d <func0+0x3d>\nmov    $0x1,%eax\nleaveq\nretq"
    },
    {
        "task_id": 95,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%eax\ntest   %esi,%esi\nje     db <func0+0xdb>\njle    7c <func0+0x7c>\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,(%rsp)\nlea    -0x1(%rsi),%eax\nshl    $0x4,%rax\nlea    0x10(%rdi,%rax,1),%rax\nmov    %rax,0x8(%rsp)\nmov    $0x0,%r13d\nmov    $0x0,%r12d\nmov    $0x1,%r14d\nmov    %r14d,%r15d\nmov    (%rsp),%rax\nmov    (%rax),%rbp\nmovzbl 0x0(%rbp),%ebx\ntest   %bl,%bl\nje     65 <func0+0x65>\ncallq  5c <func0+0x5c>\nmov    (%rax),%rdx\nadd    $0x1,%rbp\njmp    c1 <func0+0xc1>\naddq   $0x10,(%rsp)\nmov    (%rsp),%rax\ncmp    0x8(%rsp),%rax\njne    48 <func0+0x48>\nmov    $0x1,%eax\njmp    87 <func0+0x87>\nmov    $0x1,%eax\nretq\nmov    $0x0,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    $0x0,%eax\njmp    87 <func0+0x87>\nmov    $0x0,%eax\njmp    87 <func0+0x87>\ntest   $0x2,%ah\njne    9d <func0+0x9d>\nmov    %r15d,%r13d\nlea    (%r12,%r13,1),%eax\ncmp    $0x2,%eax\nje     96 <func0+0x96>\nadd    $0x1,%rbp\nmovzbl -0x1(%rbp),%ebx\ntest   %bl,%bl\nje     65 <func0+0x65>\nmovzbl %bl,%ebx\nmovzwl (%rdx,%rbx,2),%eax\ntest   $0x4,%ah\nje     82 <func0+0x82>\ntest   $0x1,%ah\njne    a4 <func0+0xa4>\ntest   $0x2,%ah\ncmovne %r14d,%r12d\njmp    ac <func0+0xac>\nretq"
    },
    {
        "task_id": 95,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ntest   %esi,%esi\nje     d0 <func0+0xd0>\njle    d1 <func0+0xd1>\npush   %r15\nlea    -0x1(%rsi),%eax\nmov    %rdi,%r15\npush   %r14\nshl    $0x4,%rax\nxor    %r14d,%r14d\npush   %r13\nlea    0x10(%rdi,%rax,1),%rax\nxor    %r13d,%r13d\npush   %r12\nmov    $0x1,%r12d\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rax,0x8(%rsp)\nmov    (%r15),%rbp\nmovzbl 0x0(%rbp),%ebx\ntest   %bl,%bl\nje     b8 <func0+0xb8>\ncallq  52 <func0+0x52>\nlea    0x1(%rbp),%rdx\nmov    (%rax),%rsi\njmp    7c <func0+0x7c>\nnopl   0x0(%rax,%rax,1)\ntest   %cx,%cx\ncmovne %r12d,%r13d\nlea    0x0(%r13,%r14,1),%eax\ncmp    $0x2,%eax\nje     a0 <func0+0xa0>\nmovzbl (%rdx),%ebx\nadd    $0x1,%rdx\ntest   %bl,%bl\nje     b8 <func0+0xb8>\nmovzwl (%rsi,%rbx,2),%eax\ntest   $0x4,%ah\nje     a0 <func0+0xa0>\nmov    %eax,%ecx\nand    $0x200,%cx\ntest   $0x1,%ah\nje     60 <func0+0x60>\ntest   %cx,%cx\njne    a0 <func0+0xa0>\nmov    $0x1,%r14d\njmp    67 <func0+0x67>\nxchg   %ax,%ax\nxor    %eax,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\nadd    $0x10,%r15\ncmp    %r15,0x8(%rsp)\njne    42 <func0+0x42>\nmov    $0x1,%eax\njmp    a2 <func0+0xa2>\nxchg   %ax,%ax\nretq\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 95,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %eax,%eax\ntest   %esi,%esi\nje     d0 <func0+0xd0>\njle    d1 <func0+0xd1>\npush   %r15\nlea    -0x1(%rsi),%eax\nmov    %rdi,%r15\npush   %r14\nshl    $0x4,%rax\nxor    %r14d,%r14d\npush   %r13\nlea    0x10(%rdi,%rax,1),%rax\nxor    %r13d,%r13d\npush   %r12\nmov    $0x1,%r12d\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rax,0x8(%rsp)\nmov    (%r15),%rbp\nmovzbl 0x0(%rbp),%ebx\ntest   %bl,%bl\nje     b8 <func0+0xb8>\ncallq  52 <func0+0x52>\nlea    0x1(%rbp),%rdx\nmov    (%rax),%rsi\njmp    7c <func0+0x7c>\nnopl   0x0(%rax,%rax,1)\ntest   %cx,%cx\ncmovne %r12d,%r13d\nlea    0x0(%r13,%r14,1),%eax\ncmp    $0x2,%eax\nje     a0 <func0+0xa0>\nmovzbl (%rdx),%ebx\nadd    $0x1,%rdx\ntest   %bl,%bl\nje     b8 <func0+0xb8>\nmovzwl (%rsi,%rbx,2),%eax\ntest   $0x4,%ah\nje     a0 <func0+0xa0>\nmov    %eax,%ecx\nand    $0x200,%cx\ntest   $0x1,%ah\nje     60 <func0+0x60>\ntest   %cx,%cx\njne    a0 <func0+0xa0>\nmov    $0x1,%r14d\njmp    67 <func0+0x67>\nxchg   %ax,%ax\nxor    %eax,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\nadd    $0x10,%r15\ncmp    %r15,0x8(%rsp)\njne    42 <func0+0x42>\nmov    $0x1,%eax\njmp    a2 <func0+0xa2>\nxchg   %ax,%ax\nretq\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 96,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  24 <func0+0x24>\nmov    %rax,-0x8(%rbp)\nmov    -0x30(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x2,-0x18(%rbp)\njmpq   cf <func0+0xcf>\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    8c <func0+0x8c>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x18(%rbp)\njl     99 <func0+0x99>\nmov    -0x18(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    88 <func0+0x88>\nmovl   $0x0,-0x10(%rbp)\njmp    9a <func0+0x9a>\naddl   $0x1,-0x14(%rbp)\nmov    -0x30(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x14(%rbp)\njl     4e <func0+0x4e>\njmp    9a <func0+0x9a>\nnop\ncmpl   $0x0,-0x10(%rbp)\nje     cb <func0+0xcb>\nmov    -0x30(%rbp),%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x30(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x30(%rbp),%rax\nmov    %edx,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     3e <func0+0x3e>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 96,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %edi,%ebp\nmov    %rsi,%rbx\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  1b <func0+0x1b>\nmov    %rax,%r10\nmovl   $0x0,(%rbx)\nmov    $0x2,%edi\ncmp    $0x2,%ebp\njg     4d <func0+0x4d>\nmov    %r10,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq\nmovslq %r9d,%rax\nmov    %edi,(%r10,%rax,4)\nadd    $0x1,%r9d\nmov    %r9d,(%rbx)\nadd    $0x1,%edi\ncmp    %edi,%ebp\nje     2e <func0+0x2e>\nmov    (%rbx),%r9d\ntest   %r9d,%r9d\njle    38 <func0+0x38>\nmov    %r10,%rsi\nlea    -0x1(%r9),%eax\nlea    0x4(%r10,%rax,4),%r8\nmov    (%rsi),%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njg     38 <func0+0x38>\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     46 <func0+0x46>\nadd    $0x4,%rsi\ncmp    %r8,%rsi\njne    61 <func0+0x61>\njmp    38 <func0+0x38>"
    },
    {
        "task_id": 96,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmovslq %edi,%rdi\nmov    %rsi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nshl    $0x2,%rdi\nsub    $0x8,%rsp\ncallq  1c <func0+0x1c>\nmovl   $0x0,0x0(%rbp)\nxor    %r10d,%r10d\nmov    $0x2,%r8d\nmov    %rax,%r11\nlea    0x4(%rax),%rsi\ncmp    $0x2,%ebx\njle    98 <func0+0x98>\nnopl   0x0(%rax,%rax,1)\n00\ntest   %r10d,%r10d\njle    77 <func0+0x77>\nlea    -0x1(%r10),%eax\nmov    %r11,%rdi\nlea    (%rsi,%rax,4),%r9\njmp    6b <func0+0x6b>\nnopw   0x0(%rax,%rax,1)\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     86 <func0+0x86>\nadd    $0x4,%rdi\ncmp    %r9,%rdi\nje     77 <func0+0x77>\nmov    (%rdi),%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %r8d,%eax\njle    58 <func0+0x58>\nmovslq %r10d,%rax\nadd    $0x1,%r10d\nmov    %r8d,(%r11,%rax,4)\nmov    %r10d,0x0(%rbp)\nadd    $0x1,%r8d\ncmp    %r8d,%ebx\nje     98 <func0+0x98>\nmov    0x0(%rbp),%r10d\njmp    40 <func0+0x40>\nnopl   (%rax)\nadd    $0x8,%rsp\nmov    %r11,%rax\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 96,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmovslq %edi,%rdi\nmov    %rsi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nshl    $0x2,%rdi\nsub    $0x8,%rsp\ncallq  1c <func0+0x1c>\nmovl   $0x0,0x0(%rbp)\nxor    %r10d,%r10d\nmov    $0x2,%r8d\nmov    %rax,%r11\nlea    0x4(%rax),%rsi\ncmp    $0x2,%ebx\njle    8f <func0+0x8f>\nnopl   0x0(%rax,%rax,1)\n00\ntest   %r10d,%r10d\nje     77 <func0+0x77>\nlea    -0x1(%r10),%eax\nmov    %r11,%rdi\nlea    (%rsi,%rax,4),%r9\njmp    6b <func0+0x6b>\nnopw   0x0(%rax,%rax,1)\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\nje     86 <func0+0x86>\nadd    $0x4,%rdi\ncmp    %r9,%rdi\nje     77 <func0+0x77>\nmov    (%rdi),%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %r8d,%eax\njle    58 <func0+0x58>\nmovslq %r10d,%rax\nadd    $0x1,%r10d\nmov    %r8d,(%r11,%rax,4)\nmov    %r10d,0x0(%rbp)\nadd    $0x1,%r8d\ncmp    %r8d,%ebx\njne    40 <func0+0x40>\nadd    $0x8,%rsp\nmov    %r11,%rax\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 97,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nsar    $0x1f,%eax\nmov    %eax,%edx\nxor    -0x4(%rbp),%edx\nsub    %eax,%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%ecx\nsar    $0x2,%ecx\nmov    %edx,%eax\nsar    $0x1f,%eax\nmov    %ecx,%esi\nsub    %eax,%esi\nmov    %esi,%eax\nshl    $0x2,%eax\nadd    %esi,%eax\nadd    %eax,%eax\nmov    %edx,%esi\nsub    %eax,%esi\nmov    -0x8(%rbp),%eax\nsar    $0x1f,%eax\nmov    %eax,%edx\nxor    -0x8(%rbp),%edx\nsub    %eax,%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%ecx\nsar    $0x2,%ecx\nmov    %edx,%eax\nsar    $0x1f,%eax\nsub    %eax,%ecx\nmov    %ecx,%eax\nshl    $0x2,%eax\nadd    %ecx,%eax\nadd    %eax,%eax\nmov    %edx,%ecx\nsub    %eax,%ecx\nmov    %esi,%eax\nimul   %ecx,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 97,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\ncltd\nxor    %edx,%eax\nsub    %edx,%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nsar    $0x22,%rdx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %esi,%edx\nsar    $0x1f,%edx\nxor    %edx,%esi\nsub    %edx,%esi\nmovslq %esi,%rdx\nimul   $0x66666667,%rdx,%rdx\nsar    $0x22,%rdx\nmov    %esi,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%esi\nimul   %esi,%eax\nretq"
    },
    {
        "task_id": 97,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%edx\nmov    %esi,%eax\nmov    $0xcccccccd,%esi\nsar    $0x1f,%edx\nxor    %edx,%edi\nsub    %edx,%edi\ncltd\nxor    %edx,%eax\nmov    %edi,%ecx\nsub    %edx,%eax\nimul   %rsi,%rcx\nmov    %eax,%edx\nimul   %rsi,%rdx\nshr    $0x23,%rcx\nlea    (%rcx,%rcx,4),%ecx\nshr    $0x23,%rdx\nadd    %ecx,%ecx\nlea    (%rdx,%rdx,4),%edx\nsub    %ecx,%edi\nadd    %edx,%edx\nsub    %edx,%eax\nimul   %edi,%eax\nretq"
    },
    {
        "task_id": 97,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%edx\nmov    %esi,%eax\nmov    $0xcccccccd,%esi\nsar    $0x1f,%edx\nxor    %edx,%edi\nsub    %edx,%edi\ncltd\nxor    %edx,%eax\nmov    %edi,%ecx\nsub    %edx,%eax\nimul   %rsi,%rcx\nmov    %eax,%edx\nimul   %rsi,%rdx\nshr    $0x23,%rcx\nlea    (%rcx,%rcx,4),%ecx\nshr    $0x23,%rdx\nadd    %ecx,%ecx\nlea    (%rdx,%rdx,4),%edx\nsub    %ecx,%edi\nadd    %edx,%edx\nsub    %edx,%eax\nimul   %edi,%eax\nretq"
    },
    {
        "task_id": 98,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    5c <func0+0x5c>\nmov    -0x1c(%rbp),%eax\nadd    %eax,%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncallq  4f <func0+0x4f>\ntest   %rax,%rax\nje     58 <func0+0x58>\naddl   $0x1,-0x20(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     89 <func0+0x89>\nmov    -0x1c(%rbp),%eax\nadd    %eax,%eax\nmovslq %eax,%rbx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  84 <func0+0x84>\ncmp    %rax,%rbx\njb     2c <func0+0x2c>\nmov    -0x20(%rbp),%eax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 98,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ncmpb   $0x0,(%rdi)\nje     6e <func0+0x6e>\nmov    %rdi,%rbp\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nshr    %rcx\nmov    %rcx,%r13\nmov    $0x0,%ebx\nmov    $0x0,%r12d\nlea    0x0(%rip),%r14\ncmp    %r13,%rbx\nje     62 <func0+0x62>\nmovsbl 0x0(%rbp,%rbx,2),%esi\nmov    %r14,%rdi\ncallq  4f <func0+0x4f>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r12d\nadd    $0x1,%rbx\ncmpb   $0x0,0x0(%rbp,%rbx,1)\njne    3d <func0+0x3d>\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nmov    $0x0,%r12d\njmp    62 <func0+0x62>"
    },
    {
        "task_id": 98,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ncmpb   $0x0,(%rdi)\nje     61 <func0+0x61>\nmov    %rdi,%r14\nxor    %ebx,%ebx\nlea    0x0(%rip),%r13\nxor    %r12d,%r12d\ncallq  25 <func0+0x25>\nlea    0x1(%rax),%rbp\nshr    %rbp\njmp    50 <func0+0x50>\nxchg   %ax,%ax\nmovsbl (%r14,%rbx,2),%esi\nmov    %r13,%rdi\ncallq  3d <func0+0x3d>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r12d\nadd    $0x1,%rbx\ncmpb   $0x0,(%r14,%rbx,1)\nje     55 <func0+0x55>\ncmp    %rbp,%rbx\njne    30 <func0+0x30>\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nxor    %r12d,%r12d\njmp    55 <func0+0x55>"
    },
    {
        "task_id": 98,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ncmpb   $0x0,(%rdi)\nje     61 <func0+0x61>\nmov    %rdi,%r14\nxor    %ebx,%ebx\nlea    0x0(%rip),%r13\nxor    %r12d,%r12d\ncallq  25 <func0+0x25>\nlea    0x1(%rax),%rbp\nshr    %rbp\njmp    50 <func0+0x50>\nxchg   %ax,%ax\nmovsbl (%r14,%rbx,2),%esi\nmov    %r13,%rdi\ncallq  3d <func0+0x3d>\ncmp    $0x1,%rax\nsbb    $0xffffffff,%r12d\nadd    $0x1,%rbx\ncmpb   $0x0,(%r14,%rbx,1)\nje     55 <func0+0x55>\ncmp    %rbx,%rbp\njne    30 <func0+0x30>\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nxor    %r12d,%r12d\njmp    55 <func0+0x55>"
    },
    {
        "task_id": 99,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  1c <func0+0x1c>\nmovq   %xmm0,%rax\nmov    %rax,-0x8(%rbp)\npxor   %xmm0,%xmm0\ncomisd -0x8(%rbp),%xmm0\njbe    4c <func0+0x4c>\nmovsd  -0x8(%rbp),%xmm0\nmovsd  0x0(%rip),%xmm1\n00\nsubsd  %xmm1,%xmm0\ncallq  46 <func0+0x46>\ncvttsd2si %xmm0,%eax\njmp    66 <func0+0x66>\nmovsd  -0x8(%rbp),%xmm1\nmovsd  0x0(%rip),%xmm0\n00\naddsd  %xmm1,%xmm0\ncallq  62 <func0+0x62>\ncvttsd2si %xmm0,%eax\nleaveq\nretq"
    },
    {
        "task_id": 99,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x0,%esi\ncallq  12 <func0+0x12>\npxor   %xmm1,%xmm1\ncomisd %xmm0,%xmm1\nja     82 <func0+0x82>\naddsd  0x0(%rip),%xmm0\n00\nmovapd %xmm0,%xmm1\nmovsd  0x0(%rip),%xmm3\n00\nmovapd %xmm0,%xmm2\nandpd  %xmm3,%xmm2\nmovsd  0x0(%rip),%xmm4\n00\nucomisd %xmm2,%xmm4\njbe    79 <func0+0x79>\ncvttsd2si %xmm0,%rax\npxor   %xmm2,%xmm2\ncvtsi2sd %rax,%xmm2\nmovapd %xmm2,%xmm1\ncmpnlesd %xmm0,%xmm1\nmovsd  0x0(%rip),%xmm4\n00\nandpd  %xmm4,%xmm1\nsubsd  %xmm1,%xmm2\nandnpd %xmm0,%xmm3\nmovapd %xmm3,%xmm1\norpd   %xmm2,%xmm1\ncvttsd2si %xmm1,%eax\nadd    $0x8,%rsp\nretq\nsubsd  0x0(%rip),%xmm0\n00\nmovapd %xmm0,%xmm1\nmovsd  0x0(%rip),%xmm3\n00\nmovapd %xmm0,%xmm2\nandpd  %xmm3,%xmm2\nmovsd  0x0(%rip),%xmm4\n00\nucomisd %xmm2,%xmm4\njbe    db <func0+0xdb>\ncvttsd2si %xmm0,%rax\npxor   %xmm2,%xmm2\ncvtsi2sd %rax,%xmm2\ncmpnlesd %xmm2,%xmm1\nmovsd  0x0(%rip),%xmm4\n00\nandpd  %xmm4,%xmm1\naddsd  %xmm1,%xmm2\nandnpd %xmm0,%xmm3\nmovapd %xmm3,%xmm1\norpd   %xmm2,%xmm1\ncvttsd2si %xmm1,%eax\njmp    7d <func0+0x7d>"
    },
    {
        "task_id": 99,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x8,%rsp\nxor    %esi,%esi\ncallq  f <func0+0xf>\npxor   %xmm1,%xmm1\ncomisd %xmm0,%xmm1\nja     90 <func0+0x90>\naddsd  0x0(%rip),%xmm0\n00\nmovsd  0x0(%rip),%xmm2\n00\nmovsd  0x0(%rip),%xmm3\n00\nmovapd %xmm0,%xmm1\nandpd  %xmm2,%xmm1\nucomisd %xmm1,%xmm3\nja     50 <func0+0x50>\ncvttsd2si %xmm0,%eax\nadd    $0x8,%rsp\nretq\nnopl   0x0(%rax,%rax,1)\n00\ncvttsd2si %xmm0,%rax\npxor   %xmm1,%xmm1\nmovsd  0x0(%rip),%xmm4\n00\nandnpd %xmm0,%xmm2\nadd    $0x8,%rsp\ncvtsi2sd %rax,%xmm1\nmovapd %xmm1,%xmm3\ncmpnlesd %xmm0,%xmm3\nmovapd %xmm2,%xmm0\nandpd  %xmm4,%xmm3\nsubsd  %xmm3,%xmm1\norpd   %xmm1,%xmm0\ncvttsd2si %xmm0,%eax\nretq\nnopl   0x0(%rax)\nsubsd  0x0(%rip),%xmm0\n00\nmovsd  0x0(%rip),%xmm2\n00\nmovsd  0x0(%rip),%xmm3\n00\nmovapd %xmm0,%xmm1\nandpd  %xmm2,%xmm1\nucomisd %xmm1,%xmm3\njbe    3f <func0+0x3f>\ncvttsd2si %xmm0,%rax\npxor   %xmm1,%xmm1\nmovapd %xmm0,%xmm3\nmovsd  0x0(%rip),%xmm4\n00\nandnpd %xmm0,%xmm2\nadd    $0x8,%rsp\nmovapd %xmm2,%xmm0\ncvtsi2sd %rax,%xmm1\ncmpnlesd %xmm1,%xmm3\nandpd  %xmm4,%xmm3\naddsd  %xmm3,%xmm1\norpd   %xmm1,%xmm0\ncvttsd2si %xmm0,%eax\nretq"
    },
    {
        "task_id": 99,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x8,%rsp\nxor    %esi,%esi\ncallq  f <func0+0xf>\npxor   %xmm1,%xmm1\ncomisd %xmm0,%xmm1\nja     90 <func0+0x90>\naddsd  0x0(%rip),%xmm0\n00\nmovsd  0x0(%rip),%xmm2\n00\nmovsd  0x0(%rip),%xmm3\n00\nmovapd %xmm0,%xmm1\nandpd  %xmm2,%xmm1\nucomisd %xmm1,%xmm3\nja     50 <func0+0x50>\ncvttsd2si %xmm0,%eax\nadd    $0x8,%rsp\nretq\nnopl   0x0(%rax,%rax,1)\n00\ncvttsd2si %xmm0,%rax\npxor   %xmm1,%xmm1\nmovsd  0x0(%rip),%xmm4\n00\nandnpd %xmm0,%xmm2\nadd    $0x8,%rsp\ncvtsi2sd %rax,%xmm1\nmovapd %xmm1,%xmm3\ncmpnlesd %xmm0,%xmm3\nmovapd %xmm2,%xmm0\nandpd  %xmm4,%xmm3\nsubsd  %xmm3,%xmm1\norpd   %xmm1,%xmm0\ncvttsd2si %xmm0,%eax\nretq\nnopl   0x0(%rax)\nsubsd  0x0(%rip),%xmm0\n00\nmovsd  0x0(%rip),%xmm2\n00\nmovsd  0x0(%rip),%xmm3\n00\nmovapd %xmm0,%xmm1\nandpd  %xmm2,%xmm1\nucomisd %xmm1,%xmm3\njbe    3f <func0+0x3f>\ncvttsd2si %xmm0,%rax\npxor   %xmm1,%xmm1\nmovapd %xmm0,%xmm3\nmovsd  0x0(%rip),%xmm4\n00\nandnpd %xmm0,%xmm2\nadd    $0x8,%rsp\nmovapd %xmm2,%xmm0\ncvtsi2sd %rax,%xmm1\ncmpnlesd %xmm1,%xmm3\nandpd  %xmm4,%xmm3\naddsd  %xmm3,%xmm1\norpd   %xmm1,%xmm0\ncvttsd2si %xmm0,%eax\nretq"
    },
    {
        "task_id": 100,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  20 <func0+0x20>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmovl   $0x1,-0xc(%rbp)\njmp    69 <func0+0x69>\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nadd    $0x2,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     36 <func0+0x36>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 100,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  13 <func0+0x13>\nmov    %ebx,(%rax)\ncmp    $0x1,%ebx\njle    36 <func0+0x36>\nmov    %rax,%rdx\nlea    -0x2(%rbx),%ecx\nlea    0x4(%rax,%rcx,4),%rsi\nmov    (%rdx),%ebx\nlea    0x2(%rbx),%ecx\nmov    %ecx,0x4(%rdx)\nadd    $0x4,%rdx\ncmp    %rsi,%rdx\njne    25 <func0+0x25>\npop    %rbx\nretq"
    },
    {
        "task_id": 100,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmovslq %edi,%rdi\nmov    %rdi,%rbx\nshl    $0x2,%rdi\ncallq  14 <func0+0x14>\nmov    %ebx,(%rax)\ncmp    $0x1,%ebx\njle    3e <func0+0x3e>\nlea    -0x2(%rbx),%ecx\nlea    0x4(%rax),%rdx\nlea    0x4(%rax,%rcx,4),%rcx\njmp    34 <func0+0x34>\nnopl   0x0(%rax)\nadd    $0x4,%rdx\nadd    $0x2,%ebx\nmov    %ebx,(%rdx)\ncmp    %rcx,%rdx\njne    30 <func0+0x30>\npop    %rbx\nretq"
    },
    {
        "task_id": 100,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmovslq %edi,%rdi\nmov    %rdi,%rbx\nshl    $0x2,%rdi\ncallq  14 <func0+0x14>\nmov    %ebx,(%rax)\ncmp    $0x1,%ebx\njle    35 <func0+0x35>\nlea    0x2(%rbx),%edx\nlea    0x4(%rax),%rcx\nlea    (%rbx,%rbx,2),%esi\nnopl   (%rax)\nmov    %edx,(%rcx)\nadd    $0x2,%edx\nadd    $0x4,%rcx\ncmp    %esi,%edx\njne    28 <func0+0x28>\npop    %rbx\nretq"
    },
    {
        "task_id": 101,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmovl   $0xa,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncallq  2d <func0+0x2d>\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncallq  3d <func0+0x3d>\nadd    $0x1,%rax\nmov    %rax,%rdi\ncallq  49 <func0+0x49>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmpq   134 <func0+0x134>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     8f <func0+0x8f>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2c,%al\njne    107 <func0+0x107>\ncmpl   $0x0,-0x28(%rbp)\njle    12f <func0+0x12f>\nmov    -0x28(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x2c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x2c(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  d0 <func0+0xd0>\nmov    %rax,(%rbx)\nmovl   $0x0,-0x28(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     12f <func0+0x12f>\nshll   -0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  101 <func0+0x101>\nmov    %rax,-0x20(%rbp)\njmp    12f <func0+0x12f>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x28(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x28(%rbp)\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmovzbl (%rcx),%eax\nmov    %al,(%rdx)\njmp    130 <func0+0x130>\nnop\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    67 <func0+0x67>\ncmpl   $0x0,-0x28(%rbp)\njle    18c <func0+0x18c>\nmov    -0x28(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x2c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x2c(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  189 <func0+0x189>\nmov    %rax,(%rbx)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  198 <func0+0x198>\nmov    -0x40(%rbp),%rax\nmov    -0x2c(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 101,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%rbx\nmov    %rsi,0x8(%rsp)\nmov    $0x50,%edi\ncallq  24 <func0+0x24>\nmov    %rax,%r13\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nmov    %rbx,%rdi\nrepnz scas %es:(%rdi),%al\nmov    %rcx,%rdi\nnot    %rdi\ncallq  43 <func0+0x43>\nmov    %rax,%r12\nmovzbl (%rbx),%eax\ntest   %al,%al\nje     112 <func0+0x112>\nadd    $0x1,%rbx\nmov    $0x0,%edx\nmov    $0x0,%ebp\nmov    $0xa,%r15d\njmp    7d <func0+0x7d>\nmovslq %edx,%rcx\nmov    %al,(%r12,%rcx,1)\nlea    0x1(%rdx),%edx\nadd    $0x1,%rbx\nmovzbl -0x1(%rbx),%eax\ntest   %al,%al\nje     ce <func0+0xce>\ncmp    $0x20,%al\nje     85 <func0+0x85>\ncmp    $0x2c,%al\njne    67 <func0+0x67>\ntest   %edx,%edx\njle    71 <func0+0x71>\nmovslq %edx,%rdx\nmovb   $0x0,(%r12,%rdx,1)\nlea    0x1(%rbp),%r14d\nmov    %r12,%rdi\ncallq  9d <func0+0x9d>\nmovslq %ebp,%rbp\nmov    %rax,0x0(%r13,%rbp,8)\nmov    %r14d,%ebp\nmov    $0x0,%edx\ncmp    %r15d,%r14d\njl     71 <func0+0x71>\nadd    %r15d,%r15d\nmovslq %r15d,%rsi\nshl    $0x3,%rsi\nmov    %r13,%rdi\ncallq  c4 <func0+0xc4>\nmov    %rax,%r13\nmov    $0x0,%edx\njmp    71 <func0+0x71>\ntest   %edx,%edx\njg     f3 <func0+0xf3>\nmov    %r12,%rdi\ncallq  da <func0+0xda>\nmov    0x8(%rsp),%rax\nmov    %ebp,(%rax)\nmov    %r13,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmovslq %edx,%rdx\nmovb   $0x0,(%r12,%rdx,1)\nlea    0x1(%rbp),%ebx\nmov    %r12,%rdi\ncallq  106 <func0+0x106>\nmovslq %ebp,%rbp\nmov    %rax,0x0(%r13,%rbp,8)\nmov    %ebx,%ebp\njmp    d2 <func0+0xd2>\nmov    $0x0,%ebp\njmp    d2 <func0+0xd2>"
    },
    {
        "task_id": 101,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    $0x50,%edi\nsub    $0x18,%rsp\nmov    %rsi,0x8(%rsp)\ncallq  24 <func0+0x24>\nmov    %rbx,%rdi\nmov    %rax,%r12\ncallq  2f <func0+0x2f>\nlea    0x1(%rax),%rdi\ncallq  38 <func0+0x38>\nmov    %rax,%r14\nmovzbl (%rbx),%eax\ntest   %al,%al\nje     110 <func0+0x110>\nadd    $0x1,%rbx\nxor    %ebp,%ebp\nxor    %r15d,%r15d\nmov    $0xa,%r13d\njmp    75 <func0+0x75>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovslq %ebp,%rdx\nadd    $0x1,%ebp\nmov    %al,(%r14,%rdx,1)\nmovzbl (%rbx),%eax\nadd    $0x1,%rbx\ntest   %al,%al\nje     c8 <func0+0xc8>\ncmp    $0x20,%al\nje     7d <func0+0x7d>\ncmp    $0x2c,%al\njne    60 <func0+0x60>\ntest   %ebp,%ebp\nje     6a <func0+0x6a>\nmovslq %ebp,%rbp\nmov    %r14,%rdi\nmovb   $0x0,(%r14,%rbp,1)\nlea    0x1(%r15),%ebp\ncallq  95 <func0+0x95>\nmov    %rax,(%r12,%r15,8)\nmovslq %ebp,%r15\nxor    %ebp,%ebp\ncmp    %r13d,%r15d\njl     6a <func0+0x6a>\nadd    %r13d,%r13d\nmov    %r12,%rdi\nadd    $0x1,%rbx\nmovslq %r13d,%rsi\nshl    $0x3,%rsi\ncallq  b9 <func0+0xb9>\nmov    %rax,%r12\nmovzbl -0x1(%rbx),%eax\ntest   %al,%al\njne    75 <func0+0x75>\nnopl   0x0(%rax)\ntest   %ebp,%ebp\njne    f0 <func0+0xf0>\nmov    %r14,%rdi\ncallq  d4 <func0+0xd4>\nmov    0x8(%rsp),%rax\nmov    %r15d,(%rax)\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nxchg   %ax,%ax\nmovslq %ebp,%rbp\nmov    %r14,%rdi\nlea    0x1(%r15),%ebx\nmovb   $0x0,(%r14,%rbp,1)\ncallq  104 <func0+0x104>\nmov    %rax,(%r12,%r15,8)\nmov    %ebx,%r15d\njmp    cc <func0+0xcc>\nnopl   (%rax)\nxor    %r15d,%r15d\njmp    cc <func0+0xcc>"
    },
    {
        "task_id": 101,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    $0x50,%edi\nsub    $0x18,%rsp\nmov    %rsi,0x8(%rsp)\ncallq  24 <func0+0x24>\nmov    %rbx,%rdi\nmov    %rax,%r12\ncallq  2f <func0+0x2f>\nlea    0x1(%rax),%rdi\ncallq  38 <func0+0x38>\nmov    %rax,%r14\nmovzbl (%rbx),%eax\ntest   %al,%al\nje     110 <func0+0x110>\nadd    $0x1,%rbx\nxor    %ebp,%ebp\nxor    %r15d,%r15d\nmov    $0xa,%r13d\njmp    75 <func0+0x75>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovslq %ebp,%rdx\nadd    $0x1,%ebp\nmov    %al,(%r14,%rdx,1)\nmovzbl (%rbx),%eax\nadd    $0x1,%rbx\ntest   %al,%al\nje     c8 <func0+0xc8>\ncmp    $0x20,%al\nje     7d <func0+0x7d>\ncmp    $0x2c,%al\njne    60 <func0+0x60>\ntest   %ebp,%ebp\nje     6a <func0+0x6a>\nmovslq %ebp,%rbp\nmov    %r14,%rdi\nmovb   $0x0,(%r14,%rbp,1)\nlea    0x1(%r15),%ebp\ncallq  95 <func0+0x95>\nmov    %rax,(%r12,%r15,8)\nmovslq %ebp,%r15\nxor    %ebp,%ebp\ncmp    %r13d,%r15d\njl     6a <func0+0x6a>\nadd    %r13d,%r13d\nmov    %r12,%rdi\nadd    $0x1,%rbx\nmovslq %r13d,%rsi\nshl    $0x3,%rsi\ncallq  b9 <func0+0xb9>\nmov    %rax,%r12\nmovzbl -0x1(%rbx),%eax\ntest   %al,%al\njne    75 <func0+0x75>\nnopl   0x0(%rax)\ntest   %ebp,%ebp\njne    f0 <func0+0xf0>\nmov    %r14,%rdi\ncallq  d4 <func0+0xd4>\nmov    0x8(%rsp),%rax\nmov    %r15d,(%rax)\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nxchg   %ax,%ax\nmovslq %ebp,%rbp\nmov    %r14,%rdi\nlea    0x1(%r15),%ebx\nmovb   $0x0,(%r14,%rbp,1)\ncallq  104 <func0+0x104>\nmov    %rax,(%r12,%r15,8)\nmov    %ebx,%r15d\njmp    cc <func0+0xcc>\nnopl   (%rax)\nxor    %r15d,%r15d\njmp    cc <func0+0xcc>"
    },
    {
        "task_id": 102,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njge    1d <func0+0x1d>\nmov    $0xffffffff,%eax\njmp    5d <func0+0x5d>\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njne    3f <func0+0x3f>\nmov    -0x8(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    3f <func0+0x3f>\nmov    $0xffffffff,%eax\njmp    5d <func0+0x5d>\nmov    -0x8(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    5a <func0+0x5a>\nmov    -0x8(%rbp),%eax\nsub    $0x1,%eax\njmp    5d <func0+0x5d>\nmov    -0x8(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 102,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%eax\ncmp    %edi,%esi\njl     3e <func0+0x3e>\nje     25 <func0+0x25>\nmov    %esi,%ecx\nshr    $0x1f,%ecx\nlea    (%rsi,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\nsete   %dl\nmovzbl %dl,%edx\nsub    %edx,%eax\nretq\nmov    %esi,%ecx\nshr    $0x1f,%ecx\nlea    (%rsi,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\nmov    $0xffffffff,%edx\ncmove  %edx,%eax\nretq\nmov    $0xffffffff,%eax\nretq"
    },
    {
        "task_id": 102,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%eax\ncmp    %edi,%esi\njl     40 <func0+0x40>\nmov    %esi,%ecx\nshr    $0x1f,%ecx\nlea    (%rsi,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    %edi,%esi\nje     30 <func0+0x30>\ncmp    $0x1,%edx\nsete   %dl\nmovzbl %dl,%edx\nsub    %edx,%eax\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    $0x1,%edx\nmov    $0xffffffff,%edx\ncmove  %edx,%eax\nretq\nnopl   0x0(%rax)\nmov    $0xffffffff,%eax\nretq"
    },
    {
        "task_id": 102,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %esi,%eax\ncmp    %edi,%esi\njl     40 <func0+0x40>\nmov    %esi,%ecx\nshr    $0x1f,%ecx\nlea    (%rsi,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    %edi,%esi\nje     30 <func0+0x30>\ncmp    $0x1,%edx\nsete   %dl\nmovzbl %dl,%edx\nsub    %edx,%eax\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\ncmp    $0x1,%edx\nmov    $0xffffffff,%edx\ncmove  %edx,%eax\nretq\nnopl   0x0(%rax)\nmov    $0xffffffff,%eax\nretq"
    },
    {
        "task_id": 103,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njle    26 <func0+0x26>\nlea    0x0(%rip),%rax\njmpq   b9 <func0+0xb9>\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x10(%rbp)\nmov    $0x21,%edi\ncallq  44 <func0+0x44>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovb   $0x0,(%rax)\nmovl   $0x20,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x10(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\nlea    0x30(%rax),%ecx\nmov    -0xc(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\nmov    -0x10(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njg     6c <func0+0x6c>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nleaveq\nretq"
    },
    {
        "task_id": 103,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    0x0(%rip),%rax\ncmp    %esi,%edi\njle    10 <func0+0x10>\nretq\npush   %rbx\nadd    %esi,%edi\nmov    %edi,%ebx\nshr    $0x1f,%ebx\nadd    %edi,%ebx\nsar    %ebx\nmov    $0x21,%edi\ncallq  26 <func0+0x26>\nmovb   $0x0,(%rax)\nmovb   $0x0,0x20(%rax)\nmov    $0x1e,%ecx\nmov    %ecx,%edi\nmov    %ebx,%esi\nshr    $0x1f,%esi\nlea    (%rbx,%rsi,1),%edx\nand    $0x1,%edx\nsub    %esi,%edx\nadd    $0x30,%edx\nmov    %dl,0x1(%rax,%rcx,1)\nmov    %ebx,%esi\nmov    %ebx,%edx\nshr    $0x1f,%edx\nadd    %edx,%ebx\nsar    %ebx\nsub    $0x1,%rcx\ncmp    $0x1,%esi\njg     32 <func0+0x32>\nmovslq %edi,%rdi\nlea    0x1(%rax,%rdi,1),%rax\npop    %rbx\nretq"
    },
    {
        "task_id": 103,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %esi,%edi\njle    10 <func0+0x10>\nlea    0x0(%rip),%rax\nretq\nadd    %esi,%edi\npush   %rbx\nmov    %edi,%ebx\nshr    $0x1f,%ebx\nadd    %edi,%ebx\nmov    $0x21,%edi\ncallq  24 <func0+0x24>\nsar    %ebx\nmov    $0x1e,%ecx\nmovb   $0x0,(%rax)\nmovb   $0x0,0x20(%rax)\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%esi\nmovslq %ecx,%rdi\nshr    $0x1f,%esi\nlea    (%rbx,%rsi,1),%edx\nand    $0x1,%edx\nsub    %esi,%edx\nadd    $0x30,%edx\nmov    %dl,0x1(%rax,%rcx,1)\nmov    %ebx,%edx\nmov    %esi,%ebx\nsub    $0x1,%rcx\nadd    %edx,%ebx\nsar    %ebx\ncmp    $0x1,%edx\njg     38 <func0+0x38>\nlea    0x1(%rax,%rdi,1),%rax\npop    %rbx\nretq"
    },
    {
        "task_id": 103,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %esi,%edi\njle    10 <func0+0x10>\nlea    0x0(%rip),%rax\nretq\nadd    %esi,%edi\npush   %rbx\nmov    %edi,%ebx\nshr    $0x1f,%ebx\nadd    %edi,%ebx\nmov    $0x21,%edi\ncallq  24 <func0+0x24>\nsar    %ebx\nmov    $0x1e,%ecx\nmovb   $0x0,(%rax)\nmovb   $0x0,0x20(%rax)\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%esi\nmovslq %ecx,%rdi\nshr    $0x1f,%esi\nlea    (%rbx,%rsi,1),%edx\nand    $0x1,%edx\nsub    %esi,%edx\nadd    $0x30,%edx\nmov    %dl,0x1(%rax,%rcx,1)\nmov    %ebx,%edx\nmov    %esi,%ebx\nsub    $0x1,%rcx\nadd    %edx,%ebx\nsar    %ebx\ncmp    $0x1,%edx\njg     38 <func0+0x38>\nlea    0x1(%rax,%rdi,1),%rax\npop    %rbx\nretq"
    },
    {
        "task_id": 104,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %rcx,-0x40(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  2c <func0+0x2c>\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x40(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x14(%rbp)\njmpq   ff <func0+0xff>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\nmovb   $0x0,-0x15(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njne    a1 <func0+0xa1>\nmovb   $0x1,-0x15(%rbp)\njmp    a1 <func0+0xa1>\nmov    -0x10(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    83 <func0+0x83>\nmovb   $0x1,-0x15(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nmov    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njle    b2 <func0+0xb2>\nmovzbl -0x15(%rbp),%eax\nxor    $0x1,%eax\ntest   %al,%al\njne    75 <func0+0x75>\nmovzbl -0x15(%rbp),%eax\nxor    $0x1,%eax\ntest   %al,%al\nje     fb <func0+0xfb>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x40(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x2,%rax\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\nmov    -0x40(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x40(%rbp),%rax\nmov    %edx,(%rax)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     4c <func0+0x4c>\nmovl   $0x0,-0xc(%rbp)\njmpq   1db <func0+0x1db>\nmovl   $0x0,-0x8(%rbp)\njmpq   1c2 <func0+0x1c2>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x8(%rbp),%ecx\nmovslq %ecx,%rcx\nadd    $0x1,%rcx\nshl    $0x2,%rcx\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    1be <func0+0x1be>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nshl    $0x2,%rdx\nlea    (%rax,%rdx,1),%rcx\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rax,%rdx\nmov    (%rcx),%eax\nmov    %eax,(%rdx)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nshl    $0x2,%rdx\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x40(%rbp),%rax\nmov    (%rax),%eax\nsub    -0xc(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x8(%rbp)\njl     123 <func0+0x123>\naddl   $0x1,-0xc(%rbp)\nmov    -0x40(%rbp),%rax\nmov    (%rax),%eax\nsub    $0x1,%eax\ncmp    %eax,-0xc(%rbp)\njl     117 <func0+0x117>\nnop\nnop\nleaveq\nretq"
    },
    {
        "task_id": 104,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r13\nmov    %esi,%r12d\nmov    %rdx,%rbx\nmov    %rcx,%rbp\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncallq  26 <func0+0x26>\nmov    %rax,(%rbx)\nmovl   $0x0,0x0(%rbp)\ntest   %r12d,%r12d\njle    ef <func0+0xef>\nmov    %r13,%rsi\nlea    -0x1(%r12),%eax\nlea    0x4(%r13,%rax,4),%r8\njmp    72 <func0+0x72>\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\ncmp    $0x9,%edx\njle    7e <func0+0x7e>\nmov    %eax,%edx\ntest   $0x1,%dl\njne    48 <func0+0x48>\nadd    $0x4,%rsi\ncmp    %rsi,%r8\nje     8e <func0+0x8e>\nmov    (%rsi),%edi\ntest   %edi,%edi\njle    7c <func0+0x7c>\nmov    %edi,%edx\njmp    64 <func0+0x64>\nje     69 <func0+0x69>\nmovslq 0x0(%rbp),%rdx\nmov    (%rbx),%rax\nmov    %edi,(%rax,%rdx,4)\naddl   $0x1,0x0(%rbp)\njmp    69 <func0+0x69>\ncmpl   $0x1,0x0(%rbp)\njle    ef <func0+0xef>\nmov    $0x0,%r8d\njmp    d8 <func0+0xd8>\nadd    $0x1,%ecx\nmov    %r8d,%edx\nnot    %edx\nadd    0x0(%rbp),%edx\ncmp    %ecx,%edx\njle    c9 <func0+0xc9>\nmov    (%rbx),%rdx\nlea    (%rdx,%rax,1),%rdi\nmov    (%rdi),%esi\nadd    $0x4,%rax\nmov    (%rdx,%rax,1),%edx\ncmp    %edx,%esi\njle    9c <func0+0x9c>\nmov    %edx,(%rdi)\nmov    (%rbx),%rdx\nmov    %esi,(%rdx,%rax,1)\njmp    9c <func0+0x9c>\nadd    $0x1,%r8d\nmov    0x0(%rbp),%eax\nsub    $0x1,%eax\ncmp    %r8d,%eax\njle    ef <func0+0xef>\nmov    0x0(%rbp),%edx\nsub    %r8d,%edx\nmov    $0x0,%eax\nmov    $0x0,%ecx\ncmp    $0x1,%edx\njg     ab <func0+0xab>\njmp    c9 <func0+0xc9>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 104,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nmov    %rdx,%r13\npush   %r12\npush   %rbp\nmov    %rcx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nshl    $0x2,%rdi\nsub    $0x8,%rsp\ncallq  26 <func0+0x26>\nmov    %rax,0x0(%r13)\nmovl   $0x0,0x0(%rbp)\ntest   %r12d,%r12d\njle    cf <func0+0xcf>\nlea    -0x1(%r12),%edx\nmov    %rbx,%r10\nxor    %r8d,%r8d\nmov    $0xcccccccd,%r9d\nlea    0x4(%rbx,%rdx,4),%rcx\nmov    (%r10),%r11d\ntest   %r11d,%r11d\nje     86 <func0+0x86>\njle    e5 <func0+0xe5>\nmov    %r11d,%edx\nnopl   0x0(%rax)\nmov    %edx,%esi\nmov    %edx,%edx\nmov    %rdx,%rdi\nimul   %r9,%rdx\nnot    %esi\nand    $0x1,%esi\nshr    $0x23,%rdx\ncmp    $0x9,%edi\njle    e0 <func0+0xe0>\ntest   %sil,%sil\nje     68 <func0+0x68>\nadd    $0x4,%r10\ncmp    %rcx,%r10\njne    50 <func0+0x50>\nlea    -0x1(%r8),%ecx\ntest   %ecx,%ecx\njle    cf <func0+0xcf>\nlea    0x4(%rax),%r9\nnopl   0x0(%rax,%rax,1)\nsub    $0x1,%ecx\nmov    %rax,%rdx\nmov    %rcx,%r8\nlea    (%r9,%rcx,4),%rdi\nnopl   (%rax)\nmov    (%rdx),%ecx\nmov    0x4(%rdx),%esi\ncmp    %esi,%ecx\njle    be <func0+0xbe>\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nadd    $0x4,%rdx\ncmp    %rdx,%rdi\njne    b0 <func0+0xb0>\nmov    %r8d,%ecx\ntest   %r8d,%r8d\njne    a0 <func0+0xa0>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopw   0x0(%rax,%rax,1)\ntest   %sil,%sil\njne    86 <func0+0x86>\nmovslq %r8d,%rdx\nadd    $0x4,%r10\nadd    $0x1,%r8d\nmov    %r11d,(%rax,%rdx,4)\nmov    %r8d,0x0(%rbp)\ncmp    %rcx,%r10\njne    50 <func0+0x50>\njmp    8f <func0+0x8f>"
    },
    {
        "task_id": 104,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nmov    %rdx,%r13\npush   %r12\npush   %rbp\nmov    %rcx,%rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%r12\nshl    $0x2,%rdi\nsub    $0x8,%rsp\ncallq  26 <func0+0x26>\nmov    %rax,0x0(%r13)\nmovl   $0x0,0x0(%rbp)\ntest   %r12d,%r12d\njle    cf <func0+0xcf>\nlea    -0x1(%r12),%edx\nmov    %rbx,%r10\nxor    %r8d,%r8d\nmov    $0xcccccccd,%r9d\nlea    0x4(%rbx,%rdx,4),%rcx\nmov    (%r10),%r11d\ntest   %r11d,%r11d\nje     86 <func0+0x86>\njle    e5 <func0+0xe5>\nmov    %r11d,%edx\nnopl   0x0(%rax)\nmov    %edx,%esi\nmov    %edx,%edx\nmov    %rdx,%rdi\nimul   %r9,%rdx\nnot    %esi\nand    $0x1,%esi\nshr    $0x23,%rdx\ncmp    $0x9,%edi\njle    e0 <func0+0xe0>\ntest   %sil,%sil\nje     68 <func0+0x68>\nadd    $0x4,%r10\ncmp    %r10,%rcx\njne    50 <func0+0x50>\nlea    -0x1(%r8),%ecx\ntest   %ecx,%ecx\njle    cf <func0+0xcf>\nlea    0x4(%rax),%r9\nnopl   0x0(%rax,%rax,1)\nsub    $0x1,%ecx\nmov    %rax,%rdx\nmov    %rcx,%r8\nlea    (%r9,%rcx,4),%rdi\nnopl   (%rax)\nmov    (%rdx),%ecx\nmov    0x4(%rdx),%esi\ncmp    %esi,%ecx\njle    be <func0+0xbe>\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nadd    $0x4,%rdx\ncmp    %rdx,%rdi\njne    b0 <func0+0xb0>\nmov    %r8d,%ecx\ntest   %r8d,%r8d\njne    a0 <func0+0xa0>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopw   0x0(%rax,%rax,1)\ntest   %sil,%sil\njne    86 <func0+0x86>\nmovslq %r8d,%rdx\nadd    $0x4,%r10\nadd    $0x1,%r8d\nmov    %r11d,(%rax,%rdx,4)\nmov    %r8d,0x0(%rbp)\ncmp    %r10,%rcx\njne    50 <func0+0x50>\njmp    8f <func0+0x8f>"
    },
    {
        "task_id": 105,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x90,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %esi,-0x7c(%rbp)\nmov    %rdx,-0x88(%rbp)\nmov    %rcx,-0x90(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %rax,-0x60(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x58(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x50(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x48(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x6c(%rbp)\njmpq   16e <func0+0x16e>\nmovl   $0x0,-0x68(%rbp)\njmpq   158 <func0+0x158>\nmov    -0x68(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x68(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x78(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    154 <func0+0x154>\nmov    -0x68(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x64(%rbp)\nmov    -0x68(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x68(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x78(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x64(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x68(%rbp)\nmov    -0x7c(%rbp),%eax\nsub    -0x6c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x68(%rbp)\njl     b9 <func0+0xb9>\naddl   $0x1,-0x6c(%rbp)\nmov    -0x7c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x6c(%rbp)\njl     ad <func0+0xad>\nmov    -0x90(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    -0x7c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x6c(%rbp)\njmp    1e3 <func0+0x1e3>\nmov    -0x6c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njle    1df <func0+0x1df>\nmov    -0x6c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    $0x9,%eax\njg     1df <func0+0x1df>\nmov    -0x90(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x90(%rbp),%rax\nmov    %edx,(%rax)\nsubl   $0x1,-0x6c(%rbp)\ncmpl   $0x0,-0x6c(%rbp)\njns    195 <func0+0x195>\nmov    -0x90(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncallq  200 <func0+0x200>\nmov    %rax,%rdx\nmov    -0x88(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x7c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x6c(%rbp)\nmovl   $0x0,-0x68(%rbp)\njmp    296 <func0+0x296>\nmov    -0x6c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njle    292 <func0+0x292>\nmov    -0x6c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    $0x9,%eax\njg     292 <func0+0x292>\nmov    -0x6c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x88(%rbp),%rax\nmov    (%rax),%rsi\nmov    -0x68(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x68(%rbp)\ncltq\nshl    $0x3,%rax\nlea    (%rsi,%rax,1),%rdx\nmovslq %ecx,%rax\nmov    -0x60(%rbp,%rax,8),%rax\nmov    %rax,(%rdx)\nsubl   $0x1,-0x6c(%rbp)\ncmpl   $0x0,-0x6c(%rbp)\njs     2ae <func0+0x2ae>\nmov    -0x90(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x68(%rbp)\njl     21f <func0+0x21f>\nnop\nmov    -0x8(%rbp),%rax\nxor    %fs:0x28,%rax\n00 00\nje     2c3 <func0+0x2c3>\ncallq  2c3 <func0+0x2c3>\nleaveq\nretq"
    },
    {
        "task_id": 105,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,%rbx\nmov    %rdx,%r12\nmov    %rcx,%rbp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %rax,(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x10(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x18(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x30(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x48(%rsp)\nlea    -0x1(%rsi),%r13d\ntest   %r13d,%r13d\njle    e2 <func0+0xe2>\nmov    %r13d,%edi\nlea    0x4(%rbx),%r8\njmp    d2 <func0+0xd2>\nadd    $0x4,%rax\ncmp    %rsi,%rax\nje     c9 <func0+0xc9>\nmov    (%rax),%edx\nmov    0x4(%rax),%ecx\ncmp    %ecx,%edx\njle    b0 <func0+0xb0>\nmov    %ecx,(%rax)\nmov    %edx,0x4(%rax)\njmp    b0 <func0+0xb0>\nsub    $0x1,%edi\nje     178 <func0+0x178>\ntest   %edi,%edi\njle    c9 <func0+0xc9>\nmov    %rbx,%rax\nlea    -0x1(%rdi),%edx\nlea    (%r8,%rdx,4),%rsi\njmp    b9 <func0+0xb9>\nmovl   $0x0,(%rcx)\nje     17f <func0+0x17f>\nmov    $0x0,%edi\ncallq  f8 <func0+0xf8>\nmov    %rax,(%r12)\nmov    0x58(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    187 <func0+0x187>\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nsub    $0x1,%rax\ntest   %eax,%eax\njs     160 <func0+0x160>\nmov    (%rbx,%rax,4),%edi\nlea    -0x1(%rdi),%edx\ncmp    $0x8,%edx\nja     117 <func0+0x117>\naddl   $0x1,0x0(%rbp)\njmp    117 <func0+0x117>\nsub    $0x1,%r13\ntest   %r13d,%r13d\njs     fc <func0+0xfc>\ncmp    %edx,0x0(%rbp)\njle    fc <func0+0xfc>\nmov    (%rbx,%r13,4),%eax\nlea    -0x1(%rax),%ecx\ncmp    $0x8,%ecx\nja     130 <func0+0x130>\nmovslq %edx,%rsi\nmov    (%r12),%rcx\ncltq\nmov    (%rsp,%rax,8),%rax\nmov    %rax,(%rcx,%rsi,8)\nlea    0x1(%rdx),%edx\njmp    130 <func0+0x130>\nmovslq 0x0(%rbp),%rdi\nshl    $0x3,%rdi\ncallq  16d <func0+0x16d>\nmov    %rax,(%r12)\nmov    $0x0,%edx\njmp    139 <func0+0x139>\nmovl   $0x0,0x0(%rbp)\nmovslq %r13d,%r13\nmov    %r13,%rax\njmp    11f <func0+0x11f>\ncallq  18c <.LC9+0x163>"
    },
    {
        "task_id": 105,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nmov    %rcx,%r13\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nlea    -0x1(%rsi),%ebx\nsub    $0x68,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %rax,(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x10(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x18(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x30(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x48(%rsp)\ntest   %ebx,%ebx\njle    172 <func0+0x172>\nmov    %ebx,%esi\nlea    0x4(%rdi),%rcx\nnop\nlea    -0x1(%rsi),%edx\nmov    %rbp,%rax\nmov    %rdx,%r9\nlea    (%rcx,%rdx,4),%r8\nnopl   (%rax)\nmov    (%rax),%esi\nmov    0x4(%rax),%edi\ncmp    %edi,%esi\njle    ce <func0+0xce>\nmov    %edi,(%rax)\nmov    %esi,0x4(%rax)\nadd    $0x4,%rax\ncmp    %rax,%r8\njne    c0 <func0+0xc0>\nmov    %r9d,%esi\ntest   %r9d,%r9d\njne    b0 <func0+0xb0>\nmovl   $0x0,0x0(%r13)\n00\nmovslq %ebx,%rbx\nxor    %ecx,%ecx\nmov    %rbx,%rax\nnop\nmov    0x0(%rbp,%rax,4),%edx\nsub    $0x1,%edx\ncmp    $0x8,%edx\nja     103 <func0+0x103>\nadd    $0x1,%ecx\nmov    %ecx,0x0(%r13)\nsub    $0x1,%rax\ntest   %eax,%eax\njns    f0 <func0+0xf0>\nmovslq %ecx,%rcx\nlea    0x0(,%rcx,8),%rdi\n00\ncallq  11b <func0+0x11b>\nmov    0x0(%r13),%edi\nxor    %ecx,%ecx\nmov    %rax,(%r12)\njmp    153 <func0+0x153>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovslq 0x0(%rbp,%rbx,4),%rdx\nlea    -0x1(%rdx),%esi\ncmp    $0x8,%esi\nja     14b <func0+0x14b>\nmov    (%rsp,%rdx,8),%rdx\nmovslq %ecx,%rsi\nadd    $0x1,%ecx\nmov    %rdx,(%rax,%rsi,8)\nsub    $0x1,%rbx\ntest   %ebx,%ebx\njs     157 <func0+0x157>\ncmp    %ecx,%edi\njg     130 <func0+0x130>\nmov    0x58(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    18b <func0+0x18b>\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nmovl   $0x0,(%rcx)\nje     e7 <func0+0xe7>\nxor    %edi,%edi\ncallq  185 <func0+0x185>\nmov    %rax,(%r12)\njmp    157 <func0+0x157>\ncallq  190 <.LC9+0x167>"
    },
    {
        "task_id": 105,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nmov    %rcx,%r13\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nlea    0x0(%rip),%rbx\nmovq   %rbx,%xmm0\nlea    0x0(%rip),%rbx\nsub    $0x68,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmovq   %rax,%xmm1\nlea    0x0(%rip),%rax\npunpcklqdq %xmm1,%xmm0\nmovq   %rax,%xmm2\nlea    0x0(%rip),%rax\nmovaps %xmm0,(%rsp)\nmovq   %rbx,%xmm0\nlea    0x0(%rip),%rbx\nmovq   %rax,%xmm3\npunpcklqdq %xmm2,%xmm0\nlea    0x0(%rip),%rax\nmovaps %xmm0,0x10(%rsp)\nmovq   %rbx,%xmm0\nmovq   %rax,%xmm4\nlea    0x0(%rip),%rbx\npunpcklqdq %xmm3,%xmm0\nlea    0x0(%rip),%rax\nmovaps %xmm0,0x20(%rsp)\nmovq   %rbx,%xmm0\nmovq   %rax,%xmm5\nlea    0x0(%rip),%rbx\npunpcklqdq %xmm4,%xmm0\nmovaps %xmm0,0x30(%rsp)\nmovq   %rbx,%xmm0\nlea    -0x1(%rsi),%ebx\npunpcklqdq %xmm5,%xmm0\nmovaps %xmm0,0x40(%rsp)\ntest   %ebx,%ebx\njle    1a2 <func0+0x1a2>\nmov    %ebx,%esi\nlea    0x4(%rdi),%rcx\nnopl   0x0(%rax)\nlea    -0x1(%rsi),%edx\nmov    %rbp,%rax\nmov    %rdx,%r9\nlea    (%rcx,%rdx,4),%r8\nnopl   (%rax)\nmov    (%rax),%esi\nmov    0x4(%rax),%edi\ncmp    %edi,%esi\njle    fe <func0+0xfe>\nmov    %edi,(%rax)\nmov    %esi,0x4(%rax)\nadd    $0x4,%rax\ncmp    %r8,%rax\njne    f0 <func0+0xf0>\nmov    %r9d,%esi\ntest   %r9d,%r9d\njne    e0 <func0+0xe0>\nmovl   $0x0,0x0(%r13)\n00\nmovslq %ebx,%rbx\nxor    %ecx,%ecx\nmov    %rbx,%rax\nnop\nmov    0x0(%rbp,%rax,4),%edx\nsub    $0x1,%edx\ncmp    $0x8,%edx\nja     133 <func0+0x133>\nadd    $0x1,%ecx\nmov    %ecx,0x0(%r13)\nsub    $0x1,%rax\ntest   %eax,%eax\njns    120 <func0+0x120>\nmovslq %ecx,%rcx\nlea    0x0(,%rcx,8),%rdi\n00\ncallq  14b <func0+0x14b>\nmov    0x0(%r13),%edi\nxor    %ecx,%ecx\nmov    %rax,(%r12)\njmp    183 <func0+0x183>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovslq 0x0(%rbp,%rbx,4),%rdx\nlea    -0x1(%rdx),%esi\ncmp    $0x8,%esi\nja     17b <func0+0x17b>\nmov    (%rsp,%rdx,8),%rdx\nmovslq %ecx,%rsi\nadd    $0x1,%ecx\nmov    %rdx,(%rax,%rsi,8)\nsub    $0x1,%rbx\ntest   %ebx,%ebx\njs     187 <func0+0x187>\ncmp    %ecx,%edi\njg     160 <func0+0x160>\nmov    0x58(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    1bb <func0+0x1bb>\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nmovl   $0x0,(%rcx)\nje     117 <func0+0x117>\nxor    %edi,%edi\ncallq  1b5 <func0+0x1b5>\nmov    %rax,(%r12)\njmp    187 <func0+0x187>\ncallq  1c0 <.LC9+0x197>"
    },
    {
        "task_id": 106,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  20 <func0+0x20>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x1,-0xc(%rbp)\njmp    8d <func0+0x8d>\nmov    -0xc(%rbp),%eax\nadd    %eax,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nimul   -0xc(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0xc(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    70 <func0+0x70>\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%eax\nmov    %eax,(%rdx)\njmp    89 <func0+0x89>\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    3b <func0+0x3b>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 106,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  13 <func0+0x13>\ntest   %ebx,%ebx\njle    48 <func0+0x48>\nlea    -0x1(%rbx),%r8d\nadd    $0x2,%r8\nmov    $0x1,%edx\nmov    $0x1,%esi\nmov    $0x0,%ecx\nadd    %edx,%ecx\nimul   %edx,%esi\ntest   $0x1,%dl\nmov    %esi,%edi\ncmovne %ecx,%edi\nmov    %edi,-0x4(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %r8,%rdx\njne    2e <func0+0x2e>\npop    %rbx\nretq"
    },
    {
        "task_id": 106,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmovslq %edi,%rdi\nmov    %rdi,%rbx\nshl    $0x2,%rdi\ncallq  14 <func0+0x14>\ntest   %ebx,%ebx\njle    4a <func0+0x4a>\nlea    -0x1(%rbx),%r8d\nmov    $0x1,%edx\nmov    $0x1,%esi\nxor    %ecx,%ecx\nadd    $0x2,%r8\nnopl   0x0(%rax)\nimul   %edx,%esi\nadd    %edx,%ecx\ntest   $0x1,%dl\nmov    %esi,%edi\ncmovne %ecx,%edi\nmov    %edi,-0x4(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %r8,%rdx\njne    30 <func0+0x30>\npop    %rbx\nretq"
    },
    {
        "task_id": 106,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmovslq %edi,%rdi\nmov    %rdi,%rbx\nshl    $0x2,%rdi\ncallq  14 <func0+0x14>\ntest   %ebx,%ebx\njle    4a <func0+0x4a>\nlea    -0x1(%rbx),%r8d\nmov    $0x1,%edx\nmov    $0x1,%esi\nxor    %ecx,%ecx\nadd    $0x2,%r8\nnopl   0x0(%rax)\nimul   %edx,%esi\nadd    %edx,%ecx\ntest   $0x1,%dl\nmov    %esi,%edi\ncmovne %ecx,%edi\nmov    %edi,-0x4(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %r8,%rdx\njne    30 <func0+0x30>\npop    %rbx\nretq"
    },
    {
        "task_id": 107,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x24(%rbp)\nmov    $0x8,%edi\ncallq  19 <func0+0x19>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovl   $0x0,(%rax)\nmovl   $0x1,-0x18(%rbp)\njmpq   ee <func0+0xee>\nmovl   $0x0,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x10(%rbp)\njmp    b2 <func0+0xb2>\nmov    -0x14(%rbp),%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nmov    %eax,%esi\nmov    -0x10(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%edx\nsar    $0x2,%edx\nmov    %ecx,%eax\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\nlea    (%rsi,%rdx,1),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nmov    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njne    56 <func0+0x56>\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njne    ea <func0+0xea>\nmov    -0xc(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    db <func0+0xdb>\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\njmp    ea <func0+0xea>\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nadd    $0x1,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    41 <func0+0x41>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 107,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x8,%edi\ncallq  11 <func0+0x11>\nmovl   $0x0,(%rax)\nmovl   $0x0,0x4(%rax)\ntest   %ebx,%ebx\njle    84 <func0+0x84>\nlea    0x1(%rbx),%r9d\nmov    $0x1,%r8d\nmov    $0x0,%r10d\njmp    40 <func0+0x40>\naddl   $0x1,(%rax)\nadd    $0x1,%r8d\ncmp    %r8d,%r9d\nje     84 <func0+0x84>\nmov    %r8d,%ecx\nmov    %r10d,%esi\ntest   %r8d,%r8d\nje     34 <func0+0x34>\nlea    (%rsi,%rsi,4),%edi\nmovslq %ecx,%rdx\nimul   $0x66666667,%rdx,%rdx\nsar    $0x22,%rdx\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%edx\nlea    (%rdx,%rdx,4),%esi\nadd    %esi,%esi\nsub    %esi,%ecx\nlea    (%rcx,%rdi,2),%esi\nmov    %edx,%ecx\ntest   %edx,%edx\njne    4b <func0+0x4b>\ncmp    %r8d,%esi\njne    37 <func0+0x37>\ntest   $0x1,%r8b\nje     34 <func0+0x34>\naddl   $0x1,0x4(%rax)\njmp    37 <func0+0x37>\npop    %rbx\nretq"
    },
    {
        "task_id": 107,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x8,%edi\ncallq  11 <func0+0x11>\nmovq   $0x0,(%rax)\ntest   %ebx,%ebx\njle    63 <func0+0x63>\nlea    0x1(%rbx),%r10d\nmov    $0x1,%r9d\nmov    $0xcccccccd,%r8d\nnopl   0x0(%rax)\nmov    %r9d,%ecx\nxor    %esi,%esi\nnopl   (%rax)\nmov    %ecx,%edx\nlea    (%rsi,%rsi,4),%edi\nimul   %r8,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%esi\nadd    %esi,%esi\nsub    %esi,%ecx\nlea    (%rcx,%rdi,2),%esi\nmov    %edx,%ecx\ntest   %edx,%edx\njne    38 <func0+0x38>\ncmp    %esi,%r9d\nje     68 <func0+0x68>\nadd    $0x1,%r9d\ncmp    %r9d,%r10d\njne    30 <func0+0x30>\npop    %rbx\nretq\nnopl   (%rax)\ntest   $0x1,%r9b\njne    78 <func0+0x78>\naddl   $0x1,(%rax)\njmp    5a <func0+0x5a>\nnopl   0x0(%rax,%rax,1)\naddl   $0x1,0x4(%rax)\njmp    5a <func0+0x5a>"
    },
    {
        "task_id": 107,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x8,%edi\ncallq  11 <func0+0x11>\nmovq   $0x0,(%rax)\ntest   %ebx,%ebx\njle    63 <func0+0x63>\nlea    0x1(%rbx),%r10d\nmov    $0x1,%r9d\nmov    $0xcccccccd,%r8d\nnopl   0x0(%rax)\nmov    %r9d,%ecx\nxor    %esi,%esi\nnopl   (%rax)\nmov    %ecx,%edx\nlea    (%rsi,%rsi,4),%edi\nimul   %r8,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%esi\nadd    %esi,%esi\nsub    %esi,%ecx\nlea    (%rcx,%rdi,2),%esi\nmov    %edx,%ecx\ntest   %edx,%edx\njne    38 <func0+0x38>\ncmp    %esi,%r9d\nje     68 <func0+0x68>\nadd    $0x1,%r9d\ncmp    %r10d,%r9d\njne    30 <func0+0x30>\npop    %rbx\nretq\nnopl   (%rax)\ntest   $0x1,%r9b\njne    78 <func0+0x78>\naddl   $0x1,(%rax)\njmp    5a <func0+0x5a>\nnopl   0x0(%rax,%rax,1)\naddl   $0x1,0x4(%rax)\njmp    5a <func0+0x5a>"
    },
    {
        "task_id": 108,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((int[]){}, 0) == 0);\n    assert(func0((int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((int[]){-0, 1}, 2) == 1);\n    assert(func0((int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmpq   d6 <func0+0xd6>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njle    45 <func0+0x45>\naddl   $0x1,-0x10(%rbp)\njmpq   d2 <func0+0xd2>\nmovl   $0x0,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    %edx,%eax\nsar    $0x1f,%eax\nxor    %eax,%edx\nmov    %edx,-0x4(%rbp)\nsub    %eax,-0x4(%rbp)\njmp    bc <func0+0xbc>\nmov    -0x4(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%edx\nsar    $0x2,%edx\nmov    %ecx,%eax\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\nadd    %edx,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njg     71 <func0+0x71>\nmov    -0x4(%rbp),%eax\nsub    %eax,-0x8(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njle    d2 <func0+0xd2>\naddl   $0x1,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     22 <func0+0x22>\nmov    -0x10(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 108,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((int[]){}, 0) == 0);\n    assert(func0((int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((int[]){-0, 1}, 2) == 1);\n    assert(func0((int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    7a <func0+0x7a>\nmov    %rdi,%r8\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r9\nmov    $0x0,%edi\njmp    6e <func0+0x6e>\nmov    %edx,%eax\nsar    $0x1f,%eax\nxor    %eax,%edx\nsub    %eax,%edx\ncmp    $0x9,%edx\njle    65 <func0+0x65>\nmov    $0x0,%esi\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nlea    (%rax,%rax,4),%ecx\nadd    %ecx,%ecx\nmov    %edx,%r10d\nsub    %ecx,%r10d\nadd    %r10d,%esi\nmov    %edx,%ecx\nmov    %eax,%edx\ncmp    $0x63,%ecx\njg     2d <func0+0x2d>\nsub    %eax,%esi\ntest   %esi,%esi\nsetg   %al\nmovzbl %al,%eax\nadd    %eax,%edi\nadd    $0x4,%r8\ncmp    %r9,%r8\nje     7f <func0+0x7f>\nmov    (%r8),%edx\ntest   %edx,%edx\njle    1a <func0+0x1a>\nadd    $0x1,%edi\njmp    65 <func0+0x65>\nmov    $0x0,%edi\nmov    %edi,%eax\nretq"
    },
    {
        "task_id": 108,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((int[]){}, 0) == 0);\n    assert(func0((int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((int[]){-0, 1}, 2) == 1);\n    assert(func0((int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    7a <func0+0x7a>\nlea    -0x1(%rsi),%eax\nxor    %r8d,%r8d\nmov    $0xcccccccd,%r9d\nlea    0x4(%rdi,%rax,4),%r10\njmp    2d <func0+0x2d>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r8d\nadd    $0x4,%rdi\ncmp    %r10,%rdi\nje     76 <func0+0x76>\nmov    (%rdi),%eax\ntest   %eax,%eax\njg     20 <func0+0x20>\nmov    %eax,%edx\nneg    %edx\ncmp    $0xfffffff7,%eax\njge    24 <func0+0x24>\nxor    %esi,%esi\nxchg   %ax,%ax\nmov    %edx,%eax\nmov    %edx,%r11d\nimul   %r9,%rax\nshr    $0x23,%rax\nlea    (%rax,%rax,4),%ecx\nadd    %ecx,%ecx\nsub    %ecx,%r11d\nmov    %edx,%ecx\nmov    %eax,%edx\nadd    %r11d,%esi\ncmp    $0x63,%ecx\njg     40 <func0+0x40>\nsub    %eax,%esi\nxor    %eax,%eax\ntest   %esi,%esi\nsetg   %al\nadd    $0x4,%rdi\nadd    %eax,%r8d\ncmp    %r10,%rdi\njne    2d <func0+0x2d>\nmov    %r8d,%eax\nretq\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 108,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((int[]){}, 0) == 0);\n    assert(func0((int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((int[]){-0, 1}, 2) == 1);\n    assert(func0((int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    7a <func0+0x7a>\nlea    -0x1(%rsi),%eax\nxor    %r8d,%r8d\nmov    $0xcccccccd,%r9d\nlea    0x4(%rdi,%rax,4),%r10\njmp    2d <func0+0x2d>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r8d\nadd    $0x4,%rdi\ncmp    %rdi,%r10\nje     76 <func0+0x76>\nmov    (%rdi),%eax\ntest   %eax,%eax\njg     20 <func0+0x20>\nmov    %eax,%edx\nneg    %edx\ncmp    $0xfffffff7,%eax\njge    24 <func0+0x24>\nxor    %esi,%esi\nxchg   %ax,%ax\nmov    %edx,%eax\nmov    %edx,%r11d\nimul   %r9,%rax\nshr    $0x23,%rax\nlea    (%rax,%rax,4),%ecx\nadd    %ecx,%ecx\nsub    %ecx,%r11d\nmov    %edx,%ecx\nmov    %eax,%edx\nadd    %r11d,%esi\ncmp    $0x63,%ecx\njg     40 <func0+0x40>\nsub    %eax,%esi\nxor    %eax,%eax\ntest   %esi,%esi\nsetg   %al\nadd    $0x4,%rdi\nadd    %eax,%r8d\ncmp    %rdi,%r10\njne    2d <func0+0x2d>\nmov    %r8d,%eax\nretq\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 109,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((int[]){}, 0) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njne    23 <func0+0x23>\nmov    $0x1,%eax\njmp    a2 <func0+0xa2>\nmovl   $0x1,-0x4(%rbp)\njmp    64 <func0+0x64>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    60 <func0+0x60>\naddl   $0x1,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     2c <func0+0x2c>\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    90 <func0+0x90>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x1,-0x8(%rbp)\njg     9d <func0+0x9d>\nmov    $0x1,%eax\njmp    a2 <func0+0xa2>\nmov    $0x0,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 109,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((int[]){}, 0) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x1,%eax\ntest   %esi,%esi\nje     4f <func0+0x4f>\ncmp    $0x1,%esi\njle    50 <func0+0x50>\nmov    %rdi,%rax\nlea    -0x2(%rsi),%edx\nlea    0x4(%rdi,%rdx,4),%r8\nmov    $0x0,%edx\nmov    (%rax),%ecx\ncmp    %ecx,0x4(%rax)\nsetl   %cl\nmovzbl %cl,%ecx\nadd    %ecx,%edx\nadd    $0x4,%rax\ncmp    %r8,%rax\njne    22 <func0+0x22>\nmovslq %esi,%rsi\nmov    (%rdi),%eax\ncmp    %eax,-0x4(%rdi,%rsi,4)\nsetg   %al\nmovzbl %al,%eax\nadd    %eax,%edx\ncmp    $0x1,%edx\nsetle  %al\nretq\nmov    $0x0,%edx\njmp    38 <func0+0x38>"
    },
    {
        "task_id": 109,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((int[]){}, 0) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x1,%eax\ntest   %esi,%esi\nje     4d <func0+0x4d>\ncmp    $0x1,%esi\njle    50 <func0+0x50>\nlea    -0x2(%rsi),%edx\nmov    %rdi,%rax\nlea    0x4(%rdi,%rdx,4),%r8\nxor    %edx,%edx\nnop\nmov    (%rax),%ecx\ncmp    %ecx,0x4(%rax)\nsetl   %cl\nadd    $0x4,%rax\nmovzbl %cl,%ecx\nadd    %ecx,%edx\ncmp    %r8,%rax\njne    20 <func0+0x20>\nmovslq %esi,%rsi\nmov    (%rdi),%eax\ncmp    %eax,-0x4(%rdi,%rsi,4)\nsetg   %al\nmovzbl %al,%eax\nadd    %eax,%edx\ncmp    $0x1,%edx\nsetle  %al\nretq\nxchg   %ax,%ax\nxor    %edx,%edx\njmp    36 <func0+0x36>"
    },
    {
        "task_id": 109,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((int[]){}, 0) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    $0x1,%eax\ntest   %esi,%esi\nje     17b <func0+0x17b>\ncmp    $0x1,%esi\njle    188 <func0+0x188>\nlea    -0x2(%rsi),%eax\nlea    -0x1(%rsi),%r8d\ncmp    $0x2,%eax\njbe    18c <func0+0x18c>\nmov    %r8d,%edx\nmov    %rdi,%rax\npxor   %xmm1,%xmm1\nshr    $0x2,%edx\nshl    $0x4,%rdx\nadd    %rdi,%rdx\nxchg   %ax,%ax\nmovdqu (%rax),%xmm0\nmovdqu 0x4(%rax),%xmm2\nadd    $0x10,%rax\npcmpgtd %xmm2,%xmm0\npsubd  %xmm0,%xmm1\ncmp    %rdx,%rax\njne    40 <func0+0x40>\nmovdqa %xmm1,%xmm0\nmov    %r8d,%edx\npsrldq $0x8,%xmm0\nand    $0xfffffffc,%edx\npaddd  %xmm0,%xmm1\nlea    0x1(%rdx),%ecx\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\ncmp    %edx,%r8d\nje     165 <func0+0x165>\nmovslq %ecx,%rdx\nlea    0x1(%rcx),%r10d\nshl    $0x2,%rdx\nlea    (%rdi,%rdx,1),%r9\ncmp    %r8d,%r10d\njge    198 <func0+0x198>\ncmp    %ecx,%esi\njle    198 <func0+0x198>\nmov    (%r9),%r10d\ncmp    %r10d,-0x4(%r9)\nsetg   %r9b\nmovzbl %r9b,%r9d\nadd    %r9d,%eax\nmov    0x4(%rdi,%rdx,1),%r9d\nxor    %edx,%edx\ncmp    %r9d,%r10d\nlea    0x3(%rcx),%r10d\nsetg   %dl\nadd    %edx,%eax\nlea    0x2(%rcx),%edx\ncmp    %r10d,%r8d\njle    129 <func0+0x129>\nmovslq %edx,%rdx\nmov    (%rdi,%rdx,4),%r10d\ncmp    %r10d,%r9d\nsetg   %r9b\nmovzbl %r9b,%r9d\nadd    %r9d,%eax\nmov    0x4(%rdi,%rdx,4),%r9d\nxor    %edx,%edx\ncmp    %r9d,%r10d\nlea    0x5(%rcx),%r10d\nsetg   %dl\nadd    %edx,%eax\nlea    0x4(%rcx),%edx\ncmp    %r10d,%r8d\njle    129 <func0+0x129>\nmovslq %edx,%rdx\nmov    (%rdi,%rdx,4),%r8d\ncmp    %r9d,%r8d\nsetl   %r9b\nmovzbl %r9b,%r9d\nadd    %r9d,%eax\ncmp    0x4(%rdi,%rdx,4),%r8d\njle    126 <func0+0x126>\nadd    $0x1,%eax\nlea    0x6(%rcx),%edx\nmovslq %edx,%rcx\nmov    -0x4(%rdi,%rcx,4),%r11d\ncmp    %r11d,(%rdi,%rcx,4)\njl     180 <func0+0x180>\nlea    0x1(%rdx),%ecx\ncmp    %ecx,%esi\njle    165 <func0+0x165>\nmovslq %ecx,%rcx\nmov    -0x4(%rdi,%rcx,4),%r11d\ncmp    %r11d,(%rdi,%rcx,4)\njge    14f <func0+0x14f>\nadd    $0x1,%eax\nadd    $0x2,%edx\ncmp    %edx,%esi\njle    165 <func0+0x165>\nmovslq %edx,%rdx\nmov    (%rdi,%rdx,4),%ecx\ncmp    %ecx,-0x4(%rdi,%rdx,4)\njle    165 <func0+0x165>\nadd    $0x1,%eax\nmovslq %esi,%rsi\nxor    %edx,%edx\nmov    (%rdi),%ecx\ncmp    %ecx,-0x4(%rdi,%rsi,4)\nsetg   %dl\nadd    %edx,%eax\ncmp    $0x1,%eax\nsetle  %al\nretq\nnopl   0x0(%rax)\nadd    $0x1,%eax\njmp    137 <func0+0x137>\nnopl   (%rax)\nxor    %eax,%eax\njmp    165 <func0+0x165>\nmov    $0x1,%ecx\nxor    %eax,%eax\njmpq   8a <func0+0x8a>\nmov    %ecx,%edx\njmp    129 <func0+0x129>"
    },
    {
        "task_id": 110,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((int[]){1, 2, 3, 4}, 4, (int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((int[]){1, 2, 3, 4}, 4, (int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((int[]){1, 2, 3, 4}, 4, (int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((int[]){5, 7, 3}, 3, (int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((int[]){5, 7, 3}, 3, (int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((int[]){3, 2, 6, 1, 8, 9}, 6, (int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((int[]){100, 200}, 2, (int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %ecx,-0x20(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    4b <func0+0x4b>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    47 <func0+0x47>\naddl   $0x1,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     26 <func0+0x26>\nmovl   $0x0,-0x4(%rbp)\njmp    81 <func0+0x81>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    7d <func0+0x7d>\naddl   $0x1,-0xc(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     5c <func0+0x5c>\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     9a <func0+0x9a>\nlea    0x0(%rip),%rax\njmp    a1 <func0+0xa1>\nlea    0x0(%rip),%rax\npop    %rbp\nretq"
    },
    {
        "task_id": 110,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((int[]){1, 2, 3, 4}, 4, (int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((int[]){1, 2, 3, 4}, 4, (int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((int[]){1, 2, 3, 4}, 4, (int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((int[]){5, 7, 3}, 3, (int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((int[]){5, 7, 3}, 3, (int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((int[]){3, 2, 6, 1, 8, 9}, 6, (int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((int[]){100, 200}, 2, (int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    62 <func0+0x62>\nmov    %rdi,%r8\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r9\nmov    $0x0,%eax\nmov    (%r8),%edi\nand    $0x1,%edi\ncmp    $0x1,%edi\nadc    $0x0,%eax\nadd    $0x4,%r8\ncmp    %r9,%r8\njne    18 <func0+0x18>\ntest   %ecx,%ecx\njle    4d <func0+0x4d>\nmov    $0x0,%edi\nmov    (%rdx,%rdi,4),%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r8d\nadc    $0x0,%eax\nadd    $0x1,%rdi\ncmp    %edi,%ecx\njg     36 <func0+0x36>\ncmp    %eax,%esi\nlea    0x0(%rip),%rax\nlea    0x0(%rip),%rdx\ncmovle %rdx,%rax\nretq\nmov    $0x0,%eax\ntest   %ecx,%ecx\njg     31 <func0+0x31>\nlea    0x0(%rip),%rax\nretq"
    },
    {
        "task_id": 110,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((int[]){1, 2, 3, 4}, 4, (int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((int[]){1, 2, 3, 4}, 4, (int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((int[]){1, 2, 3, 4}, 4, (int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((int[]){5, 7, 3}, 3, (int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((int[]){5, 7, 3}, 3, (int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((int[]){3, 2, 6, 1, 8, 9}, 6, (int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((int[]){100, 200}, 2, (int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    68 <func0+0x68>\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r9\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmov    (%rdi),%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r8d\nadc    $0x0,%eax\nadd    $0x4,%rdi\ncmp    %r9,%rdi\njne    18 <func0+0x18>\ntest   %ecx,%ecx\njle    4f <func0+0x4f>\nxor    %edi,%edi\nnopl   (%rax)\nmov    (%rdx,%rdi,4),%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r8d\nadc    $0x0,%eax\nadd    $0x1,%rdi\ncmp    %edi,%ecx\njg     38 <func0+0x38>\ncmp    %eax,%esi\nlea    0x0(%rip),%rdx\nlea    0x0(%rip),%rax\ncmovg  %rdx,%rax\nretq\nnopl   0x0(%rax)\nxor    %eax,%eax\ntest   %ecx,%ecx\njg     33 <func0+0x33>\nlea    0x0(%rip),%rax\nretq"
    },
    {
        "task_id": 110,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((int[]){1, 2, 3, 4}, 4, (int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((int[]){1, 2, 3, 4}, 4, (int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((int[]){1, 2, 3, 4}, 4, (int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((int[]){5, 7, 3}, 3, (int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((int[]){5, 7, 3}, 3, (int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((int[]){3, 2, 6, 1, 8, 9}, 6, (int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((int[]){100, 200}, 2, (int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    1e0 <func0+0x1e0>\nlea    -0x1(%rsi),%eax\ncmp    $0x3,%eax\njbe    1f2 <func0+0x1f2>\nmov    %esi,%r8d\npxor   %xmm1,%xmm1\nmovdqa 0x0(%rip),%xmm2\n00\nmov    %rdi,%rax\nshr    $0x2,%r8d\nmovdqa %xmm1,%xmm3\nshl    $0x4,%r8\nadd    %rdi,%r8\nnopl   0x0(%rax)\nmovdqu (%rax),%xmm0\nadd    $0x10,%rax\npand   %xmm2,%xmm0\npcmpeqd %xmm3,%xmm0\npsubd  %xmm0,%xmm1\ncmp    %r8,%rax\njne    40 <func0+0x40>\nmovdqa %xmm1,%xmm0\nmov    %esi,%r8d\npsrldq $0x8,%xmm0\nand    $0xfffffffc,%r8d\npaddd  %xmm0,%xmm1\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\ntest   $0x3,%sil\nje     e5 <func0+0xe5>\nmovslq %r8d,%r9\nmov    (%rdi,%r9,4),%r9d\nand    $0x1,%r9d\ncmp    $0x1,%r9d\nlea    0x1(%r8),%r9d\nadc    $0x0,%eax\ncmp    %esi,%r9d\njge    e5 <func0+0xe5>\nmovslq %r9d,%r9\nmov    (%rdi,%r9,4),%r9d\nand    $0x1,%r9d\ncmp    $0x1,%r9d\nlea    0x2(%r8),%r9d\nadc    $0x0,%eax\ncmp    %r9d,%esi\njle    e5 <func0+0xe5>\nmovslq %r9d,%r9\nmov    (%rdi,%r9,4),%r9d\nand    $0x1,%r9d\ncmp    $0x1,%r9d\nadc    $0x0,%eax\nadd    $0x3,%r8d\ncmp    %r8d,%esi\njle    e5 <func0+0xe5>\nmovslq %r8d,%r8\nmov    (%rdi,%r8,4),%edi\nand    $0x1,%edi\ncmp    $0x1,%edi\nadc    $0x0,%eax\ntest   %ecx,%ecx\njle    1cb <func0+0x1cb>\ntest   %ecx,%ecx\nmov    $0x1,%r9d\ncmovg  %ecx,%r9d\ncmp    $0x4,%ecx\njle    1fc <func0+0x1fc>\nmov    %r9d,%r8d\npxor   %xmm1,%xmm1\nmovdqa 0x0(%rip),%xmm2\n00\nmov    %rdx,%rdi\nshr    $0x2,%r8d\nmovdqa %xmm1,%xmm3\nshl    $0x4,%r8\nadd    %rdx,%r8\nnopl   0x0(%rax,%rax,1)\nmovdqu (%rdi),%xmm0\nadd    $0x10,%rdi\npand   %xmm2,%xmm0\npcmpeqd %xmm3,%xmm0\npsubd  %xmm0,%xmm1\ncmp    %r8,%rdi\njne    128 <func0+0x128>\nmovdqa %xmm1,%xmm0\npsrldq $0x8,%xmm0\npaddd  %xmm0,%xmm1\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%edi\nadd    %edi,%eax\nmov    %r9d,%edi\nand    $0xfffffffc,%edi\nand    $0x3,%r9d\nje     1cb <func0+0x1cb>\nmovslq %edi,%r8\nmov    (%rdx,%r8,4),%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r8d\nlea    0x1(%rdi),%r8d\nadc    $0x0,%eax\ncmp    %r8d,%ecx\njle    1cb <func0+0x1cb>\nmovslq %r8d,%r8\nmov    (%rdx,%r8,4),%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r8d\nlea    0x2(%rdi),%r8d\nadc    $0x0,%eax\ncmp    %r8d,%ecx\njle    1cb <func0+0x1cb>\nmovslq %r8d,%r8\nmov    (%rdx,%r8,4),%r8d\nand    $0x1,%r8d\ncmp    $0x1,%r8d\nadc    $0x0,%eax\nadd    $0x3,%edi\ncmp    %edi,%ecx\njle    1cb <func0+0x1cb>\nmovslq %edi,%rdi\nmov    (%rdx,%rdi,4),%edx\nand    $0x1,%edx\ncmp    $0x1,%edx\nadc    $0x0,%eax\ncmp    %eax,%esi\nlea    0x0(%rip),%rdx\nlea    0x0(%rip),%rax\ncmovg  %rdx,%rax\nretq\nxor    %eax,%eax\ntest   %ecx,%ecx\njg     ed <func0+0xed>\nlea    0x0(%rip),%rax\nretq\nxor    %r8d,%r8d\nxor    %eax,%eax\njmpq   84 <func0+0x84>\nxor    %edi,%edi\njmpq   16d <func0+0x16d>"
    },
    {
        "task_id": 111,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb0,%rsp\nmov    %rdi,-0x98(%rbp)\nmov    %rsi,-0xa0(%rbp)\nmov    %rdx,-0xa8(%rbp)\nmov    %rcx,-0xb0(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x70(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0xd,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x0,-0x88(%rbp)\n00 00 00\nmov    -0x98(%rbp),%rax\nmov    %rax,-0x78(%rbp)\nmovl   $0x0,-0x84(%rbp)\n00 00 00\njmp    c4 <func0+0xc4>\nmov    -0x78(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     bf <func0+0xbf>\nmov    -0x78(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nsub    $0x61,%eax\nmov    %eax,-0x7c(%rbp)\nmov    -0x7c(%rbp),%eax\ncltq\nmov    -0x70(%rbp,%rax,4),%eax\nlea    0x1(%rax),%edx\nmov    -0x7c(%rbp),%eax\ncltq\nmov    %edx,-0x70(%rbp,%rax,4)\nmov    -0x7c(%rbp),%eax\ncltq\nmov    -0x70(%rbp,%rax,4),%eax\ncmp    %eax,-0x88(%rbp)\njge    bf <func0+0xbf>\nmov    -0x7c(%rbp),%eax\ncltq\nmov    -0x70(%rbp,%rax,4),%eax\nmov    %eax,-0x88(%rbp)\naddq   $0x1,-0x78(%rbp)\nmov    -0x78(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    6f <func0+0x6f>\nmovl   $0x0,-0x80(%rbp)\njmp    135 <func0+0x135>\nmov    -0x80(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0xa0(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x80(%rbp),%eax\ncltq\nmov    -0x70(%rbp,%rax,4),%eax\nmov    %eax,(%rdx)\nmov    -0x80(%rbp),%eax\ncltq\nmov    -0x70(%rbp,%rax,4),%eax\ncmp    %eax,-0x88(%rbp)\njne    131 <func0+0x131>\nmov    -0x80(%rbp),%eax\nlea    0x61(%rax),%ecx\nmov    -0x84(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x84(%rbp)\nmovslq %eax,%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\naddl   $0x1,-0x80(%rbp)\ncmpl   $0x19,-0x80(%rbp)\njle    d8 <func0+0xd8>\nmov    -0xa8(%rbp),%rax\nmov    -0x88(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x84(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\nmov    -0x8(%rbp),%rax\nxor    %fs:0x28,%rax\n00 00\nje     175 <func0+0x175>\ncallq  175 <func0+0x175>\nleaveq\nretq"
    },
    {
        "task_id": 111,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nsub    $0x78,%rsp\nmov    %rdi,%r8\nmov    %rcx,%r9\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdi\nmov    $0xd,%ecx\nrep stos %rax,%es:(%rdi)\nmovzbl (%r8),%eax\ntest   %al,%al\nje     60 <func0+0x60>\nmov    $0x0,%edi\njmp    5a <func0+0x5a>\nmovsbl %al,%eax\nsub    $0x61,%eax\ncltq\nmov    (%rsp,%rax,4),%ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rsp,%rax,4)\ncmp    %ecx,%edi\ncmovl  %ecx,%edi\nadd    $0x1,%r8\nmovzbl (%r8),%eax\ntest   %al,%al\nje     65 <func0+0x65>\ncmp    $0x20,%al\njne    38 <func0+0x38>\njmp    4e <func0+0x4e>\nmov    $0x0,%edi\nmov    $0x0,%eax\nmov    $0x0,%r8d\njmp    7c <func0+0x7c>\nadd    $0x1,%rax\ncmp    $0x1a,%rax\nje     97 <func0+0x97>\nmov    (%rsp,%rax,4),%ecx\nmov    %ecx,(%rsi,%rax,4)\ncmp    %edi,%ecx\njne    72 <func0+0x72>\nmovslq %r8d,%rcx\nlea    0x61(%rax),%r10d\nmov    %r10b,(%r9,%rcx,1)\nlea    0x1(%r8),%r8d\njmp    72 <func0+0x72>\nmov    %edi,(%rdx)\nmovslq %r8d,%r8\nmovb   $0x0,(%r9,%r8,1)\nmov    0x68(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    b6 <func0+0xb6>\nadd    $0x78,%rsp\nretq\ncallq  bb <func0+0xbb>"
    },
    {
        "task_id": 111,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%r8\nmov    %rcx,%r9\nmov    $0xd,%ecx\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r10\nmov    %r10,%rdi\nrep stos %rax,%es:(%rdi)\nmovsbl (%r8),%eax\ntest   %al,%al\nje     bd <func0+0xbd>\nxor    %r11d,%r11d\nnopl   0x0(%rax)\ncmp    $0x20,%al\nje     59 <func0+0x59>\nsub    $0x61,%eax\ncltq\nmov    (%rsp,%rax,4),%ebx\nlea    0x1(%rbx),%ecx\ncmp    %ecx,%r11d\nmov    %ecx,(%rsp,%rax,4)\ncmovl  %ecx,%r11d\nmovsbl 0x1(%r8),%eax\nadd    $0x1,%r8\ntest   %al,%al\njne    40 <func0+0x40>\nmov    (%rsp),%ecx\nxor    %eax,%eax\nxor    %ebx,%ebx\nxor    %r8d,%r8d\njmp    7c <func0+0x7c>\nnopw   0x0(%rax,%rax,1)\nmov    (%r10,%rax,4),%ecx\nmov    %ecx,(%rsi,%rax,4)\nlea    (%r9,%r8,1),%rdi\ncmp    %ecx,%r11d\njne    97 <func0+0x97>\nadd    $0x1,%ebx\nlea    0x61(%rax),%ecx\nmovslq %ebx,%r8\nmov    %cl,(%rdi)\nlea    (%r9,%r8,1),%rdi\nadd    $0x1,%rax\ncmp    $0x1a,%rax\njne    78 <func0+0x78>\nmov    %r11d,(%rdx)\nmovb   $0x0,(%rdi)\nmov    0x68(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    c4 <func0+0xc4>\nadd    $0x70,%rsp\npop    %rbx\nretq\nxor    %ecx,%ecx\nxor    %r11d,%r11d\njmp    69 <func0+0x69>\ncallq  c9 <func0+0xc9>"
    },
    {
        "task_id": 111,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%r8\nmov    %rcx,%r9\nmov    $0xd,%ecx\nxor    %r11d,%r11d\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r10\nmov    %r10,%rdi\nrep stos %rax,%es:(%rdi)\nmovsbl (%r8),%eax\ntest   %al,%al\nje     66 <func0+0x66>\nnopl   0x0(%rax,%rax,1)\n00\ncmp    $0x20,%al\nje     b8 <func0+0xb8>\nsub    $0x61,%eax\ncltq\nmov    (%rsp,%rax,4),%ebx\nlea    0x1(%rbx),%ecx\ncmp    %ecx,%r11d\nmov    %ecx,(%rsp,%rax,4)\ncmovl  %ecx,%r11d\nmovsbl 0x1(%r8),%eax\nadd    $0x1,%r8\ntest   %al,%al\njne    40 <func0+0x40>\nxor    %eax,%eax\nxor    %ebx,%ebx\nxor    %r8d,%r8d\nnopl   (%rax)\nmov    (%r10,%rax,4),%ecx\nlea    (%r9,%r8,1),%rdi\nmov    %ecx,(%rsi,%rax,4)\ncmp    %r11d,%ecx\njne    8f <func0+0x8f>\nadd    $0x1,%ebx\nlea    0x61(%rax),%ecx\nmovslq %ebx,%r8\nmov    %cl,(%rdi)\nlea    (%r9,%r8,1),%rdi\nadd    $0x1,%rax\ncmp    $0x1a,%rax\njne    70 <func0+0x70>\nmov    %r11d,(%rdx)\nmovb   $0x0,(%rdi)\nmov    0x68(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    cb <func0+0xcb>\nadd    $0x70,%rsp\npop    %rbx\nretq\nnopl   (%rax)\nmovsbl 0x1(%r8),%eax\nadd    $0x1,%r8\ntest   %al,%al\njne    40 <func0+0x40>\njmp    66 <func0+0x66>\ncallq  d0 <func0+0xd0>"
    },
    {
        "task_id": 112,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %rcx,-0x50(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncallq  28 <func0+0x28>\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncallq  3b <func0+0x3b>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmp    c3 <func0+0xc3>\nmov    -0x40(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmovb   $0x0,-0x26(%rbp)\njmp    83 <func0+0x83>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njne    7e <func0+0x7e>\nmovb   $0x1,-0x26(%rbp)\njmp    8e <func0+0x8e>\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    5d <func0+0x5d>\nmovzbl -0x26(%rbp),%eax\nxor    $0x1,%eax\ntest   %al,%al\nje     bf <func0+0xbf>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x24(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x24(%rbp)\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmovzbl (%rcx),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    4f <func0+0x4f>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncallq  f7 <func0+0xf7>\nmov    %eax,-0x14(%rbp)\nmovb   $0x1,-0x25(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    13b <func0+0x13b>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x14(%rbp),%eax\nsub    $0x1,%eax\nsub    -0x1c(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     137 <func0+0x137>\nmovb   $0x0,-0x25(%rbp)\njmp    14c <func0+0x14c>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x1c(%rbp)\njl     107 <func0+0x107>\nmov    -0x8(%rbp),%rdx\nmov    -0x48(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  15f <func0+0x15f>\ncmpb   $0x0,-0x25(%rbp)\nje     16e <func0+0x16e>\nlea    0x0(%rip),%rax\njmp    175 <func0+0x175>\nlea    0x0(%rip),%rax\nmov    -0x50(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncallq  184 <func0+0x184>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncallq  190 <func0+0x190>\nnop\nleaveq\nretq"
    },
    {
        "task_id": 112,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r14\nmov    %rsi,%rbp\nmov    %rdx,%r13\nmov    %rcx,%r12\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nmov    %ecx,%eax\nnot    %eax\nmovslq %eax,%rdi\ncallq  32 <func0+0x32>\nmov    %rax,%rbx\nmovzbl (%r14),%ecx\ntest   %cl,%cl\nje     53 <func0+0x53>\nmovzbl 0x0(%rbp),%r8d\nlea    0x1(%r14),%rsi\nmov    $0x0,%edi\nmov    %r8d,%r9d\njmpq   101 <func0+0x101>\nmov    $0x0,%edi\nmovslq %edi,%rdi\nmovb   $0x0,(%rbx,%rdi,1)\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nmov    %rbx,%rdi\nrepnz scas %es:(%rdi),%al\nmov    %rcx,%rax\nnot    %rax\nsub    $0x1,%rax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %eax,%ecx\nsar    %ecx\ncmp    $0x1,%eax\njle    a9 <func0+0xa9>\ncltq\nlea    -0x1(%rbx,%rax,1),%rdx\nmov    $0x0,%eax\nmovzbl (%rdx),%esi\ncmp    %sil,(%rbx,%rax,1)\njne    d4 <func0+0xd4>\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %eax,%ecx\njg     94 <func0+0x94>\nmov    %rbx,%rsi\nmov    %r13,%rdi\ncallq  b4 <func0+0xb4>\nlea    0x0(%rip),%rsi\nmov    %r12,%rdi\ncallq  c3 <func0+0xc3>\nmov    %rbx,%rdi\ncallq  cb <func0+0xcb>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nmov    %rbx,%rsi\nmov    %r13,%rdi\ncallq  df <func0+0xdf>\nlea    0x0(%rip),%rsi\njmp    bb <func0+0xbb>\nmovslq %edi,%rax\nmov    %cl,(%rbx,%rax,1)\nlea    0x1(%rdi),%edi\nadd    $0x1,%rsi\nmovzbl -0x1(%rsi),%ecx\ntest   %cl,%cl\nje     58 <func0+0x58>\nmov    %rbp,%rdx\nmov    %r9d,%eax\ntest   %r8b,%r8b\nje     e8 <func0+0xe8>\ncmp    %cl,%al\nje     f1 <func0+0xf1>\nadd    $0x1,%rdx\nmovzbl (%rdx),%eax\ntest   %al,%al\njne    10c <func0+0x10c>\njmp    e8 <func0+0xe8>"
    },
    {
        "task_id": 112,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\nmov    %rsi,%r14\npush   %r13\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %rcx,%rbp\npush   %rbx\nmov    %rdi,%rbx\ncallq  1d <func0+0x1d>\nlea    0x1(%rax),%edi\nmovslq %edi,%rdi\ncallq  28 <func0+0x28>\nmovzbl (%rbx),%ecx\nmov    %rax,%r13\ntest   %cl,%cl\nje     75 <func0+0x75>\nmovzbl (%r14),%r9d\nlea    0x1(%rbx),%rdi\nxor    %r8d,%r8d\nnopl   (%rax)\nmov    %r14,%rdx\nmov    %r9d,%eax\ntest   %r9b,%r9b\njne    60 <func0+0x60>\njmpq   118 <func0+0x118>\nmovzbl 0x1(%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\nje     118 <func0+0x118>\ncmp    %al,%cl\njne    50 <func0+0x50>\nmovzbl (%rdi),%ecx\nadd    $0x1,%rdi\ntest   %cl,%cl\njne    40 <func0+0x40>\nmovslq %r8d,%rax\nadd    %r13,%rax\nmovb   $0x0,(%rax)\nmov    %r13,%rcx\nmov    (%rcx),%edx\nadd    $0x4,%rcx\nlea    -0x1010101(%rdx),%eax\nnot    %edx\nand    %edx,%eax\nand    $0x80808080,%eax\nje     7b <func0+0x7b>\nmov    %eax,%edx\nshr    $0x10,%edx\ntest   $0x8080,%eax\ncmove  %edx,%eax\nlea    0x2(%rcx),%rdx\ncmove  %rdx,%rcx\nmov    %eax,%ebx\nadd    %al,%bl\nsbb    $0x3,%rcx\nsub    %r13,%rcx\nmov    %ecx,%esi\nshr    $0x1f,%esi\nadd    %ecx,%esi\nsar    %esi\ncmp    $0x1,%ecx\njle    139 <func0+0x139>\nlea    -0x1(%rcx),%edx\nxor    %eax,%eax\nmovslq %edx,%rdx\nadd    %r13,%rdx\njmp    dc <func0+0xdc>\nnopl   (%rax)\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %eax,%esi\njle    139 <func0+0x139>\nmovzbl (%rdx),%ebx\ncmp    %bl,0x0(%r13,%rax,1)\nje     d0 <func0+0xd0>\nmov    %r13,%rsi\nlea    0x1(%rcx),%rdx\nmov    %r12,%rdi\ncallq  f5 <func0+0xf5>\nlea    0x0(%rip),%rsi\nmov    %rbp,%rdi\ncallq  104 <func0+0x104>\npop    %rbx\nmov    %r13,%rdi\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\njmpq   114 <func0+0x114>\nnopl   0x0(%rax)\nmovslq %r8d,%rax\nadd    $0x1,%rdi\nadd    $0x1,%r8d\nmov    %cl,0x0(%r13,%rax,1)\nmovzbl -0x1(%rdi),%ecx\ntest   %cl,%cl\njne    40 <func0+0x40>\njmpq   6f <func0+0x6f>\nmov    %r13,%rsi\nlea    0x1(%rcx),%rdx\nmov    %r12,%rdi\ncallq  148 <func0+0x148>\nlea    0x0(%rip),%rsi\njmp    fc <func0+0xfc>"
    },
    {
        "task_id": 112,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\nmov    %rsi,%r14\npush   %r13\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %rcx,%rbp\npush   %rbx\nmov    %rdi,%rbx\ncallq  1d <func0+0x1d>\nlea    0x1(%rax),%edi\nmovslq %edi,%rdi\ncallq  28 <func0+0x28>\nmovzbl (%rbx),%ecx\nmov    %rax,%r13\ntest   %cl,%cl\nje     75 <func0+0x75>\nmovzbl (%r14),%r9d\nlea    0x1(%rbx),%rdi\nxor    %r8d,%r8d\nnopl   (%rax)\nmov    %r14,%rdx\nmov    %r9d,%eax\ntest   %r9b,%r9b\njne    60 <func0+0x60>\njmpq   118 <func0+0x118>\nmovzbl 0x1(%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\nje     118 <func0+0x118>\ncmp    %al,%cl\njne    50 <func0+0x50>\nmovzbl (%rdi),%ecx\nadd    $0x1,%rdi\ntest   %cl,%cl\njne    40 <func0+0x40>\nmovslq %r8d,%rax\nadd    %r13,%rax\nmovb   $0x0,(%rax)\nmov    %r13,%rcx\nmov    (%rcx),%edx\nadd    $0x4,%rcx\nlea    -0x1010101(%rdx),%eax\nnot    %edx\nand    %edx,%eax\nand    $0x80808080,%eax\nje     7b <func0+0x7b>\nmov    %eax,%edx\nshr    $0x10,%edx\ntest   $0x8080,%eax\ncmove  %edx,%eax\nlea    0x2(%rcx),%rdx\ncmove  %rdx,%rcx\nmov    %eax,%ebx\nadd    %al,%bl\nsbb    $0x3,%rcx\nsub    %r13,%rcx\nmov    %ecx,%esi\nshr    $0x1f,%esi\nadd    %ecx,%esi\nsar    %esi\ncmp    $0x1,%ecx\njle    139 <func0+0x139>\nlea    -0x1(%rcx),%edx\nxor    %eax,%eax\nmovslq %edx,%rdx\nadd    %r13,%rdx\njmp    dc <func0+0xdc>\nnopl   (%rax)\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %eax,%esi\njle    139 <func0+0x139>\nmovzbl (%rdx),%ebx\ncmp    %bl,0x0(%r13,%rax,1)\nje     d0 <func0+0xd0>\nmov    %r13,%rsi\nlea    0x1(%rcx),%rdx\nmov    %r12,%rdi\ncallq  f5 <func0+0xf5>\nlea    0x0(%rip),%rsi\nmov    %rbp,%rdi\ncallq  104 <func0+0x104>\npop    %rbx\nmov    %r13,%rdi\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\njmpq   114 <func0+0x114>\nnopl   0x0(%rax)\nmovslq %r8d,%rax\nadd    $0x1,%rdi\nadd    $0x1,%r8d\nmov    %cl,0x0(%r13,%rax,1)\nmovzbl -0x1(%rdi),%ecx\ntest   %cl,%cl\njne    40 <func0+0x40>\njmpq   6f <func0+0x6f>\nmov    %r13,%rsi\nlea    0x1(%rcx),%rdx\nmov    %r12,%rdi\ncallq  148 <func0+0x148>\nlea    0x0(%rip),%rsi\njmp    fc <func0+0xfc>"
    },
    {
        "task_id": 113,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncallq  25 <func0+0x25>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmpq   161 <func0+0x161>\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmpq   da <func0+0xda>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    d6 <func0+0xd6>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x39,%al\njg     d6 <func0+0xd6>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nlea    -0x30(%rax),%edx\nmov    %edx,%eax\nsar    $0x1f,%eax\nshr    $0x1f,%eax\nadd    %eax,%edx\nand    $0x1,%edx\nsub    %eax,%edx\nmov    %edx,%eax\ncmp    $0x1,%eax\njne    d6 <func0+0xd6>\naddl   $0x1,-0x20(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    48 <func0+0x48>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    $0x64,%edi\ncallq  123 <func0+0x123>\nmov    %rax,(%rbx)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x20(%rbp),%esi\nmov    -0x20(%rbp),%ecx\nmov    -0x20(%rbp),%edx\nmov    %esi,%r8d\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncallq  15d <func0+0x15d>\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     35 <func0+0x35>\nmov    -0x18(%rbp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 113,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r13\nmov    %esi,%ebx\nmovslq %esi,%rdi\nshl    $0x3,%rdi\ncallq  23 <func0+0x23>\nmov    %rax,%r12\ntest   %ebx,%ebx\njle    cd <func0+0xcd>\nlea    -0x1(%rbx),%r15d\nmov    $0x0,%ebp\nlea    0x0(%rip),%r14\njmp    b6 <func0+0xb6>\nadd    $0x1,%rdx\nmovzbl -0x1(%rdx),%eax\ntest   %al,%al\nje     73 <func0+0x73>\nlea    -0x30(%rax),%ecx\ncmp    $0x9,%cl\nja     40 <func0+0x40>\nmovsbl %al,%eax\nsub    $0x30,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nand    $0x1,%eax\nsub    %ecx,%eax\ncmp    $0x1,%eax\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebx\njmp    40 <func0+0x40>\nmov    $0x64,%edi\ncallq  7d <func0+0x7d>\nmov    %rax,%rdi\nmov    %rax,(%r12,%rbp,8)\nsub    $0x8,%rsp\npush   %rbx\nmov    %ebx,%r9d\nmov    %ebx,%r8d\nmov    %r14,%rcx\nmov    $0x64,%edx\nmov    $0x1,%esi\nmov    $0x0,%eax\ncallq  a6 <func0+0xa6>\nlea    0x1(%rbp),%rax\nadd    $0x10,%rsp\ncmp    %r15,%rbp\nje     cd <func0+0xcd>\nmov    %rax,%rbp\nmov    0x0(%r13,%rbp,8),%rdx\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\nmov    $0x0,%ebx\ntest   %al,%al\njne    4c <func0+0x4c>\njmp    73 <func0+0x73>\nmov    %r12,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 113,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%rbp\nshl    $0x3,%rdi\nsub    $0x8,%rsp\ncallq  24 <func0+0x24>\nmov    %rax,%r12\ntest   %ebp,%ebp\njle    b8 <func0+0xb8>\nlea    -0x1(%rbp),%r13d\nxor    %r14d,%r14d\nlea    0x0(%rip),%rbp\nnopl   (%rax)\nmov    (%rbx,%r14,8),%rdx\nxor    %r15d,%r15d\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\nje     74 <func0+0x74>\nnopw   0x0(%rax,%rax,1)\nlea    -0x30(%rax),%ecx\ncmp    $0x9,%cl\nja     69 <func0+0x69>\nand    $0x1,%eax\ncmp    $0x1,%al\nsbb    $0xffffffff,%r15d\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\njne    58 <func0+0x58>\nmov    $0x64,%edi\ncallq  7e <func0+0x7e>\nsub    $0x8,%rsp\nmov    %rbp,%rcx\nmov    %r15d,%r9d\npush   %r15\nmov    %rax,%rdi\nmov    $0x64,%edx\nmov    %r15d,%r8d\nmov    %rax,(%r12,%r14,8)\nmov    $0x1,%esi\nxor    %eax,%eax\ncallq  a5 <func0+0xa5>\npop    %rdx\nlea    0x1(%r14),%rax\npop    %rcx\ncmp    %r14,%r13\nje     b8 <func0+0xb8>\nmov    %rax,%r14\njmp    40 <func0+0x40>\nnopl   (%rax)\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 113,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmovslq %esi,%rdi\nmov    %rdi,%rbp\nshl    $0x3,%rdi\nsub    $0x8,%rsp\ncallq  24 <func0+0x24>\nmov    %rax,%r12\ntest   %ebp,%ebp\njle    b8 <func0+0xb8>\nlea    -0x1(%rbp),%r13d\nxor    %r14d,%r14d\nlea    0x0(%rip),%rbp\nnopl   (%rax)\nmov    (%rbx,%r14,8),%rdx\nxor    %r15d,%r15d\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\nje     74 <func0+0x74>\nnopw   0x0(%rax,%rax,1)\nlea    -0x30(%rax),%ecx\ncmp    $0x9,%cl\nja     69 <func0+0x69>\nand    $0x1,%eax\ncmp    $0x1,%al\nsbb    $0xffffffff,%r15d\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\njne    58 <func0+0x58>\nmov    $0x64,%edi\ncallq  7e <func0+0x7e>\nsub    $0x8,%rsp\nmov    %rbp,%rcx\nmov    %r15d,%r9d\npush   %r15\nmov    %rax,%rdi\nmov    $0x64,%edx\nmov    %r15d,%r8d\nmov    %rax,(%r12,%r14,8)\nmov    $0x1,%esi\nxor    %eax,%eax\ncallq  a5 <func0+0xa5>\npop    %rdx\nlea    0x1(%r14),%rax\npop    %rcx\ncmp    %r13,%r14\nje     b8 <func0+0xb8>\nmov    %rax,%r14\njmp    40 <func0+0x40>\nnopl   (%rax)\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 114,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x1,-0x14(%rbp)\njmp    86 <func0+0x86>\ncmpq   $0x0,-0x10(%rbp)\njns    55 <func0+0x55>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\njmp    6c <func0+0x6c>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njge    82 <func0+0x82>\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x8(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     2e <func0+0x2e>\nmov    -0x8(%rbp),%rax\npop    %rbp\nretq"
    },
    {
        "task_id": 114,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    (%rdi),%rax\ncmp    $0x1,%esi\njle    3a <func0+0x3a>\nlea    0x8(%rdi),%rdx\nlea    -0x2(%rsi),%ecx\nlea    0x10(%rdi,%rcx,8),%rsi\nmov    %rax,%rcx\njmp    30 <func0+0x30>\nadd    (%rdx),%rax\ncmp    %rax,%rcx\ncmovg  %rax,%rcx\nadd    $0x8,%rdx\ncmp    %rsi,%rdx\nje     3d <func0+0x3d>\ntest   %rax,%rax\njs     1d <func0+0x1d>\nmov    (%rdx),%rax\njmp    20 <func0+0x20>\nmov    %rax,%rcx\nmov    %rcx,%rax\nretq"
    },
    {
        "task_id": 114,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    (%rdi),%rax\ncmp    $0x1,%esi\njle    48 <func0+0x48>\nlea    -0x2(%rsi),%ecx\nlea    0x8(%rdi),%rdx\nmov    %rax,%r8\nlea    0x10(%rdi,%rcx,8),%rdi\nnopl   0x0(%rax,%rax,1)\nmov    (%rdx),%rcx\ntest   %rax,%rax\nlea    (%rax,%rcx,1),%rsi\nmov    %rcx,%rax\ncmovs  %rsi,%rax\ncmp    %rax,%r8\ncmovg  %rax,%r8\nadd    $0x8,%rdx\ncmp    %rdx,%rdi\njne    20 <func0+0x20>\nmov    %r8,%rax\nretq\nnopl   (%rax)\nmov    %rax,%r8\nmov    %r8,%rax\nretq"
    },
    {
        "task_id": 114,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    (%rdi),%rcx\ncmp    $0x1,%esi\njle    48 <func0+0x48>\nlea    -0x2(%rsi),%eax\nlea    0x8(%rdi),%rdx\nmov    %rcx,%r8\nlea    0x10(%rdi,%rax,8),%rsi\njmp    23 <func0+0x23>\nnopl   (%rax)\nmov    %rax,%rcx\nmov    (%rdx),%rax\ntest   %rcx,%rcx\njns    2e <func0+0x2e>\nadd    %rcx,%rax\ncmp    %rax,%r8\ncmovg  %rax,%r8\nadd    $0x8,%rdx\ncmp    %rdx,%rsi\njne    20 <func0+0x20>\nmov    %r8,%rax\nretq\nnopw   0x0(%rax,%rax,1)\nmov    %rcx,%r8\nmov    %r8,%rax\nretq"
    },
    {
        "task_id": 115,
        "type": "O0",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    %ecx,-0x24(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    86 <func0+0x86>\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    62 <func0+0x62>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     35 <func0+0x35>\ncmpl   $0x0,-0x8(%rbp)\njle    82 <func0+0x82>\nmov    -0x8(%rbp),%edx\nmov    -0x24(%rbp),%eax\nadd    %edx,%eax\nsub    $0x1,%eax\ncltd\nidivl  -0x24(%rbp)\nadd    %eax,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     25 <func0+0x25>\nmov    -0x10(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 115,
        "type": "O1",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    61 <func0+0x61>\npush   %rbx\nmov    %edx,%r9d\nmov    %rdi,%r8\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%r10\nlea    -0x1(%rdx),%eax\nmov    $0x0,%edi\nlea    0x4(,%rax,4),%rbx\n00\nmov    $0x0,%r11d\njmp    38 <func0+0x38>\nadd    $0x8,%r8\ncmp    %r10,%r8\nje     69 <func0+0x69>\ntest   %r9d,%r9d\njle    2f <func0+0x2f>\nmov    (%r8),%rax\nlea    (%rbx,%rax,1),%rsi\nmov    %r11d,%edx\nadd    (%rax),%edx\nadd    $0x4,%rax\ncmp    %rsi,%rax\njne    47 <func0+0x47>\ntest   %edx,%edx\njle    2f <func0+0x2f>\nlea    -0x1(%rdx,%rcx,1),%eax\ncltd\nidiv   %ecx\nadd    %eax,%edi\njmp    2f <func0+0x2f>\nmov    $0x0,%edi\nmov    %edi,%eax\nretq\nmov    %edi,%eax\npop    %rbx\nretq"
    },
    {
        "task_id": 115,
        "type": "O2",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edx,%r11d\ntest   %esi,%esi\njle    66 <func0+0x66>\nlea    -0x1(%rsi),%eax\nxor    %r8d,%r8d\nlea    0x8(%rdi,%rax,8),%r9\nlea    -0x1(%rdx),%eax\nlea    0x4(,%rax,4),%r10\n00\nnopl   0x0(%rax)\ntest   %r11d,%r11d\njle    59 <func0+0x59>\nmov    (%rdi),%rax\nxor    %edx,%edx\nlea    (%r10,%rax,1),%rsi\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nadd    (%rax),%edx\nadd    $0x4,%rax\ncmp    %rsi,%rax\njne    40 <func0+0x40>\ntest   %edx,%edx\njle    59 <func0+0x59>\nlea    -0x1(%rdx,%rcx,1),%eax\ncltd\nidiv   %ecx\nadd    %eax,%r8d\nadd    $0x8,%rdi\ncmp    %r9,%rdi\njne    28 <func0+0x28>\nmov    %r8d,%eax\nretq\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 115,
        "type": "O3",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    fa <func0+0xfa>\nmov    %edx,%r11d\nlea    -0x1(%rsi),%eax\nmov    %edx,%r9d\npush   %r13\nshr    $0x2,%r11d\npush   %r12\nmov    %edx,%r8d\nand    $0xfffffffc,%r9d\npush   %rbp\nshl    $0x4,%r11\nlea    -0x1(%rdx),%ebp\nxor    %r10d,%r10d\npush   %rbx\nlea    0x8(%rdi,%rax,8),%rbx\nnopl   (%rax)\ntest   %r8d,%r8d\njle    dd <func0+0xdd>\nmov    (%rdi),%rsi\ncmp    $0x3,%ebp\njbe    f4 <func0+0xf4>\nmov    %rsi,%rax\nlea    (%rsi,%r11,1),%rdx\npxor   %xmm0,%xmm0\nnopl   0x0(%rax,%rax,1)\n00\nmovdqu (%rax),%xmm2\nadd    $0x10,%rax\npaddd  %xmm2,%xmm0\ncmp    %rdx,%rax\njne    60 <func0+0x60>\nmovdqa %xmm0,%xmm1\nmov    %r9d,%edx\npsrldq $0x8,%xmm1\npaddd  %xmm1,%xmm0\nmovdqa %xmm0,%xmm1\npsrldq $0x4,%xmm1\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%eax\ncmp    %r9d,%r8d\nje     cf <func0+0xcf>\nmovslq %edx,%r13\nlea    0x0(,%r13,4),%r12\n00\nadd    (%rsi,%r13,4),%eax\nlea    0x1(%rdx),%r13d\ncmp    %r13d,%r8d\njle    cf <func0+0xcf>\nlea    0x2(%rdx),%r13d\nadd    0x4(%rsi,%r12,1),%eax\ncmp    %r13d,%r8d\njle    cf <func0+0xcf>\nadd    $0x3,%edx\nadd    0x8(%rsi,%r12,1),%eax\ncmp    %edx,%r8d\njle    cf <func0+0xcf>\nadd    0xc(%rsi,%r12,1),%eax\ntest   %eax,%eax\njle    dd <func0+0xdd>\nlea    -0x1(%rax,%rcx,1),%eax\ncltd\nidiv   %ecx\nadd    %eax,%r10d\nadd    $0x8,%rdi\ncmp    %rbx,%rdi\njne    38 <func0+0x38>\npop    %rbx\nmov    %r10d,%eax\npop    %rbp\npop    %r12\npop    %r13\nretq\nxor    %edx,%edx\nxor    %eax,%eax\njmp    97 <func0+0x97>\nxor    %r10d,%r10d\nmov    %r10d,%eax\nretq"
    },
    {
        "task_id": 116,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmpq   154 <func0+0x154>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x8(%rbp)\njmpq   144 <func0+0x144>\nmovl   $0x0,-0x18(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\njmp    70 <func0+0x70>\nmov    -0x14(%rbp),%eax\nand    $0x1,%eax\nadd    %eax,-0x18(%rbp)\nsarl   -0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     64 <func0+0x64>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    91 <func0+0x91>\nmov    -0x10(%rbp),%eax\nand    $0x1,%eax\nadd    %eax,-0x18(%rbp)\nsarl   -0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njg     85 <func0+0x85>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     e1 <func0+0xe1>\nmov    -0x10(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njne    140 <func0+0x140>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    140 <func0+0x140>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     29 <func0+0x29>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     1b <func0+0x1b>\nnop\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 116,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    b7 <func0+0xb7>\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r11\nmov    %esi,%ebp\nmov    %rdi,%r10\nlea    -0x1(%rsi),%r13d\nadd    $0x1,%r13\nmov    $0x1,%r12d\njmp    95 <func0+0x95>\nmov    $0x0,%ecx\njmp    7e <func0+0x7e>\nmov    %r9d,(%rbx)\nmov    %r8d,(%r11,%rdi,4)\nadd    $0x1,%rdi\ncmp    %edi,%ebp\njle    8d <func0+0x8d>\nmov    %r10,%rbx\nmov    (%r10),%r8d\nmov    (%r11,%rdi,4),%r9d\ntest   %r8d,%r8d\njle    9f <func0+0x9f>\nmov    %r8d,%eax\nmov    $0x0,%edx\nmov    %eax,%ecx\nand    $0x1,%ecx\nadd    %ecx,%edx\nsar    %eax\ntest   %eax,%eax\njg     57 <func0+0x57>\ntest   %r9d,%r9d\njle    2a <func0+0x2a>\nmov    %r9d,%eax\nmov    $0x0,%ecx\nmov    %eax,%esi\nand    $0x1,%esi\nadd    %esi,%ecx\nsar    %eax\ntest   %eax,%eax\njg     71 <func0+0x71>\ncmp    %ecx,%edx\njg     31 <func0+0x31>\ncmp    %r9d,%r8d\njle    38 <func0+0x38>\ncmp    %edx,%ecx\njne    38 <func0+0x38>\njmp    31 <func0+0x31>\nadd    $0x1,%r12\nadd    $0x4,%r10\ncmp    %r13,%r12\nje     b0 <func0+0xb0>\nmov    %r12,%rdi\njmp    40 <func0+0x40>\nmov    $0x0,%edx\nmov    $0x0,%ecx\ntest   %r9d,%r9d\njg     69 <func0+0x69>\njmp    82 <func0+0x82>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nretq"
    },
    {
        "task_id": 116,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    be <func0+0xbe>\npush   %r12\nlea    -0x1(%rsi),%r12d\nmov    %rdi,%r11\nmov    %rdi,%r10\npush   %rbp\nadd    $0x1,%r12\nmov    $0x1,%ebp\npush   %rbx\nmov    %esi,%ebx\ncmp    %rbp,%r12\nje     98 <func0+0x98>\nnopw   0x0(%rax,%rax,1)\nmov    %rbp,%rdi\nnopl   0x0(%rax,%rax,1)\nmov    (%r10),%r8d\nmov    (%r11,%rdi,4),%r9d\ntest   %r8d,%r8d\njle    b0 <func0+0xb0>\nmov    %r8d,%eax\nxor    %ecx,%ecx\nnopl   0x0(%rax)\nmov    %eax,%edx\nand    $0x1,%edx\nadd    %edx,%ecx\nsar    %eax\njne    50 <func0+0x50>\ntest   %r9d,%r9d\njle    73 <func0+0x73>\nmov    %r9d,%edx\nxor    %eax,%eax\nnopl   (%rax)\nmov    %edx,%esi\nand    $0x1,%esi\nadd    %esi,%eax\nsar    %edx\njne    68 <func0+0x68>\ncmp    %eax,%ecx\njg     a0 <func0+0xa0>\nsete   %al\ncmp    %r9d,%r8d\njle    83 <func0+0x83>\ntest   %al,%al\njne    a0 <func0+0xa0>\nadd    $0x1,%rdi\ncmp    %edi,%ebx\njg     38 <func0+0x38>\nadd    $0x1,%rbp\nadd    $0x4,%r10\ncmp    %rbp,%r12\njne    30 <func0+0x30>\npop    %rbx\npop    %rbp\npop    %r12\nretq\nnopl   (%rax)\nmov    %r9d,(%r10)\nmov    %r8d,(%r11,%rdi,4)\njmp    83 <func0+0x83>\nnopl   0x0(%rax)\nxor    %ecx,%ecx\nmov    $0x1,%eax\ntest   %r9d,%r9d\njg     60 <func0+0x60>\njmp    7a <func0+0x7a>\nretq"
    },
    {
        "task_id": 116,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    be <func0+0xbe>\npush   %r12\nlea    -0x2(%rsi),%r12d\nmov    %rdi,%r11\nmov    %rdi,%r10\npush   %rbp\nadd    $0x2,%r12\nmov    $0x1,%ebp\npush   %rbx\nmov    %esi,%ebx\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    %rbp,%rdi\nnopl   0x0(%rax,%rax,1)\nmov    (%r10),%r8d\nmov    (%r11,%rdi,4),%r9d\ntest   %r8d,%r8d\njle    b0 <func0+0xb0>\nmov    %r8d,%eax\nxor    %ecx,%ecx\nnopl   0x0(%rax)\nmov    %eax,%edx\nand    $0x1,%edx\nadd    %edx,%ecx\nsar    %eax\njne    50 <func0+0x50>\ntest   %r9d,%r9d\njle    73 <func0+0x73>\nmov    %r9d,%edx\nxor    %eax,%eax\nnopl   (%rax)\nmov    %edx,%esi\nand    $0x1,%esi\nadd    %esi,%eax\nsar    %edx\njne    68 <func0+0x68>\ncmp    %eax,%ecx\njg     a0 <func0+0xa0>\nsete   %al\ncmp    %r9d,%r8d\njle    83 <func0+0x83>\ntest   %al,%al\njne    a0 <func0+0xa0>\nadd    $0x1,%rdi\ncmp    %edi,%ebx\njg     38 <func0+0x38>\nadd    $0x1,%rbp\nadd    $0x4,%r10\ncmp    %rbp,%r12\njne    30 <func0+0x30>\npop    %rbx\npop    %rbp\npop    %r12\nretq\nnopl   (%rax)\nmov    %r9d,(%r10)\nmov    %r8d,(%r11,%rdi,4)\njmp    83 <func0+0x83>\nnopl   0x0(%rax)\nxor    %ecx,%ecx\nmov    $0x1,%eax\ntest   %r9d,%r9d\njg     60 <func0+0x60>\njmp    7a <func0+0x7a>\nretq"
    },
    {
        "task_id": 117,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x58,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %esi,-0x4c(%rbp)\nmov    %rdx,-0x58(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x28(%rbp)\nmovq   $0x0,-0x30(%rbp)\n00\nmovl   $0x0,-0x40(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncallq  4c <func0+0x4c>\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,%rdi\ncallq  60 <func0+0x60>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x34(%rbp)\njmpq   1e9 <func0+0x1e9>\ncallq  75 <func0+0x75>\nmov    (%rax),%rax\nmov    -0x34(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x48(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovsbq %dl,%rdx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x2000,%eax\ntest   %eax,%eax\njne    b9 <func0+0xb9>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    168 <func0+0x168>\nmov    -0x40(%rbp),%eax\ncmp    -0x4c(%rbp),%eax\njne    156 <func0+0x156>\nmov    -0x34(%rbp),%eax\nsub    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x3c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  f7 <func0+0xf7>\nmov    %rax,-0x30(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  107 <func0+0x107>\nadd    $0x1,%rax\nmov    -0x3c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x30(%rbp),%rdx\nlea    (%rcx,%rdx,1),%rbx\nmov    %rax,%rdi\ncallq  129 <func0+0x129>\nmov    %rax,(%rbx)\nmov    -0x3c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  152 <func0+0x152>\naddl   $0x1,-0x3c(%rbp)\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x38(%rbp)\nmovl   $0x0,-0x40(%rbp)\njmp    1e5 <func0+0x1e5>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x34(%rbp),%eax\nsub    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmovzbl (%rcx),%eax\nmov    %al,(%rdx)\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncallq  1ac <func0+0x1ac>\ntest   %rax,%rax\njne    1e5 <func0+0x1e5>\ncallq  1b6 <func0+0x1b6>\nmov    (%rax),%rax\nmov    -0x34(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x48(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovzbl %dl,%edx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\nje     1e5 <func0+0x1e5>\naddl   $0x1,-0x40(%rbp)\naddl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncltq\ncmp    %rax,-0x20(%rbp)\njae    70 <func0+0x70>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  204 <func0+0x204>\nmov    -0x58(%rbp),%rax\nmov    -0x3c(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%rax\nadd    $0x58,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 117,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,%r14\nmov    %esi,0x18(%rsp)\nmov    %rdx,0x28(%rsp)\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nmov    %rcx,%rdi\nnot    %rdi\nlea    -0x1(%rdi),%rax\nmov    %rax,0x8(%rsp)\ncallq  40 <func0+0x40>\nmov    %rax,0x10(%rsp)\ncallq  4a <func0+0x4a>\nmov    %rax,%r15\nmov    $0x0,%ebx\nmov    $0x0,%r13d\nmovl   $0x0,0x1c(%rsp)\n00\nmovl   $0x0,0x4(%rsp)\n00\nmovq   $0x0,0x20(%rsp)\n00 00\njmp    9f <func0+0x9f>\nmov    0x4(%rsp),%edx\ncmp    %edx,0x18(%rsp)\nje     f8 <func0+0xf8>\nmov    (%rsp),%r13d\nadd    $0x1,%r13d\nmovl   $0x0,0x4(%rsp)\n00\nlea    0x1(%rbx),%rax\ncmp    %rbx,0x8(%rsp)\nje     162 <func0+0x162>\nmov    %rax,%rbx\nmov    %ebx,(%rsp)\nmov    %ebx,%eax\nmov    (%r15),%r12\nmovzbl (%r14,%rbx,1),%ebp\nmovsbq %bpl,%rdx\ntestb  $0x20,0x1(%r12,%rdx,2)\njne    73 <func0+0x73>\ntest   %bpl,%bpl\nje     73 <func0+0x73>\nsub    %r13d,%eax\ncltq\nmov    0x10(%rsp),%rdi\nmov    %bpl,(%rdi,%rax,1)\nmovsbl %bpl,%esi\nlea    0x0(%rip),%rdi\ncallq  db <func0+0xdb>\ntest   %rax,%rax\njne    8d <func0+0x8d>\nmovzbl %bpl,%ebp\nmovzwl (%r12,%rbp,2),%eax\nand    $0x400,%ax\ncmp    $0x1,%ax\nsbbl   $0xffffffff,0x4(%rsp)\njmp    8d <func0+0x8d>\nsub    %r13d,%eax\ncltq\nmov    0x10(%rsp),%r12\nmovb   $0x0,(%r12,%rax,1)\naddl   $0x1,0x1c(%rsp)\nmov    0x1c(%rsp),%eax\nmovslq %eax,%rbp\nshl    $0x3,%rbp\nmov    %rbp,%rsi\nmov    0x20(%rsp),%rdi\ncallq  124 <func0+0x124>\nmov    %rax,%r13\nmov    %rax,0x20(%rsp)\nmov    $0x0,%eax\nmov    $0xffffffffffffffff,%rcx\nmov    %r12,0x10(%rsp)\nmov    %r12,%rdi\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nmov    %rcx,%rdi\ncallq  14d <func0+0x14d>\nmov    %rax,%rdi\nmov    %rax,-0x8(%r13,%rbp,1)\nmov    %r12,%rsi\ncallq  15d <func0+0x15d>\njmpq   7d <func0+0x7d>\nmov    0x10(%rsp),%rdi\ncallq  16c <func0+0x16c>\nmov    0x28(%rsp),%rax\nmov    0x1c(%rsp),%esi\nmov    %esi,(%rax)\nmov    0x20(%rsp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 117,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nxor    %r15d,%r15d\npush   %r14\nxor    %r14d,%r14d\npush   %r13\nmov    %rdi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %esi,0xc(%rsp)\nmov    %rdx,0x28(%rsp)\ncallq  29 <func0+0x29>\nlea    0x1(%rax),%rdi\nmov    %rax,%rbx\ncallq  35 <func0+0x35>\nadd    $0x1,%ebx\nmov    %rax,%rbp\ncallq  40 <func0+0x40>\nmovl   $0x0,0x20(%rsp)\n00\nxor    %r10d,%r10d\nxor    %r9d,%r9d\nmov    (%rax),%r12\njmp    72 <func0+0x72>\nnopl   0x0(%rax,%rax,1)\ncmp    %r9d,0xc(%rsp)\nje     110 <func0+0x110>\nmov    %r15d,%r10d\nxor    %r9d,%r9d\nadd    $0x1,%r13\ncmp    %r15d,%ebx\nje     e4 <func0+0xe4>\nmovsbq 0x0(%r13),%rsi\nmov    %r15d,%eax\nadd    $0x1,%r15d\nmov    %rsi,%rdx\ntestb  $0x20,0x1(%r12,%rsi,2)\njne    58 <func0+0x58>\ntest   %sil,%sil\nje     58 <func0+0x58>\nsub    %r10d,%eax\nlea    0x0(%rip),%rdi\nmov    %r9d,0x24(%rsp)\ncltq\nmov    %r10d,0x18(%rsp)\nmov    %sil,0x0(%rbp,%rax,1)\nmovsbl %sil,%esi\nmov    %dl,0x10(%rsp)\ncallq  b6 <func0+0xb6>\nmovzbl 0x10(%rsp),%edx\nmov    0x18(%rsp),%r10d\ntest   %rax,%rax\nmov    0x24(%rsp),%r9d\njne    69 <func0+0x69>\nmovzwl (%r12,%rdx,2),%eax\nand    $0x400,%ax\ncmp    $0x1,%ax\nsbb    $0xffffffff,%r9d\nadd    $0x1,%r13\ncmp    %r15d,%ebx\njne    72 <func0+0x72>\nmov    %rbp,%rdi\ncallq  ec <func0+0xec>\nmov    0x28(%rsp),%rax\nmov    0x20(%rsp),%ebx\nmov    %ebx,(%rax)\nadd    $0x38,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\nsub    %r10d,%eax\naddl   $0x1,0x20(%rsp)\nmov    %r14,%rdi\ncltq\nmovb   $0x0,0x0(%rbp,%rax,1)\nmovslq 0x20(%rsp),%rax\nshl    $0x3,%rax\nmov    %rax,%rsi\nmov    %rax,0x18(%rsp)\ncallq  138 <func0+0x138>\nmov    %rbp,%rdx\nmov    %rax,%r14\nmov    (%rdx),%esi\nadd    $0x4,%rdx\nlea    -0x1010101(%rsi),%eax\nnot    %esi\nand    %esi,%eax\nand    $0x80808080,%eax\nje     13e <func0+0x13e>\nmov    %eax,%esi\nshr    $0x10,%esi\ntest   $0x8080,%eax\ncmove  %esi,%eax\nlea    0x2(%rdx),%rsi\ncmove  %rsi,%rdx\nmov    %eax,%ecx\nadd    %al,%cl\nsbb    $0x3,%rdx\nsub    %rbp,%rdx\nadd    $0x1,%rdx\nmov    %rdx,%rdi\nmov    %rdx,0x10(%rsp)\ncallq  186 <func0+0x186>\nmov    0x10(%rsp),%rdx\nmov    %rbp,%rsi\nmov    %rax,%rdi\nmov    0x18(%rsp),%rax\nmov    %rdi,-0x8(%r14,%rax,1)\ncallq  1a0 <func0+0x1a0>\njmpq   63 <func0+0x63>"
    },
    {
        "task_id": 117,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nxor    %r15d,%r15d\npush   %r14\nxor    %r14d,%r14d\npush   %r13\nmov    %rdi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %esi,0xc(%rsp)\nmov    %rdx,0x28(%rsp)\ncallq  29 <func0+0x29>\nlea    0x1(%rax),%rdi\nmov    %rax,%rbx\ncallq  35 <func0+0x35>\nadd    $0x1,%ebx\nmov    %rax,%rbp\ncallq  40 <func0+0x40>\nmovl   $0x0,0x20(%rsp)\n00\nxor    %r10d,%r10d\nxor    %r9d,%r9d\nmov    (%rax),%r12\njmp    72 <func0+0x72>\nnopl   0x0(%rax,%rax,1)\ncmp    %r9d,0xc(%rsp)\nje     110 <func0+0x110>\nmov    %r15d,%r10d\nxor    %r9d,%r9d\nadd    $0x1,%r13\ncmp    %r15d,%ebx\nje     e4 <func0+0xe4>\nmovsbq 0x0(%r13),%rsi\nmov    %r15d,%eax\nadd    $0x1,%r15d\nmov    %rsi,%rdx\ntestb  $0x20,0x1(%r12,%rsi,2)\njne    58 <func0+0x58>\ntest   %sil,%sil\nje     58 <func0+0x58>\nsub    %r10d,%eax\nlea    0x0(%rip),%rdi\nmov    %r9d,0x24(%rsp)\ncltq\nmov    %r10d,0x18(%rsp)\nmov    %sil,0x0(%rbp,%rax,1)\nmovsbl %sil,%esi\nmov    %dl,0x10(%rsp)\ncallq  b6 <func0+0xb6>\nmovzbl 0x10(%rsp),%edx\nmov    0x18(%rsp),%r10d\ntest   %rax,%rax\nmov    0x24(%rsp),%r9d\njne    69 <func0+0x69>\nmovzwl (%r12,%rdx,2),%eax\nand    $0x400,%ax\ncmp    $0x1,%ax\nsbb    $0xffffffff,%r9d\nadd    $0x1,%r13\ncmp    %r15d,%ebx\njne    72 <func0+0x72>\nmov    %rbp,%rdi\ncallq  ec <func0+0xec>\nmov    0x28(%rsp),%rax\nmov    0x20(%rsp),%ebx\nmov    %ebx,(%rax)\nadd    $0x38,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\nsub    %r10d,%eax\naddl   $0x1,0x20(%rsp)\nmov    %r14,%rdi\ncltq\nmovb   $0x0,0x0(%rbp,%rax,1)\nmovslq 0x20(%rsp),%rax\nshl    $0x3,%rax\nmov    %rax,%rsi\nmov    %rax,0x18(%rsp)\ncallq  138 <func0+0x138>\nmov    %rbp,%rdx\nmov    %rax,%r14\nmov    (%rdx),%esi\nadd    $0x4,%rdx\nlea    -0x1010101(%rsi),%eax\nnot    %esi\nand    %esi,%eax\nand    $0x80808080,%eax\nje     13e <func0+0x13e>\nmov    %eax,%esi\nshr    $0x10,%esi\ntest   $0x8080,%eax\ncmove  %esi,%eax\nlea    0x2(%rdx),%rsi\ncmove  %rsi,%rdx\nmov    %eax,%ecx\nadd    %al,%cl\nsbb    $0x3,%rdx\nsub    %rbp,%rdx\nadd    $0x1,%rdx\nmov    %rdx,%rdi\nmov    %rdx,0x10(%rsp)\ncallq  186 <func0+0x186>\nmov    0x10(%rsp),%rdx\nmov    %rbp,%rsi\nmov    %rax,%rdi\nmov    0x18(%rsp),%rax\nmov    %rdi,-0x8(%r14,%rax,1)\ncallq  1a0 <func0+0x1a0>\njmpq   63 <func0+0x63>"
    },
    {
        "task_id": 118,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  27 <func0+0x27>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nsub    $0x2,%eax\nmov    %eax,-0x14(%rbp)\njmpq   d5 <func0+0xd5>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncallq  5b <func0+0x5b>\ntest   %rax,%rax\nje     d1 <func0+0xd1>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncallq  84 <func0+0x84>\ntest   %rax,%rax\njne    d1 <func0+0xd1>\nmov    -0x14(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncallq  ad <func0+0xad>\ntest   %rax,%rax\njne    d1 <func0+0xd1>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,0x0(%rip)\nlea    0x0(%rip),%rax\njmp    ed <func0+0xed>\nsubl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     3a <func0+0x3a>\nmovb   $0x0,0x0(%rip)\nlea    0x0(%rip),%rax\nleaveq\nretq"
    },
    {
        "task_id": 118,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%rdx\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x3(%rcx),%eax\ntest   %eax,%eax\njle    a8 <func0+0xa8>\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    -0x1(%rcx),%rsi\ncltq\nlea    (%rdx,%rax,1),%rbx\nlea    -0x1(%rdx,%rax,1),%r14\nlea    -0x3(%rsi),%eax\nsub    %rax,%r14\nlea    0x0(%rip),%r12\njmp    52 <func0+0x52>\nsub    $0x1,%rbx\ncmp    %r14,%rbx\nje     91 <func0+0x91>\nmovzbl (%rbx),%ebp\nmovsbl %bpl,%esi\nmov    %r12,%rdi\ncallq  61 <func0+0x61>\ntest   %rax,%rax\nje     49 <func0+0x49>\nmovsbl 0x1(%rbx),%esi\nmov    %r12,%rdi\ncallq  72 <func0+0x72>\ntest   %rax,%rax\njne    49 <func0+0x49>\nmovsbl -0x1(%rbx),%esi\nmov    %r12,%rdi\ncallq  83 <func0+0x83>\ntest   %rax,%rax\njne    49 <func0+0x49>\nmov    %bpl,0x0(%rip)\njmp    98 <func0+0x98>\nmovb   $0x0,0x0(%rip)\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nmovb   $0x0,0x0(%rip)\nlea    0x0(%rip),%rax\nretq"
    },
    {
        "task_id": 118,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\ncallq  16 <func0+0x16>\nlea    -0x2(%rax),%edx\ntest   %edx,%edx\njle    90 <func0+0x90>\nmovslq %edx,%rdx\nsub    $0x3,%eax\nlea    0x0(%rip),%r12\nlea    -0x1(%rbp,%rdx,1),%r13\nlea    0x0(%rbp,%rdx,1),%rbx\nsub    %rax,%r13\njmp    49 <func0+0x49>\nnopl   0x0(%rax)\nsub    $0x1,%rbx\ncmp    %rbx,%r13\nje     90 <func0+0x90>\nmovsbl (%rbx),%esi\nmov    %r12,%rdi\nmov    %esi,%ebp\ncallq  56 <func0+0x56>\ntest   %rax,%rax\nje     40 <func0+0x40>\nmovsbl 0x1(%rbx),%esi\nmov    %r12,%rdi\ncallq  67 <func0+0x67>\ntest   %rax,%rax\njne    40 <func0+0x40>\nmovsbl -0x1(%rbx),%esi\nmov    %r12,%rdi\ncallq  78 <func0+0x78>\ntest   %rax,%rax\njne    40 <func0+0x40>\nmov    %bpl,0x0(%rip)\njmp    97 <func0+0x97>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmovb   $0x0,0x0(%rip)\nadd    $0x8,%rsp\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 118,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\ncallq  16 <func0+0x16>\nlea    -0x2(%rax),%edx\ntest   %edx,%edx\njle    90 <func0+0x90>\nmovslq %edx,%rdx\nsub    $0x3,%eax\nlea    0x0(%rip),%r12\nlea    -0x1(%rbp,%rdx,1),%r13\nlea    0x0(%rbp,%rdx,1),%rbx\nsub    %rax,%r13\njmp    49 <func0+0x49>\nnopl   0x0(%rax)\nsub    $0x1,%rbx\ncmp    %rbx,%r13\nje     90 <func0+0x90>\nmovsbl (%rbx),%esi\nmov    %r12,%rdi\nmov    %esi,%ebp\ncallq  56 <func0+0x56>\ntest   %rax,%rax\nje     40 <func0+0x40>\nmovsbl 0x1(%rbx),%esi\nmov    %r12,%rdi\ncallq  67 <func0+0x67>\ntest   %rax,%rax\njne    40 <func0+0x40>\nmovsbl -0x1(%rbx),%esi\nmov    %r12,%rdi\ncallq  78 <func0+0x78>\ntest   %rax,%rax\njne    40 <func0+0x40>\nmov    %bpl,0x0(%rip)\njmp    97 <func0+0x97>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmovb   $0x0,0x0(%rip)\nadd    $0x8,%rsp\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 119,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  27 <func0+0x27>\nmov    %eax,-0x8(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncallq  36 <func0+0x36>\nmov    %eax,-0x4(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    8a <func0+0x8a>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x28,%al\njne    61 <func0+0x61>\naddl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x29,%al\njne    79 <func0+0x79>\nsubl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njns    86 <func0+0x86>\nmovl   $0x0,-0xc(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njl     49 <func0+0x49>\nmovl   $0x0,-0x10(%rbp)\njmp    dc <func0+0xdc>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x28,%al\njne    b3 <func0+0xb3>\naddl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x29,%al\njne    cb <func0+0xcb>\nsubl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njns    d8 <func0+0xd8>\nmovl   $0x0,-0xc(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     9b <func0+0x9b>\ncmpl   $0x0,-0x14(%rbp)\njne    fc <func0+0xfc>\ncmpl   $0x0,-0xc(%rbp)\nje     fc <func0+0xfc>\nlea    0x0(%rip),%rax\njmpq   1ca <func0+0x1ca>\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    154 <func0+0x154>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x28,%al\njne    12b <func0+0x12b>\naddl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x29,%al\njne    143 <func0+0x143>\nsubl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njns    150 <func0+0x150>\nmovl   $0x0,-0xc(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     113 <func0+0x113>\nmovl   $0x0,-0x10(%rbp)\njmp    1a6 <func0+0x1a6>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x28,%al\njne    17d <func0+0x17d>\naddl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x29,%al\njne    195 <func0+0x195>\nsubl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njns    1a2 <func0+0x1a2>\nmovl   $0x0,-0xc(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njl     165 <func0+0x165>\ncmpl   $0x0,-0x14(%rbp)\njne    1c3 <func0+0x1c3>\ncmpl   $0x0,-0xc(%rbp)\nje     1c3 <func0+0x1c3>\nlea    0x0(%rip),%rax\njmp    1ca <func0+0x1ca>\nlea    0x0(%rip),%rax\nleaveq\nretq"
    },
    {
        "task_id": 119,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r8\nmov    $0xffffffffffffffff,%rbx\nmov    $0x0,%eax\nmov    %rbx,%rcx\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%r10\nmov    %r10d,%r9d\nmov    %rbx,%rcx\nmov    %rsi,%rdi\nrepnz scas %es:(%rdi),%al\nmov    %rcx,%rax\nnot    %rax\nlea    -0x1(%rax),%rbx\nmov    %ebx,%r11d\ntest   %r10d,%r10d\njle    1a8 <func0+0x1a8>\nmov    %r8,%rcx\nlea    -0x1(%r10),%eax\nlea    0x1(%r8,%rax,1),%r12\nmov    $0x1,%edx\nmov    $0x0,%eax\nmov    $0x0,%ebp\njmp    7d <func0+0x7d>\ncmp    $0x29,%dil\nsete   %dil\nmovzbl %dil,%edi\nsub    %edi,%eax\ntest   %eax,%eax\ncmovs  %ebp,%edx\nadd    $0x1,%rcx\ncmp    %r12,%rcx\nje     8b <func0+0x8b>\nmovzbl (%rcx),%edi\ncmp    $0x28,%dil\njne    61 <func0+0x61>\nadd    $0x1,%eax\njmp    6f <func0+0x6f>\ntest   %ebx,%ebx\njle    cf <func0+0xcf>\nmov    %rsi,%rcx\nlea    -0x1(%rbx),%edi\nlea    0x1(%rsi,%rdi,1),%rbp\nmov    $0x0,%ebx\njmp    c1 <func0+0xc1>\ncmp    $0x29,%dil\nsete   %dil\nmovzbl %dil,%edi\nsub    %edi,%eax\ntest   %eax,%eax\ncmovs  %ebx,%edx\nadd    $0x1,%rcx\ncmp    %rcx,%rbp\nje     180 <func0+0x180>\nmovzbl (%rcx),%edi\ncmp    $0x28,%dil\njne    a1 <func0+0xa1>\nadd    $0x1,%eax\njmp    af <func0+0xaf>\ntest   %eax,%eax\njne    e2 <func0+0xe2>\nlea    0x0(%rip),%rcx\ntest   %edx,%edx\njne    178 <func0+0x178>\nmov    $0x1,%edx\nmov    $0x0,%eax\nlea    0x0(%rip),%rcx\ntest   %r10d,%r10d\njg     12a <func0+0x12a>\njmp    178 <func0+0x178>\ncmp    $0x29,%dil\nsete   %dil\nmovzbl %dil,%edi\nsub    %edi,%eax\ntest   %eax,%eax\ncmovs  %ebx,%edx\nadd    $0x1,%rcx\ncmp    %ecx,%r11d\njle    125 <func0+0x125>\nmovzbl (%rsi,%rcx,1),%edi\ncmp    $0x28,%dil\njne    fa <func0+0xfa>\nadd    $0x1,%eax\njmp    108 <func0+0x108>\ntest   %r10d,%r10d\njle    162 <func0+0x162>\nmov    $0x0,%ecx\nmov    $0x0,%edi\njmp    152 <func0+0x152>\ncmp    $0x29,%sil\nsete   %sil\nmovzbl %sil,%esi\nsub    %esi,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rcx\ncmp    %ecx,%r9d\njle    162 <func0+0x162>\nmovzbl (%r8,%rcx,1),%esi\ncmp    $0x28,%sil\njne    136 <func0+0x136>\nadd    $0x1,%eax\njmp    144 <func0+0x144>\ntest   %eax,%eax\njne    171 <func0+0x171>\nlea    0x0(%rip),%rcx\ntest   %edx,%edx\njne    178 <func0+0x178>\nlea    0x0(%rip),%rcx\nmov    %rcx,%rax\npop    %rbx\npop    %rbp\npop    %r12\nretq\ntest   %edx,%edx\nje     18f <func0+0x18f>\nlea    0x0(%rip),%rcx\ntest   %eax,%eax\nje     178 <func0+0x178>\nmov    $0x0,%ecx\nmov    $0x1,%edx\nmov    $0x0,%eax\nmov    $0x0,%ebx\njmpq   116 <func0+0x116>\nmov    $0x1,%edx\nmov    $0x0,%eax\ntest   %ebx,%ebx\njg     8f <func0+0x8f>\nlea    0x0(%rip),%rcx\njmp    178 <func0+0x178>"
    },
    {
        "task_id": 119,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x8,%rsp\ncallq  19 <func0+0x19>\nmov    %rbx,%rdi\nmov    %rax,%r13\nmov    %eax,%r12d\ncallq  27 <func0+0x27>\ntest   %r13d,%r13d\njle    1c0 <func0+0x1c0>\nlea    -0x1(%r13),%edx\nmov    %rbp,%rsi\nmov    $0x1,%ecx\nxor    %r8d,%r8d\nlea    0x1(%rbp,%rdx,1),%r9\nxor    %edx,%edx\njmp    6d <func0+0x6d>\nnopl   0x0(%rax,%rax,1)\n00\ncmp    $0x29,%dil\nsete   %dil\nmovzbl %dil,%edi\nsub    %edi,%edx\ntest   %edx,%edx\ncmovs  %r8d,%ecx\nadd    $0x1,%rsi\ncmp    %r9,%rsi\nje     88 <func0+0x88>\nmovzbl (%rsi),%edi\ncmp    $0x28,%dil\njne    50 <func0+0x50>\nadd    $0x1,%edx\ntest   %edx,%edx\ncmovs  %r8d,%ecx\nadd    $0x1,%rsi\ncmp    %r9,%rsi\njne    6d <func0+0x6d>\ntest   %eax,%eax\njle    1d8 <func0+0x1d8>\nsub    $0x1,%eax\nmov    %rbx,%rsi\nxor    %r9d,%r9d\nlea    0x1(%rbx,%rax,1),%r8\nmov    %rbx,%rax\njmp    c5 <func0+0xc5>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x29,%dil\nsete   %dil\nmovzbl %dil,%edi\nsub    %edi,%edx\ntest   %edx,%edx\ncmovs  %r9d,%ecx\nadd    $0x1,%rax\ncmp    %r8,%rax\nje     e0 <func0+0xe0>\nmovzbl (%rax),%edi\ncmp    $0x28,%dil\njne    a8 <func0+0xa8>\nadd    $0x1,%edx\ntest   %edx,%edx\ncmovs  %r9d,%ecx\nadd    $0x1,%rax\ncmp    %r8,%rax\njne    c5 <func0+0xc5>\ntest   %edx,%edx\njne    100 <func0+0x100>\nand    $0x1,%ecx\nlea    0x0(%rip),%rax\nje     100 <func0+0x100>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%edx\nxor    %eax,%eax\nxor    %edi,%edi\njmp    129 <func0+0x129>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x29,%cl\nsete   %cl\nmovzbl %cl,%ecx\nsub    %ecx,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rsi\ncmp    %r8,%rsi\nje     142 <func0+0x142>\nmovzbl (%rsi),%ecx\ncmp    $0x28,%cl\njne    110 <func0+0x110>\nadd    $0x1,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rsi\ncmp    %r8,%rsi\njne    129 <func0+0x129>\ntest   %r13d,%r13d\njle    188 <func0+0x188>\nxor    %ecx,%ecx\nxor    %edi,%edi\njmp    16c <func0+0x16c>\nnopl   (%rax)\ncmp    $0x29,%sil\nsete   %sil\nmovzbl %sil,%esi\nsub    %esi,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rcx\ncmp    %ecx,%r12d\njle    188 <func0+0x188>\nmovzbl 0x0(%rbp,%rcx,1),%esi\ncmp    $0x28,%sil\njne    150 <func0+0x150>\nadd    $0x1,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rcx\ncmp    %ecx,%r12d\njg     16c <func0+0x16c>\ntest   %eax,%eax\njne    1a8 <func0+0x1a8>\nand    $0x1,%edx\nje     1a8 <func0+0x1a8>\nadd    $0x8,%rsp\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopl   0x0(%rax,%rax,1)\nadd    $0x8,%rsp\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopw   0x0(%rax,%rax,1)\nxor    %edx,%edx\nmov    $0x1,%ecx\ntest   %eax,%eax\njg     90 <func0+0x90>\njmp    191 <func0+0x191>\nnopl   0x0(%rax)\ntest   %edx,%edx\njne    1ec <func0+0x1ec>\nand    $0x1,%ecx\nlea    0x0(%rip),%rax\njne    f0 <func0+0xf0>\nxor    %eax,%eax\nmov    $0x1,%edx\njmpq   147 <func0+0x147>"
    },
    {
        "task_id": 119,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x8,%rsp\ncallq  19 <func0+0x19>\nmov    %rbx,%rdi\nmov    %rax,%r13\nmov    %eax,%r12d\ncallq  27 <func0+0x27>\ntest   %r13d,%r13d\njle    1c0 <func0+0x1c0>\nlea    -0x1(%r13),%edx\nmov    %rbp,%rsi\nmov    $0x1,%ecx\nxor    %r8d,%r8d\nlea    0x1(%rbp,%rdx,1),%r9\nxor    %edx,%edx\njmp    6d <func0+0x6d>\nnopl   0x0(%rax,%rax,1)\n00\ncmp    $0x29,%dil\nsete   %dil\nmovzbl %dil,%edi\nsub    %edi,%edx\ntest   %edx,%edx\ncmovs  %r8d,%ecx\nadd    $0x1,%rsi\ncmp    %r9,%rsi\nje     88 <func0+0x88>\nmovzbl (%rsi),%edi\ncmp    $0x28,%dil\njne    50 <func0+0x50>\nadd    $0x1,%edx\ntest   %edx,%edx\ncmovs  %r8d,%ecx\nadd    $0x1,%rsi\ncmp    %r9,%rsi\njne    6d <func0+0x6d>\ntest   %eax,%eax\njle    1d8 <func0+0x1d8>\nsub    $0x1,%eax\nmov    %rbx,%rsi\nxor    %r9d,%r9d\nlea    0x1(%rbx,%rax,1),%r8\nmov    %rbx,%rax\njmp    c5 <func0+0xc5>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x29,%dil\nsete   %dil\nmovzbl %dil,%edi\nsub    %edi,%edx\ntest   %edx,%edx\ncmovs  %r9d,%ecx\nadd    $0x1,%rax\ncmp    %rax,%r8\nje     e0 <func0+0xe0>\nmovzbl (%rax),%edi\ncmp    $0x28,%dil\njne    a8 <func0+0xa8>\nadd    $0x1,%edx\ntest   %edx,%edx\ncmovs  %r9d,%ecx\nadd    $0x1,%rax\ncmp    %rax,%r8\njne    c5 <func0+0xc5>\ntest   %edx,%edx\njne    100 <func0+0x100>\nand    $0x1,%ecx\nlea    0x0(%rip),%rax\nje     100 <func0+0x100>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%edx\nxor    %eax,%eax\nxor    %edi,%edi\njmp    129 <func0+0x129>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x29,%cl\nsete   %cl\nmovzbl %cl,%ecx\nsub    %ecx,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rsi\ncmp    %rsi,%r8\nje     142 <func0+0x142>\nmovzbl (%rsi),%ecx\ncmp    $0x28,%cl\njne    110 <func0+0x110>\nadd    $0x1,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rsi\ncmp    %rsi,%r8\njne    129 <func0+0x129>\ntest   %r13d,%r13d\njle    188 <func0+0x188>\nxor    %ecx,%ecx\nxor    %edi,%edi\njmp    16c <func0+0x16c>\nnopl   (%rax)\ncmp    $0x29,%sil\nsete   %sil\nmovzbl %sil,%esi\nsub    %esi,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rcx\ncmp    %ecx,%r12d\njle    188 <func0+0x188>\nmovzbl 0x0(%rbp,%rcx,1),%esi\ncmp    $0x28,%sil\njne    150 <func0+0x150>\nadd    $0x1,%eax\ntest   %eax,%eax\ncmovs  %edi,%edx\nadd    $0x1,%rcx\ncmp    %ecx,%r12d\njg     16c <func0+0x16c>\ntest   %eax,%eax\njne    1a8 <func0+0x1a8>\nand    $0x1,%edx\nje     1a8 <func0+0x1a8>\nadd    $0x8,%rsp\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopl   0x0(%rax,%rax,1)\nadd    $0x8,%rsp\nlea    0x0(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopw   0x0(%rax,%rax,1)\nxor    %edx,%edx\nmov    $0x1,%ecx\ntest   %eax,%eax\njg     90 <func0+0x90>\njmp    191 <func0+0x191>\nnopl   0x0(%rax)\ntest   %edx,%edx\njne    1ec <func0+0x1ec>\nand    $0x1,%ecx\nlea    0x0(%rip),%rax\njne    f0 <func0+0xf0>\nxor    %eax,%eax\nmov    $0x1,%edx\njmpq   147 <func0+0x147>"
    },
    {
        "task_id": 120,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    %rcx,-0x28(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmpq   e3 <func0+0xe3>\nmovl   $0x0,-0xc(%rbp)\njmpq   cd <func0+0xcd>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    c9 <func0+0xc9>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0xc(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0xc(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    -0x10(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0xc(%rbp)\njl     2e <func0+0x2e>\naddl   $0x1,-0x10(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x10(%rbp)\njl     22 <func0+0x22>\nmovl   $0x0,-0x8(%rbp)\njmp    136 <func0+0x136>\nmov    -0x1c(%rbp),%eax\nsub    -0x20(%rbp),%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nadd    %edx,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     fb <func0+0xfb>\nnop\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 120,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edx,%ebx\nlea    -0x1(%rsi),%r11d\ntest   %r11d,%r11d\njle    4c <func0+0x4c>\nlea    0x4(%rdi),%rdx\njmp    3a <func0+0x3a>\nadd    $0x4,%rax\ncmp    %r10,%rax\nje     34 <func0+0x34>\nmov    (%rax),%r8d\nmov    0x4(%rax),%r9d\ncmp    %r9d,%r8d\njle    16 <func0+0x16>\nmov    %r9d,(%rax)\nmov    %r8d,0x4(%rax)\njmp    16 <func0+0x16>\nsub    $0x1,%r11d\nje     4c <func0+0x4c>\ntest   %r11d,%r11d\njle    34 <func0+0x34>\nmov    %rdi,%rax\nlea    -0x1(%r11),%r8d\nlea    (%rdx,%r8,4),%r10\njmp    1f <func0+0x1f>\ntest   %ebx,%ebx\njle    78 <func0+0x78>\nlea    -0x1(%rbx),%r8d\nmovslq %esi,%rsi\nmovslq %ebx,%rbx\nsub    %rbx,%rsi\nlea    (%rdi,%rsi,4),%rsi\nmov    $0x0,%eax\nmov    (%rsi,%rax,4),%edx\nmov    %edx,(%rcx,%rax,4)\nmov    %rax,%rdx\nadd    $0x1,%rax\ncmp    %r8,%rdx\njne    66 <func0+0x66>\npop    %rbx\nretq"
    },
    {
        "task_id": 120,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    -0x1(%rsi),%r8d\npush   %rbx\nmov    %edx,%ebx\ntest   %r8d,%r8d\njle    54 <func0+0x54>\nlea    0x4(%rdi),%rdx\nnopl   0x0(%rax)\nsub    $0x1,%r8d\nmov    %rdi,%rax\nmov    %r8,%r11\nlea    (%rdx,%r8,4),%r10\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    (%rax),%r8d\nmov    0x4(%rax),%r9d\ncmp    %r9d,%r8d\njle    43 <func0+0x43>\nmov    %r9d,(%rax)\nmov    %r8d,0x4(%rax)\nadd    $0x4,%rax\ncmp    %rax,%r10\njne    30 <func0+0x30>\nmov    %r11d,%r8d\ntest   %r11d,%r11d\njne    18 <func0+0x18>\ntest   %ebx,%ebx\njle    82 <func0+0x82>\nsub    %ebx,%esi\nlea    -0x1(%rbx),%r8d\nmovslq %esi,%rax\nlea    (%rdi,%rax,4),%rsi\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    (%rsi,%rax,4),%edx\nmov    %edx,(%rcx,%rax,4)\nmov    %rax,%rdx\nadd    $0x1,%rax\ncmp    %rdx,%r8\njne    70 <func0+0x70>\npop    %rbx\nretq"
    },
    {
        "task_id": 120,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nlea    -0x1(%rsi),%r8d\npush   %rbx\nmov    %edx,%ebx\ntest   %r8d,%r8d\njle    54 <func0+0x54>\nlea    0x4(%rdi),%rdx\nnopl   0x0(%rax)\nsub    $0x1,%r8d\nmov    %rdi,%rax\nmov    %r8,%r11\nlea    (%rdx,%r8,4),%r10\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    (%rax),%r8d\nmov    0x4(%rax),%r9d\ncmp    %r9d,%r8d\njle    43 <func0+0x43>\nmov    %r9d,(%rax)\nmov    %r8d,0x4(%rax)\nadd    $0x4,%rax\ncmp    %r10,%rax\njne    30 <func0+0x30>\nmov    %r11d,%r8d\ntest   %r11d,%r11d\njne    18 <func0+0x18>\ntest   %ebx,%ebx\njle    fa <func0+0xfa>\nsub    %ebx,%esi\nlea    -0x1(%rbx),%eax\nmovslq %esi,%r8\nlea    (%rdi,%r8,4),%rdx\nlea    0x10(%rdi,%r8,4),%r8\ncmp    %r8,%rcx\nlea    0x10(%rcx),%r8\nsetae  %r9b\ncmp    %r8,%rdx\nsetae  %r8b\nor     %r8b,%r9b\nje     fc <func0+0xfc>\ncmp    $0x3,%eax\njbe    fc <func0+0xfc>\nmov    %ebx,%r8d\nxor    %eax,%eax\nshr    $0x2,%r8d\nshl    $0x4,%r8\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmovdqu (%rdx,%rax,1),%xmm0\nmovups %xmm0,(%rcx,%rax,1)\nadd    $0x10,%rax\ncmp    %r8,%rax\njne    a0 <func0+0xa0>\nmov    %ebx,%eax\nand    $0xfffffffc,%eax\ntest   $0x3,%bl\nje     fa <func0+0xfa>\nlea    (%rsi,%rax,1),%edx\nmovslq %edx,%rdx\nmov    (%rdi,%rdx,4),%r8d\nmov    %eax,%edx\nmov    %r8d,(%rcx,%rdx,4)\nlea    0x1(%rax),%edx\ncmp    %edx,%ebx\njle    fa <func0+0xfa>\nlea    (%rdx,%rsi,1),%r8d\nadd    $0x2,%eax\nmovslq %edx,%rdx\nmovslq %r8d,%r8\nmov    (%rdi,%r8,4),%r8d\nmov    %r8d,(%rcx,%rdx,4)\ncmp    %eax,%ebx\njle    fa <func0+0xfa>\nlea    (%rsi,%rax,1),%edx\ncltq\nmovslq %edx,%rdx\nmov    (%rdi,%rdx,4),%edx\nmov    %edx,(%rcx,%rax,4)\npop    %rbx\nretq\nmov    %eax,%esi\nxor    %eax,%eax\nmov    (%rdx,%rax,4),%edi\nmov    %edi,(%rcx,%rax,4)\nmov    %rax,%rdi\nadd    $0x1,%rax\ncmp    %rsi,%rdi\njne    100 <func0+0x100>\npop    %rbx\nretq"
    },
    {
        "task_id": 121,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    66 <func0+0x66>\nmov    -0x4(%rbp),%eax\nadd    %eax,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    62 <func0+0x62>\nmov    -0x4(%rbp),%eax\nadd    %eax,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    %eax,%eax\ncmp    %eax,-0x1c(%rbp)\njg     1f <func0+0x1f>\nmov    -0x8(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 121,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    3f <func0+0x3f>\nmov    %rdi,%rcx\nsub    $0x1,%esi\nshr    %esi\nmov    %esi,%esi\nlea    0x8(%rdi,%rsi,8),%r8\nmov    $0x0,%esi\nmov    (%rcx),%eax\nmov    %eax,%edi\nshr    $0x1f,%edi\nlea    (%rax,%rdi,1),%edx\nand    $0x1,%edx\nsub    %edi,%edx\nadd    %esi,%eax\ncmp    $0x1,%edx\ncmove  %eax,%esi\nadd    $0x8,%rcx\ncmp    %r8,%rcx\njne    1c <func0+0x1c>\nmov    %esi,%eax\nretq\nmov    $0x0,%esi\njmp    3c <func0+0x3c>"
    },
    {
        "task_id": 121,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    40 <func0+0x40>\nsub    $0x1,%esi\nxor    %r8d,%r8d\nshr    %esi\nlea    0x8(%rdi,%rsi,8),%rsi\nnopl   (%rax)\nmov    (%rdi),%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nlea    (%rax,%rcx,1),%edx\nadd    %r8d,%eax\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\ncmove  %eax,%r8d\nadd    $0x8,%rdi\ncmp    %rsi,%rdi\njne    18 <func0+0x18>\nmov    %r8d,%eax\nretq\nxchg   %ax,%ax\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 121,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    130 <func0+0x130>\nlea    -0x1(%rsi),%edx\ncmp    $0x7,%edx\njbe    133 <func0+0x133>\nshr    $0x3,%edx\nmovdqa 0x0(%rip),%xmm4\n00\nmov    %rdi,%rax\npxor   %xmm2,%xmm2\nmov    %edx,%ecx\nshl    $0x5,%rcx\nadd    %rdi,%rcx\nnopl   0x0(%rax,%rax,1)\nmovdqu (%rax),%xmm1\nmovdqu 0x10(%rax),%xmm5\nadd    $0x20,%rax\nshufps $0x88,%xmm5,%xmm1\nmovdqa %xmm1,%xmm3\nmovdqa %xmm1,%xmm0\npsrld  $0x1f,%xmm3\npaddd  %xmm3,%xmm0\npand   %xmm4,%xmm0\npsubd  %xmm3,%xmm0\npcmpeqd %xmm4,%xmm0\npand   %xmm1,%xmm0\npaddd  %xmm0,%xmm2\ncmp    %rcx,%rax\njne    38 <func0+0x38>\nmovdqa %xmm2,%xmm0\nlea    0x0(,%rdx,4),%r9d\n00\nshl    $0x3,%edx\npsrldq $0x8,%xmm0\npaddd  %xmm0,%xmm2\nmovdqa %xmm2,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm2\nmovd   %xmm2,%eax\nmovslq %edx,%rdx\nmov    (%rdi,%rdx,4),%edx\nmov    %edx,%r8d\nshr    $0x1f,%r8d\nlea    (%rdx,%r8,1),%ecx\nadd    %eax,%edx\nand    $0x1,%ecx\nsub    %r8d,%ecx\ncmp    $0x1,%ecx\ncmove  %edx,%eax\nlea    0x2(%r9,%r9,1),%edx\ncmp    %esi,%edx\njge    132 <func0+0x132>\nmovslq %edx,%rcx\nmov    (%rdi,%rcx,4),%ecx\nmov    %ecx,%r9d\nshr    $0x1f,%r9d\nlea    (%rcx,%r9,1),%r8d\nadd    %eax,%ecx\nand    $0x1,%r8d\nsub    %r9d,%r8d\ncmp    $0x1,%r8d\ncmove  %ecx,%eax\nlea    0x2(%rdx),%ecx\ncmp    %ecx,%esi\njle    132 <func0+0x132>\nmovslq %ecx,%rcx\nmov    (%rdi,%rcx,4),%ecx\nmov    %ecx,%r9d\nshr    $0x1f,%r9d\nlea    (%rcx,%r9,1),%r8d\nadd    %eax,%ecx\nand    $0x1,%r8d\nsub    %r9d,%r8d\ncmp    $0x1,%r8d\ncmove  %ecx,%eax\nadd    $0x4,%edx\ncmp    %edx,%esi\njle    132 <func0+0x132>\nmovslq %edx,%rdx\nmov    (%rdi,%rdx,4),%edx\nmov    %edx,%esi\nshr    $0x1f,%esi\nlea    (%rdx,%rsi,1),%ecx\nadd    %eax,%edx\nand    $0x1,%ecx\nsub    %esi,%ecx\ncmp    $0x1,%ecx\ncmove  %edx,%eax\nretq\nxor    %eax,%eax\nretq\nxor    %r9d,%r9d\nxor    %eax,%eax\nxor    %edx,%edx\njmpq   9c <func0+0x9c>"
    },
    {
        "task_id": 122,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    72 <func0+0x72>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    $0xffffff9d,%eax\njl     6e <func0+0x6e>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    $0x63,%eax\njg     6e <func0+0x6e>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1f <func0+0x1f>\nmov    -0x8(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 122,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    34 <func0+0x34>\nmov    %rdi,%rdx\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rdi\nmov    $0x0,%ecx\nmov    (%rdx),%eax\nlea    0x63(%rax),%esi\nadd    %ecx,%eax\ncmp    $0xc7,%esi\ncmovb  %eax,%ecx\nadd    $0x4,%rdx\ncmp    %rdi,%rdx\njne    18 <func0+0x18>\nmov    %ecx,%eax\nretq\nmov    $0x0,%ecx\njmp    31 <func0+0x31>"
    },
    {
        "task_id": 122,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    40 <func0+0x40>\nlea    -0x1(%rsi),%eax\nxor    %r8d,%r8d\nlea    0x4(%rdi,%rax,4),%rcx\nnopl   0x0(%rax,%rax,1)\nmov    (%rdi),%eax\nlea    0x63(%rax),%edx\nadd    %r8d,%eax\ncmp    $0xc7,%edx\ncmovb  %eax,%r8d\nadd    $0x4,%rdi\ncmp    %rcx,%rdi\njne    18 <func0+0x18>\nmov    %r8d,%eax\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 122,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    110 <func0+0x110>\nlea    -0x1(%rsi),%eax\ncmp    $0x3,%eax\njbe    119 <func0+0x119>\nmov    %esi,%edx\nmov    %rdi,%rax\npxor   %xmm1,%xmm1\nmovdqa 0x0(%rip),%xmm3\n00\nmovdqa 0x0(%rip),%xmm2\n00\nshr    $0x2,%edx\nmovdqa 0x0(%rip),%xmm4\n00\nshl    $0x4,%rdx\nadd    %rdi,%rdx\npsubd  %xmm3,%xmm2\nnopw   0x0(%rax,%rax,1)\n00 00\nmovdqu (%rax),%xmm0\nmovdqu (%rax),%xmm5\nadd    $0x10,%rax\npaddd  %xmm4,%xmm0\npsubd  %xmm3,%xmm0\npcmpgtd %xmm2,%xmm0\npandn  %xmm5,%xmm0\npaddd  %xmm0,%xmm1\ncmp    %rdx,%rax\njne    50 <func0+0x50>\nmovdqa %xmm1,%xmm0\nmov    %esi,%edx\npsrldq $0x8,%xmm0\nand    $0xfffffffc,%edx\npaddd  %xmm0,%xmm1\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%eax\ntest   $0x3,%sil\nje     118 <func0+0x118>\nmovslq %edx,%rcx\nmov    (%rdi,%rcx,4),%ecx\nlea    0x63(%rcx),%r8d\nadd    %eax,%ecx\ncmp    $0xc7,%r8d\ncmovb  %ecx,%eax\nlea    0x1(%rdx),%ecx\ncmp    %esi,%ecx\njge    112 <func0+0x112>\nmovslq %ecx,%rcx\nmov    (%rdi,%rcx,4),%ecx\nlea    0x63(%rcx),%r8d\nadd    %eax,%ecx\ncmp    $0xc7,%r8d\ncmovb  %ecx,%eax\nlea    0x2(%rdx),%ecx\ncmp    %ecx,%esi\njle    112 <func0+0x112>\nmovslq %ecx,%rcx\nmov    (%rdi,%rcx,4),%ecx\nlea    0x63(%rcx),%r8d\nadd    %eax,%ecx\ncmp    $0xc7,%r8d\ncmovb  %ecx,%eax\nadd    $0x3,%edx\ncmp    %edx,%esi\njle    112 <func0+0x112>\nmovslq %edx,%rdx\nmov    (%rdi,%rdx,4),%edx\nlea    0x63(%rdx),%ecx\nadd    %eax,%edx\ncmp    $0xc7,%ecx\ncmovb  %edx,%eax\nretq\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nretq\nnopl   0x0(%rax,%rax,1)\nretq\nxor    %edx,%edx\nxor    %eax,%eax\njmpq   9e <func0+0x9e>"
    },
    {
        "task_id": 123,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0xa,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmovl   $0x1,(%rax)\nmov    -0x20(%rbp),%rax\nmovl   $0x1,(%rax)\njmpq   bd <func0+0xbd>\nmov    -0x14(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    ae <func0+0xae>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x10(%rbp)\njg     78 <func0+0x78>\nshll   -0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  74 <func0+0x74>\nmov    %rax,-0x20(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%ecx\nmov    -0x28(%rbp),%rdx\nmov    %ecx,(%rdx)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x14(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\njmp    bd <func0+0xbd>\nmov    -0x14(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x1,-0x14(%rbp)\njne    37 <func0+0x37>\nmovl   $0x1,-0xc(%rbp)\njmpq   16e <func0+0x16e>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0xc(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x8(%rbp)\njmp    12c <func0+0x12c>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nsubl   $0x1,-0x8(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njs     14d <func0+0x14d>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x4(%rbp)\njl     f7 <func0+0xf7>\nmov    -0x8(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njl     d3 <func0+0xd3>\nnop\nnop\nleaveq\nretq"
    },
    {
        "task_id": 123,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%rax\nmov    %rdx,%rbx\nmovl   $0x1,(%rdx)\nmovl   $0x1,(%rsi)\ncmp    $0x1,%edi\nje     76 <func0+0x76>\nmov    %edi,%ebp\nmov    $0xa,%r12d\njmp    4b <func0+0x4b>\nadd    %r12d,%r12d\nmovslq %r12d,%rsi\nshl    $0x2,%rsi\nmov    %rax,%rdi\ncallq  3b <func0+0x3b>\njmp    63 <func0+0x63>\nmov    %ebp,%edi\nshr    $0x1f,%edi\nadd    %edi,%ebp\nsar    %ebp\ncmp    $0x1,%ebp\nje     76 <func0+0x76>\nmov    %ebp,%ecx\nshr    $0x1f,%ecx\nlea    0x0(%rbp,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\njne    3d <func0+0x3d>\ncmp    %r12d,(%rbx)\njge    29 <func0+0x29>\nmov    (%rbx),%edx\nlea    0x1(%rdx),%ecx\nmov    %ecx,(%rbx)\nmovslq %edx,%rdx\nmov    %ebp,(%rax,%rdx,4)\nlea    0x1(%rbp,%rbp,2),%ebp\njmp    46 <func0+0x46>\ncmpl   $0x1,(%rbx)\njle    c3 <func0+0xc3>\nmov    %rax,%r9\nmov    $0x0,%r8d\njmp    9d <func0+0x9d>\nmovslq %ecx,%rcx\nmov    %edi,0x4(%rax,%rcx,4)\nadd    $0x1,%r8\nadd    $0x4,%r9\nlea    0x1(%r8),%edx\ncmp    %edx,(%rbx)\njle    c3 <func0+0xc3>\nmov    0x4(%r9),%edi\nmov    %r8d,%ecx\nmov    %r9,%rdx\ntest   %r8d,%r8d\njs     86 <func0+0x86>\nmov    (%rdx),%esi\ncmp    %edi,%esi\njle    86 <func0+0x86>\nmov    %esi,0x4(%rdx)\nsub    $0x1,%ecx\nsub    $0x4,%rdx\ncmp    $0xffffffff,%ecx\njne    ac <func0+0xac>\njmp    86 <func0+0x86>\npop    %rbx\npop    %rbp\npop    %r12\nretq"
    },
    {
        "task_id": 123,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %rsi,%r11\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmovl   $0x1,(%rdx)\nmovl   $0x1,(%rsi)\ncmp    $0x1,%edi\nje     ee <func0+0xee>\nmovslq (%rdx),%rdx\nmov    %edi,%ebx\nmov    $0xa,%r12d\njmp    3e <func0+0x3e>\nmov    %ebx,%edi\nshr    $0x1f,%edi\nadd    %edi,%ebx\nsar    %ebx\ncmp    $0x1,%ebx\nje     6c <func0+0x6c>\nmov    %ebx,%eax\nshr    $0x1f,%eax\nlea    (%rbx,%rax,1),%ecx\nand    $0x1,%ecx\nsub    %eax,%ecx\ncmp    $0x1,%ecx\njne    30 <func0+0x30>\ncmp    %edx,%r12d\njle    d0 <func0+0xd0>\nlea    0x1(%rdx),%eax\nmov    %eax,0x0(%rbp)\nmov    %ebx,(%r11,%rdx,4)\nlea    0x1(%rbx,%rbx,2),%ebx\nmovslq 0x0(%rbp),%rdx\ncmp    $0x1,%ebx\njne    3e <func0+0x3e>\nlea    0x4(%r11),%r10\nxor    %eax,%eax\ncmp    $0x1,%edx\njle    c4 <func0+0xc4>\nnopw   0x0(%rax,%rax,1)\n00 00\nlea    -0x4(%r10),%r8\nlea    0x0(,%rax,4),%rdx\n00\nmov    (%r10),%r9d\nmov    %r10,%rcx\nsub    %rdx,%r8\nnopl   (%rax)\nmov    -0x4(%rcx),%esi\nmov    %rcx,%rdi\ncmp    %r9d,%esi\njle    b1 <func0+0xb1>\nmov    %esi,(%rcx)\nlea    -0x4(%rdi),%rcx\ncmp    %rcx,%r8\njne    98 <func0+0x98>\nmov    %r11,%rdi\nadd    $0x1,%rax\nmov    %r9d,(%rdi)\nadd    $0x4,%r10\nlea    0x1(%rax),%edx\ncmp    0x0(%rbp),%edx\njl     80 <func0+0x80>\npop    %rbx\npop    %rbp\npop    %r12\nretq\nnopl   0x0(%rax)\nadd    %r12d,%r12d\nmov    %r11,%rdi\nmovslq %r12d,%rsi\nshl    $0x2,%rsi\ncallq  e2 <func0+0xe2>\nmovslq 0x0(%rbp),%rdx\nmov    %rax,%r11\njmpq   55 <func0+0x55>\nmov    (%rdx),%edx\njmpq   6c <func0+0x6c>"
    },
    {
        "task_id": 123,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\nmov    %rsi,%r11\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmovl   $0x1,(%rdx)\nmovl   $0x1,(%rsi)\ncmp    $0x1,%edi\nje     ee <func0+0xee>\nmovslq (%rdx),%rdx\nmov    %edi,%ebx\nmov    $0xa,%r12d\njmp    3e <func0+0x3e>\nmov    %ebx,%edi\nshr    $0x1f,%edi\nadd    %edi,%ebx\nsar    %ebx\ncmp    $0x1,%ebx\nje     6c <func0+0x6c>\nmov    %ebx,%eax\nshr    $0x1f,%eax\nlea    (%rbx,%rax,1),%ecx\nand    $0x1,%ecx\nsub    %eax,%ecx\ncmp    $0x1,%ecx\njne    30 <func0+0x30>\ncmp    %edx,%r12d\njle    d0 <func0+0xd0>\nlea    0x1(%rdx),%eax\nmov    %eax,0x0(%rbp)\nmov    %ebx,(%r11,%rdx,4)\nlea    0x1(%rbx,%rbx,2),%ebx\nmovslq 0x0(%rbp),%rdx\ncmp    $0x1,%ebx\njne    3e <func0+0x3e>\nlea    0x4(%r11),%r10\nxor    %eax,%eax\ncmp    $0x1,%edx\njle    c4 <func0+0xc4>\nnopw   0x0(%rax,%rax,1)\n00 00\nlea    -0x4(%r10),%r8\nlea    0x0(,%rax,4),%rdx\n00\nmov    (%r10),%r9d\nmov    %r10,%rcx\nsub    %rdx,%r8\nnopl   (%rax)\nmov    -0x4(%rcx),%esi\nmov    %rcx,%rdi\ncmp    %r9d,%esi\njle    b1 <func0+0xb1>\nmov    %esi,(%rcx)\nlea    -0x4(%rdi),%rcx\ncmp    %r8,%rcx\njne    98 <func0+0x98>\nmov    %r11,%rdi\nadd    $0x1,%rax\nmov    %r9d,(%rdi)\nadd    $0x4,%r10\nlea    0x1(%rax),%edx\ncmp    %edx,0x0(%rbp)\njg     80 <func0+0x80>\npop    %rbx\npop    %rbp\npop    %r12\nretq\nnopl   0x0(%rax)\nadd    %r12d,%r12d\nmov    %r11,%rdi\nmovslq %r12d,%rsi\nshl    $0x2,%rsi\ncallq  e2 <func0+0xe2>\nmovslq 0x0(%rbp),%rdx\nmov    %rax,%r11\njmpq   55 <func0+0x55>\nmov    (%rdx),%edx\njmpq   6c <func0+0x6c>"
    },
    {
        "task_id": 124,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncallq  2b <func0+0x2b>\ncmp    $0xa,%rax\nje     3b <func0+0x3b>\nmov    $0x0,%eax\njmpq   19d <func0+0x19d>\nmovl   $0x0,-0x24(%rbp)\njmp    a4 <func0+0xa4>\ncmpl   $0x2,-0x24(%rbp)\nje     50 <func0+0x50>\ncmpl   $0x5,-0x24(%rbp)\njne    6e <func0+0x6e>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\nje     a0 <func0+0xa0>\nmov    $0x0,%eax\njmpq   19d <func0+0x19d>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    96 <func0+0x96>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x39,%al\njle    a0 <func0+0xa0>\nmov    $0x0,%eax\njmpq   19d <func0+0x19d>\naddl   $0x1,-0x24(%rbp)\ncmpl   $0x9,-0x24(%rbp)\njle    44 <func0+0x44>\nmov    -0x38(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,-0x13(%rbp)\nmov    -0x38(%rbp),%rax\nmovzbl 0x1(%rax),%eax\nmov    %al,-0x12(%rbp)\nmovb   $0x0,-0x11(%rbp)\nmov    -0x38(%rbp),%rax\nmovzbl 0x3(%rax),%eax\nmov    %al,-0x10(%rbp)\nmov    -0x38(%rbp),%rax\nmovzbl 0x4(%rax),%eax\nmov    %al,-0xf(%rbp)\nmovb   $0x0,-0xe(%rbp)\nmov    -0x38(%rbp),%rax\nmovzbl 0x6(%rax),%eax\nmov    %al,-0xd(%rbp)\nmov    -0x38(%rbp),%rax\nmovzbl 0x7(%rax),%eax\nmov    %al,-0xc(%rbp)\nmov    -0x38(%rbp),%rax\nmovzbl 0x8(%rax),%eax\nmov    %al,-0xb(%rbp)\nmov    -0x38(%rbp),%rax\nmovzbl 0x9(%rax),%eax\nmov    %al,-0xa(%rbp)\nmovb   $0x0,-0x9(%rbp)\nlea    -0x13(%rbp),%rax\nmov    %rax,%rdi\ncallq  119 <func0+0x119>\nmov    %eax,-0x20(%rbp)\nlea    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncallq  128 <func0+0x128>\nmov    %eax,-0x1c(%rbp)\nlea    -0xd(%rbp),%rax\nmov    %rax,%rdi\ncallq  137 <func0+0x137>\nmov    %eax,-0x18(%rbp)\ncmpl   $0x0,-0x20(%rbp)\njle    146 <func0+0x146>\ncmpl   $0xc,-0x20(%rbp)\njle    14d <func0+0x14d>\nmov    $0x0,%eax\njmp    19d <func0+0x19d>\ncmpl   $0x0,-0x1c(%rbp)\njle    159 <func0+0x159>\ncmpl   $0x1f,-0x1c(%rbp)\njle    160 <func0+0x160>\nmov    $0x0,%eax\njmp    19d <func0+0x19d>\ncmpl   $0x4,-0x20(%rbp)\nje     178 <func0+0x178>\ncmpl   $0x6,-0x20(%rbp)\nje     178 <func0+0x178>\ncmpl   $0x9,-0x20(%rbp)\nje     178 <func0+0x178>\ncmpl   $0xb,-0x20(%rbp)\njne    185 <func0+0x185>\ncmpl   $0x1f,-0x1c(%rbp)\njne    185 <func0+0x185>\nmov    $0x0,%eax\njmp    19d <func0+0x19d>\ncmpl   $0x2,-0x20(%rbp)\njne    198 <func0+0x198>\ncmpl   $0x1d,-0x1c(%rbp)\njle    198 <func0+0x198>\nmov    $0x0,%eax\njmp    19d <func0+0x19d>\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rcx\nxor    %fs:0x28,%rcx\n00 00\nje     1b1 <func0+0x1b1>\ncallq  1b1 <func0+0x1b1>\nleaveq\nretq"
    },
    {
        "task_id": 124,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,%rdx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmov    $0xffffffffffffffff,%rcx\nrepnz scas %es:(%rdi),%al\nmov    $0x0,%eax\ncmp    $0xfffffffffffffff4,%rcx\njne    142 <func0+0x142>\nmov    $0x0,%eax\njmp    50 <func0+0x50>\ncmpb   $0x2d,(%rdx,%rax,1)\njne    159 <func0+0x159>\nadd    $0x1,%rax\ncmp    $0xa,%rax\nje     70 <func0+0x70>\ncmp    $0x2,%eax\nje     3c <func0+0x3c>\ncmp    $0x5,%eax\nje     3c <func0+0x3c>\nmovzbl (%rdx,%rax,1),%ebx\nlea    -0x30(%rbx),%ecx\ncmp    $0x9,%cl\njbe    46 <func0+0x46>\nmov    $0x0,%eax\njmpq   142 <func0+0x142>\nmovzbl (%rdx),%eax\nmov    %al,0xd(%rsp)\nmovzbl 0x1(%rdx),%eax\nmov    %al,0xe(%rsp)\nmovb   $0x0,0xf(%rsp)\nmovzbl 0x3(%rdx),%eax\nmov    %al,0x10(%rsp)\nmovzbl 0x4(%rdx),%eax\nmov    %al,0x11(%rsp)\nmovb   $0x0,0x12(%rsp)\nmovzbl 0x6(%rdx),%eax\nmov    %al,0x13(%rsp)\nmovzbl 0x7(%rdx),%eax\nmov    %al,0x14(%rsp)\nmovzbl 0x8(%rdx),%eax\nmov    %al,0x15(%rsp)\nmovzbl 0x9(%rdx),%eax\nmov    %al,0x16(%rsp)\nmovb   $0x0,0x17(%rsp)\nlea    0xd(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncallq  d2 <func0+0xd2>\nmov    %rax,%rbx\nlea    0x10(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncallq  e9 <func0+0xe9>\nmov    %rax,%rbp\nlea    0x13(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncallq  100 <func0+0x100>\nlea    -0x1(%rbx),%edx\nmov    $0x0,%eax\ncmp    $0xb,%edx\nja     142 <func0+0x142>\nlea    -0x1(%rbp),%edx\ncmp    $0x1e,%edx\nja     142 <func0+0x142>\nmov    %ebx,%eax\nand    $0xfffffffd,%eax\ncmp    $0x4,%eax\nje     124 <func0+0x124>\ncmp    $0x9,%eax\njne    12e <func0+0x12e>\nmov    $0x0,%eax\ncmp    $0x1f,%ebp\nje     142 <func0+0x142>\ncmp    $0x2,%ebx\nsete   %al\ncmp    $0x1d,%ebp\nsetg   %dl\nand    %edx,%eax\nxor    $0x1,%eax\nmovzbl %al,%eax\nmov    0x18(%rsp),%rsi\nxor    %fs:0x28,%rsi\n00 00\njne    160 <func0+0x160>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nretq\nmov    $0x0,%eax\njmp    142 <func0+0x142>\ncallq  165 <func0+0x165>"
    },
    {
        "task_id": 124,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncallq  22 <func0+0x22>\ncmp    $0xa,%rax\njne    58 <func0+0x58>\nxor    %eax,%eax\njmp    42 <func0+0x42>\nnopl   0x0(%rax)\nsub    $0x30,%edx\ncmp    $0x9,%dl\nja     58 <func0+0x58>\nadd    $0x1,%rax\ncmp    $0xa,%rax\nje     78 <func0+0x78>\nmovzbl (%rbx,%rax,1),%edx\ncmp    $0x2,%eax\nje     50 <func0+0x50>\ncmp    $0x5,%eax\njne    30 <func0+0x30>\ncmp    $0x2d,%dl\nje     38 <func0+0x38>\nnopl   (%rax)\nxor    %eax,%eax\nmov    0x18(%rsp),%rcx\nxor    %fs:0x28,%rcx\n00 00\njne    121 <func0+0x121>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nretq\nnopl   (%rax)\nmovzwl (%rbx),%eax\nlea    0xd(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nmovb   $0x0,0xf(%rsp)\nmov    %ax,0xd(%rsp)\nmovzwl 0x3(%rbx),%eax\nmovb   $0x0,0x12(%rsp)\nmov    %ax,0x10(%rsp)\nmov    0x6(%rbx),%eax\nmovb   $0x0,0x17(%rsp)\nmov    %eax,0x13(%rsp)\ncallq  b0 <func0+0xb0>\nlea    0x10(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %rax,%rbx\ncallq  c4 <func0+0xc4>\nlea    0x13(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %rax,%rbp\ncallq  d8 <func0+0xd8>\nlea    -0x1(%rbx),%eax\ncmp    $0xb,%eax\nja     58 <func0+0x58>\nlea    -0x1(%rbp),%eax\ncmp    $0x1e,%eax\nja     58 <func0+0x58>\nmov    %ebx,%eax\nand    $0xfffffffd,%eax\ncmp    $0x4,%eax\nje     ff <func0+0xff>\ncmp    $0x9,%eax\njne    108 <func0+0x108>\ncmp    $0x1f,%ebp\nje     58 <func0+0x58>\ncmp    $0x2,%ebx\nsete   %al\ncmp    $0x1d,%ebp\nsetg   %dl\nand    %edx,%eax\nxor    $0x1,%eax\nmovzbl %al,%eax\njmpq   5a <func0+0x5a>\ncallq  126 <func0+0x126>"
    },
    {
        "task_id": 124,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncallq  22 <func0+0x22>\ncmp    $0xa,%rax\njne    158 <func0+0x158>\nmovzbl (%rbx),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\nja     158 <func0+0x158>\nmovzbl 0x1(%rbx),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\nja     158 <func0+0x158>\ncmpb   $0x2d,0x2(%rbx)\njne    158 <func0+0x158>\nmovzbl 0x3(%rbx),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\nja     158 <func0+0x158>\nmovzbl 0x4(%rbx),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\nja     158 <func0+0x158>\ncmpb   $0x2d,0x5(%rbx)\njne    158 <func0+0x158>\nmovzbl 0x6(%rbx),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\nja     158 <func0+0x158>\nmovzbl 0x7(%rbx),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\nja     158 <func0+0x158>\nmovzbl 0x8(%rbx),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\nja     158 <func0+0x158>\nmovzbl 0x9(%rbx),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\nja     158 <func0+0x158>\nmovzwl (%rbx),%eax\nlea    0xd(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nmovb   $0x0,0xf(%rsp)\nmov    %ax,0xd(%rsp)\nmovzwl 0x3(%rbx),%eax\nmovb   $0x0,0x12(%rsp)\nmov    %ax,0x10(%rsp)\nmov    0x6(%rbx),%eax\nmovb   $0x0,0x17(%rsp)\nmov    %eax,0x13(%rsp)\ncallq  ef <func0+0xef>\nlea    0x10(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %rax,%rbx\ncallq  103 <func0+0x103>\nlea    0x13(%rsp),%rdi\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %rax,%rbp\ncallq  117 <func0+0x117>\nlea    -0x1(%rbx),%eax\ncmp    $0xb,%eax\nja     158 <func0+0x158>\nlea    -0x1(%rbp),%eax\ncmp    $0x1e,%eax\nja     158 <func0+0x158>\nmov    %ebx,%eax\nand    $0xfffffffd,%eax\ncmp    $0x4,%eax\nje     136 <func0+0x136>\ncmp    $0x9,%eax\njne    13b <func0+0x13b>\ncmp    $0x1f,%ebp\nje     158 <func0+0x158>\ncmp    $0x2,%ebx\nsete   %al\ncmp    $0x1d,%ebp\nsetg   %dl\nand    %edx,%eax\nxor    $0x1,%eax\nmovzbl %al,%eax\njmp    15a <func0+0x15a>\nnopl   0x0(%rax)\nxor    %eax,%eax\nmov    0x18(%rsp),%rcx\nxor    %fs:0x28,%rcx\n00 00\njne    171 <func0+0x171>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nretq\ncallq  176 <func0+0x176>"
    },
    {
        "task_id": 125,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0xa8,%rsp\nmov    %rdi,-0xa8(%rbp)\nmov    %rsi,-0xb0(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x98(%rbp)\n00 00 00\nmovl   $0x0,-0x94(%rbp)\n00 00 00\nmovl   $0x0,-0x90(%rbp)\n00 00 00\nmov    -0xa8(%rbp),%rax\nmov    %rax,%rdi\ncallq  5a <func0+0x5a>\nmov    %eax,-0x8c(%rbp)\nmovq   $0x0,-0x88(%rbp)\n00 00 00 00\nmovq   $0x0,-0x80(%rbp)\n00\nmovq   $0x0,-0x78(%rbp)\n00\nmovq   $0x0,-0x70(%rbp)\n00\nmovq   $0x0,-0x68(%rbp)\n00\nmovq   $0x0,-0x60(%rbp)\n00\nmovq   $0x0,-0x58(%rbp)\n00\nmovq   $0x0,-0x50(%rbp)\n00\nmovq   $0x0,-0x48(%rbp)\n00\nmovq   $0x0,-0x40(%rbp)\n00\nmovq   $0x0,-0x38(%rbp)\n00\nmovq   $0x0,-0x30(%rbp)\n00\nmovq   $0x0,-0x28(%rbp)\n00\nmovl   $0x0,-0x20(%rbp)\nmovb   $0x0,-0x1c(%rbp)\nmov    -0xa8(%rbp),%rax\nmov    $0x20,%esi\nmov    %rax,%rdi\ncallq  ea <func0+0xea>\ntest   %rax,%rax\njne    10c <func0+0x10c>\nmov    -0xa8(%rbp),%rax\nmov    $0x2c,%esi\nmov    %rax,%rdi\ncallq  103 <func0+0x103>\ntest   %rax,%rax\nje     224 <func0+0x224>\nmov    -0x8c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncallq  123 <func0+0x123>\nmov    %rax,-0x88(%rbp)\nmovl   $0x0,-0x9c(%rbp)\n00 00 00\njmpq   20d <func0+0x20d>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     187 <func0+0x187>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2c,%al\nje     187 <func0+0x187>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1da <func0+0x1da>\ncmpl   $0x0,-0x98(%rbp)\njle    206 <func0+0x206>\nmov    -0x98(%rbp),%eax\ncltq\nmovb   $0x0,-0x80(%rbp,%rax,1)\nmov    -0x90(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x88(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nlea    -0x80(%rbp),%rax\nmov    %rax,%rdi\ncallq  1c4 <func0+0x1c4>\nmov    %rax,(%rbx)\naddl   $0x1,-0x90(%rbp)\nmovl   $0x0,-0x98(%rbp)\n00 00 00\njmp    206 <func0+0x206>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x98(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x98(%rbp)\nmovzbl (%rcx),%edx\ncltq\nmov    %dl,-0x80(%rbp,%rax,1)\naddl   $0x1,-0x9c(%rbp)\nmov    -0x9c(%rbp),%eax\ncmp    -0x8c(%rbp),%eax\njle    139 <func0+0x139>\njmpq   30f <func0+0x30f>\nmovl   $0x0,-0x9c(%rbp)\n00 00 00\njmp    2a7 <func0+0x2a7>\ncallq  235 <func0+0x235>\nmov    (%rax),%rax\nmov    -0x9c(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0xa8(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovsbq %dl,%rdx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x200,%eax\ntest   %eax,%eax\nje     2a0 <func0+0x2a0>\nmov    -0x9c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nlea    -0x61(%rax),%edx\nmov    %edx,%eax\nsar    $0x1f,%eax\nshr    $0x1f,%eax\nadd    %eax,%edx\nand    $0x1,%edx\nsub    %eax,%edx\nmov    %edx,%eax\ncmp    $0x1,%eax\njne    2a0 <func0+0x2a0>\naddl   $0x1,-0x94(%rbp)\naddl   $0x1,-0x9c(%rbp)\nmov    -0x9c(%rbp),%eax\ncmp    -0x8c(%rbp),%eax\njl     230 <func0+0x230>\nmov    $0x8,%edi\ncallq  2c3 <func0+0x2c3>\nmov    %rax,-0x88(%rbp)\nmov    $0xc,%edi\ncallq  2d4 <func0+0x2d4>\nmov    %rax,%rdx\nmov    -0x88(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x88(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x94(%rbp),%edx\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncallq  305 <func0+0x305>\nmovl   $0x1,-0x90(%rbp)\n00 00 00\nmov    -0xb0(%rbp),%rax\nmov    -0x90(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x88(%rbp),%rax\nmov    -0x18(%rbp),%rbx\nxor    %fs:0x28,%rbx\n00 00\nje     339 <func0+0x339>\ncallq  339 <func0+0x339>\nadd    $0xa8,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 125,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x78,%rsp\nmov    %rdi,%r12\nmov    %rsi,%r14\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\nmov    $0xffffffffffffffff,%rcx\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%rbp\nmovq   $0x0,(%rsp)\n00\nmovq   $0x0,0x8(%rsp)\n00 00\nmovq   $0x0,0x10(%rsp)\n00 00\nmovq   $0x0,0x18(%rsp)\n00 00\nmovq   $0x0,0x20(%rsp)\n00 00\nmovq   $0x0,0x28(%rsp)\n00 00\nmovq   $0x0,0x30(%rsp)\n00 00\nmovq   $0x0,0x38(%rsp)\n00 00\nmovq   $0x0,0x40(%rsp)\n00 00\nmovq   $0x0,0x48(%rsp)\n00 00\nmovq   $0x0,0x50(%rsp)\n00 00\nmovq   $0x0,0x58(%rsp)\n00 00\nmovl   $0x0,0x60(%rsp)\n00\nmovb   $0x0,0x64(%rsp)\nmov    $0x20,%esi\nmov    %r12,%rdi\ncallq  bd <func0+0xbd>\ntest   %rax,%rax\nje     f5 <func0+0xf5>\nlea    0x1(%rbp),%edi\nmovslq %edi,%rdi\nshl    $0x3,%rdi\ncallq  d1 <func0+0xd1>\nmov    %rax,%r13\ntest   %ebp,%ebp\njs     215 <func0+0x215>\nmov    %r12,%rbx\nmov    %ebp,%ebp\nlea    0x1(%r12,%rbp,1),%r12\nmov    $0x0,%ebp\nmov    $0x0,%edx\nmov    %rsp,%r15\njmp    13f <func0+0x13f>\nmov    $0x2c,%esi\nmov    %r12,%rdi\ncallq  102 <func0+0x102>\ntest   %rax,%rax\njne    c2 <func0+0xc2>\nmov    $0x0,%ebx\ntest   %ebp,%ebp\njle    1af <func0+0x1af>\ncallq  119 <func0+0x119>\nmov    (%rax),%rdi\nmov    %r12,%rdx\nlea    -0x1(%rbp),%eax\nlea    0x1(%r12,%rax,1),%rsi\nmov    $0x0,%ebx\njmp    182 <func0+0x182>\ntest   %edx,%edx\njg     155 <func0+0x155>\nadd    $0x1,%rbx\ncmp    %r12,%rbx\nje     1f0 <func0+0x1f0>\nmovzbl (%rbx),%eax\ntest   $0xdf,%al\nje     12e <func0+0x12e>\ncmp    $0x2c,%al\nje     12e <func0+0x12e>\nmovslq %edx,%rcx\nmov    %al,(%rsp,%rcx,1)\nlea    0x1(%rdx),%edx\njmp    132 <func0+0x132>\nmovslq %edx,%rdx\nmovb   $0x0,(%rsp,%rdx,1)\nmov    %r15,%rdi\ncallq  164 <func0+0x164>\nmov    %rax,%rdx\nmovslq %ebp,%rax\nmov    %rdx,0x0(%r13,%rax,8)\nadd    $0x1,%ebp\nmov    $0x0,%edx\njmp    132 <func0+0x132>\nadd    $0x1,%rdx\ncmp    %rsi,%rdx\nje     1af <func0+0x1af>\nmovzbl (%rdx),%eax\nmovsbq %al,%rcx\ntestb  $0x2,0x1(%rdi,%rcx,2)\nje     179 <func0+0x179>\nmovsbl %al,%eax\nsub    $0x61,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nand    $0x1,%eax\nsub    %ecx,%eax\ncmp    $0x1,%eax\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebx\njmp    179 <func0+0x179>\nmov    $0x8,%edi\ncallq  1b9 <func0+0x1b9>\nmov    %rax,%r13\nmov    $0xc,%edi\ncallq  1c6 <func0+0x1c6>\nmov    %rax,%rdi\nmov    %rax,0x0(%r13)\nmov    %ebx,%r8d\nlea    0x0(%rip),%rcx\nmov    $0xc,%edx\nmov    $0x1,%esi\nmov    $0x0,%eax\ncallq  1eb <func0+0x1eb>\nmov    $0x1,%ebp\nmov    %ebp,(%r14)\nmov    0x68(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    21c <func0+0x21c>\nmov    %r13,%rax\nadd    $0x78,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    $0x0,%ebp\njmp    1f0 <func0+0x1f0>\ncallq  221 <func0+0x221>"
    },
    {
        "task_id": 125,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x78,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\ncallq  2d <func0+0x2d>\npxor   %xmm0,%xmm0\nmov    %rbx,%rdi\nmov    $0x20,%esi\nmovl   $0x0,0x60(%rsp)\n00\nmov    %rax,%r12\nmovb   $0x0,0x64(%rsp)\nmovaps %xmm0,(%rsp)\nmovaps %xmm0,0x10(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x50(%rsp)\ncallq  6b <func0+0x6b>\ntest   %rax,%rax\nje     128 <func0+0x128>\nlea    0x1(%r12),%edi\nmovslq %edi,%rdi\nshl    $0x3,%rdi\ncallq  85 <func0+0x85>\nmov    %rax,%r14\ntest   %r12d,%r12d\njs     1d8 <func0+0x1d8>\nmov    %r12d,%r12d\nxor    %edx,%edx\nmov    %rsp,%r15\nlea    0x1(%rbx,%r12,1),%r13\nxor    %r12d,%r12d\njmp    d4 <func0+0xd4>\nnopl   0x0(%rax,%rax,1)\ntest   %edx,%edx\nje     cb <func0+0xcb>\nmovslq %edx,%rdx\nmov    %r15,%rdi\nmovb   $0x0,(%rsp,%rdx,1)\ncallq  bb <func0+0xbb>\nxor    %edx,%edx\nmov    %rax,%r8\nmovslq %r12d,%rax\nadd    $0x1,%r12d\nmov    %r8,(%r14,%rax,8)\nadd    $0x1,%rbx\ncmp    %rbx,%r13\nje     f8 <func0+0xf8>\nmovzbl (%rbx),%eax\ntest   $0xdf,%al\nje     a8 <func0+0xa8>\ncmp    $0x2c,%al\nje     a8 <func0+0xa8>\nmovslq %edx,%rcx\nadd    $0x1,%rbx\nadd    $0x1,%edx\nmov    %al,(%rsp,%rcx,1)\ncmp    %rbx,%r13\njne    d4 <func0+0xd4>\nnopl   0x0(%rax)\nmov    %r12d,0x0(%rbp)\nmov    0x68(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    1e5 <func0+0x1e5>\nadd    $0x78,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopw   0x0(%rax,%rax,1)\nmov    $0x2c,%esi\nmov    %rbx,%rdi\ncallq  135 <func0+0x135>\ntest   %rax,%rax\njne    74 <func0+0x74>\ntest   %r12d,%r12d\njle    1e0 <func0+0x1e0>\ncallq  14c <func0+0x14c>\nmov    (%rax),%rsi\nlea    -0x1(%r12),%eax\nxor    %r12d,%r12d\nlea    0x1(%rbx,%rax,1),%rcx\nnopl   0x0(%rax)\nmovsbq (%rbx),%rdx\nmov    %rdx,%rax\ntestb  $0x2,0x1(%rsi,%rdx,2)\nje     189 <func0+0x189>\nsub    $0x61,%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%r12d\nadd    $0x1,%rbx\ncmp    %rbx,%rcx\njne    160 <func0+0x160>\nmov    $0x8,%edi\ncallq  19c <func0+0x19c>\nmov    $0xc,%edi\nmov    %rax,%r14\ncallq  1a9 <func0+0x1a9>\nmov    %r12d,%r8d\nmov    $0xc,%edx\nlea    0x0(%rip),%rcx\nmov    %rax,(%r14)\nmov    %rax,%rdi\nxor    %eax,%eax\nmov    $0x1,%esi\nmov    $0x1,%r12d\ncallq  1d0 <func0+0x1d0>\njmpq   f8 <func0+0xf8>\nnopl   (%rax)\nxor    %r12d,%r12d\njmpq   f8 <func0+0xf8>\nxor    %r12d,%r12d\njmp    192 <func0+0x192>\ncallq  1ea <func0+0x1ea>"
    },
    {
        "task_id": 125,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x78,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\ncallq  2d <func0+0x2d>\npxor   %xmm0,%xmm0\nmov    %rbx,%rdi\nmov    $0x20,%esi\nmovl   $0x0,0x60(%rsp)\n00\nmov    %rax,%r12\nmovb   $0x0,0x64(%rsp)\nmovaps %xmm0,(%rsp)\nmovaps %xmm0,0x10(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x50(%rsp)\ncallq  6b <func0+0x6b>\ntest   %rax,%rax\nje     128 <func0+0x128>\nlea    0x1(%r12),%edi\nmovslq %edi,%rdi\nshl    $0x3,%rdi\ncallq  85 <func0+0x85>\nmov    %rax,%r14\ntest   %r12d,%r12d\njs     1d8 <func0+0x1d8>\nmov    %r12d,%r12d\nxor    %edx,%edx\nmov    %rsp,%r15\nlea    0x1(%rbx,%r12,1),%r13\nxor    %r12d,%r12d\njmp    d4 <func0+0xd4>\nnopl   0x0(%rax,%rax,1)\ntest   %edx,%edx\nje     cb <func0+0xcb>\nmovslq %edx,%rdx\nmov    %r15,%rdi\nmovb   $0x0,(%rsp,%rdx,1)\ncallq  bb <func0+0xbb>\nxor    %edx,%edx\nmov    %rax,%r8\nmovslq %r12d,%rax\nadd    $0x1,%r12d\nmov    %r8,(%r14,%rax,8)\nadd    $0x1,%rbx\ncmp    %rbx,%r13\nje     f8 <func0+0xf8>\nmovzbl (%rbx),%eax\ntest   $0xdf,%al\nje     a8 <func0+0xa8>\ncmp    $0x2c,%al\nje     a8 <func0+0xa8>\nmovslq %edx,%rcx\nadd    $0x1,%rbx\nadd    $0x1,%edx\nmov    %al,(%rsp,%rcx,1)\ncmp    %rbx,%r13\njne    d4 <func0+0xd4>\nnopl   0x0(%rax)\nmov    %r12d,0x0(%rbp)\nmov    0x68(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    1e5 <func0+0x1e5>\nadd    $0x78,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopw   0x0(%rax,%rax,1)\nmov    $0x2c,%esi\nmov    %rbx,%rdi\ncallq  135 <func0+0x135>\ntest   %rax,%rax\njne    74 <func0+0x74>\ntest   %r12d,%r12d\njle    1e0 <func0+0x1e0>\ncallq  14c <func0+0x14c>\nmov    (%rax),%rsi\nlea    -0x1(%r12),%eax\nxor    %r12d,%r12d\nlea    0x1(%rbx,%rax,1),%rcx\nnopl   0x0(%rax)\nmovsbq (%rbx),%rdx\nmov    %rdx,%rax\ntestb  $0x2,0x1(%rsi,%rdx,2)\nje     189 <func0+0x189>\nsub    $0x61,%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%r12d\nadd    $0x1,%rbx\ncmp    %rbx,%rcx\njne    160 <func0+0x160>\nmov    $0x8,%edi\ncallq  19c <func0+0x19c>\nmov    $0xc,%edi\nmov    %rax,%r14\ncallq  1a9 <func0+0x1a9>\nmov    %r12d,%r8d\nmov    $0xc,%edx\nlea    0x0(%rip),%rcx\nmov    %rax,(%r14)\nmov    %rax,%rdi\nxor    %eax,%eax\nmov    $0x1,%esi\nmov    $0x1,%r12d\ncallq  1d0 <func0+0x1d0>\njmpq   f8 <func0+0xf8>\nnopl   (%rax)\nxor    %r12d,%r12d\njmpq   f8 <func0+0xf8>\nxor    %r12d,%r12d\njmp    192 <func0+0x192>\ncallq  1ea <func0+0x1ea>"
    },
    {
        "task_id": 126,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njne    1f <func0+0x1f>\nmov    $0x1,%eax\njmpq   e7 <func0+0xe7>\nmovl   $0x1,-0x4(%rbp)\njmpq   d6 <func0+0xd6>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    65 <func0+0x65>\nmov    $0x0,%eax\njmpq   e7 <func0+0xe7>\ncmpl   $0x1,-0x4(%rbp)\njle    d2 <func0+0xd2>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    d2 <func0+0xd2>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x8(%rax),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    d2 <func0+0xd2>\nmov    $0x0,%eax\njmp    e7 <func0+0xe7>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     2b <func0+0x2b>\nmov    $0x1,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 126,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    44 <func0+0x44>\nlea    -0x2(%rsi),%esi\nadd    $0x2,%rsi\nmov    $0x1,%eax\njmp    20 <func0+0x20>\nadd    $0x1,%rax\ncmp    %rsi,%rax\nje     3e <func0+0x3e>\nmov    (%rdi,%rax,4),%edx\nmov    -0x4(%rdi,%rax,4),%ecx\ncmp    %ecx,%edx\njl     4a <func0+0x4a>\njne    17 <func0+0x17>\ncmp    $0x1,%eax\njle    17 <func0+0x17>\ncmp    -0x8(%rdi,%rax,4),%edx\njne    17 <func0+0x17>\nmov    $0x0,%eax\nretq\nmov    $0x1,%eax\nretq\nmov    $0x1,%eax\nretq\nmov    $0x0,%eax\nretq"
    },
    {
        "task_id": 126,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    48 <func0+0x48>\nlea    -0x2(%rsi),%ecx\nmov    $0x1,%eax\nadd    $0x2,%rcx\njmp    29 <func0+0x29>\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    $0x1,%rax\ncmp    %rax,%rcx\nje     48 <func0+0x48>\nmov    (%rdi,%rax,4),%edx\ncmp    -0x4(%rdi,%rax,4),%edx\njl     3f <func0+0x3f>\njne    20 <func0+0x20>\ncmp    $0x1,%eax\nje     20 <func0+0x20>\ncmp    -0x8(%rdi,%rax,4),%edx\njne    20 <func0+0x20>\nxor    %eax,%eax\nretq\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 126,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    48 <func0+0x48>\nlea    -0x2(%rsi),%ecx\nmov    $0x1,%eax\nadd    $0x2,%rcx\njmp    29 <func0+0x29>\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    $0x1,%rax\ncmp    %rax,%rcx\nje     48 <func0+0x48>\nmov    (%rdi,%rax,4),%edx\ncmp    -0x4(%rdi,%rax,4),%edx\njl     3f <func0+0x3f>\njne    20 <func0+0x20>\ncmp    $0x1,%eax\nje     20 <func0+0x20>\ncmp    -0x8(%rdi,%rax,4),%edx\njne    20 <func0+0x20>\nxor    %eax,%eax\nretq\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 127,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %edx,-0x1c(%rbp)\nmov    %ecx,-0x20(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    %eax,-0x1c(%rbp)\ncmovge -0x1c(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    %eax,-0x20(%rbp)\ncmovle -0x20(%rbp),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nsub    -0xc(%rbp),%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njg     46 <func0+0x46>\nlea    0x0(%rip),%rax\njmp    7b <func0+0x7b>\nmovl   $0x2,-0x10(%rbp)\njmp    69 <func0+0x69>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x10(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    65 <func0+0x65>\nlea    0x0(%rip),%rax\njmp    7b <func0+0x7b>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x4(%rbp)\njge    4f <func0+0x4f>\nlea    0x0(%rip),%rax\npop    %rbp\nretq"
    },
    {
        "task_id": 127,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %esi,%ecx\ncmovg  %esi,%ecx\ncmp    %edi,%edx\ncmovl  %edi,%edx\nsub    %edx,%ecx\nlea    0x0(%rip),%rax\ncmp    $0x1,%ecx\njle    55 <func0+0x55>\nlea    0x0(%rip),%rax\ncmp    $0x3,%ecx\njle    55 <func0+0x55>\nlea    0x0(%rip),%rax\ntest   $0x1,%cl\nje     55 <func0+0x55>\nmov    $0x2,%edi\nadd    $0x1,%edi\nmov    %edi,%eax\nimul   %edi,%eax\ncmp    %ecx,%eax\njg     56 <func0+0x56>\nmov    %ecx,%eax\ncltd\nidiv   %edi\ntest   %edx,%edx\njne    39 <func0+0x39>\nlea    0x0(%rip),%rax\nretq\nlea    0x0(%rip),%rax\nretq"
    },
    {
        "task_id": 127,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %esi,%ecx\nlea    0x0(%rip),%rax\ncmovg  %esi,%ecx\ncmp    %edi,%edx\ncmovl  %edi,%edx\nsub    %edx,%ecx\ncmp    $0x1,%ecx\njle    67 <func0+0x67>\nlea    0x0(%rip),%rax\ncmp    $0x3,%ecx\njle    67 <func0+0x67>\nlea    0x0(%rip),%rax\ntest   $0x1,%cl\nje     67 <func0+0x67>\nmov    $0x2,%edi\njmp    49 <func0+0x49>\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,%eax\ncltd\nidiv   %edi\ntest   %edx,%edx\nje     60 <func0+0x60>\nadd    $0x1,%edi\nmov    %edi,%eax\nimul   %edi,%eax\ncmp    %ecx,%eax\njle    40 <func0+0x40>\nlea    0x0(%rip),%rax\nretq\nnopl   (%rax)\nlea    0x0(%rip),%rax\nretq"
    },
    {
        "task_id": 127,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %esi,%ecx\nlea    0x0(%rip),%rax\ncmovg  %esi,%ecx\ncmp    %edi,%edx\ncmovl  %edi,%edx\nsub    %edx,%ecx\ncmp    $0x1,%ecx\njle    67 <func0+0x67>\nlea    0x0(%rip),%rax\ncmp    $0x3,%ecx\njle    67 <func0+0x67>\nlea    0x0(%rip),%rax\ntest   $0x1,%cl\nje     67 <func0+0x67>\nmov    $0x2,%edi\njmp    49 <func0+0x49>\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,%eax\ncltd\nidiv   %edi\ntest   %edx,%edx\nje     60 <func0+0x60>\nadd    $0x1,%edi\nmov    %edi,%eax\nimul   %edi,%eax\ncmp    %ecx,%eax\njle    40 <func0+0x40>\nlea    0x0(%rip),%rax\nretq\nnopl   (%rax)\nlea    0x0(%rip),%rax\nretq"
    },
    {
        "task_id": 128,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njne    1f <func0+0x1f>\nmov    $0xffff8000,%eax\njmpq   a5 <func0+0xa5>\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    96 <func0+0x96>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltd\nxor    %edx,%eax\nsub    %edx,%eax\nadd    %eax,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    75 <func0+0x75>\nmovl   $0x0,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njns    92 <func0+0x92>\nnegl   -0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     36 <func0+0x36>\nmov    -0xc(%rbp),%eax\nimul   -0x8(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 128,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\nje     5e <func0+0x5e>\njle    4e <func0+0x4e>\nmov    %rdi,%rcx\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r9\nmov    $0x1,%r8d\nmov    $0x0,%eax\njmp    2e <func0+0x2e>\nmov    %edx,%r8d\nadd    $0x4,%rcx\ncmp    %r9,%rcx\nje     59 <func0+0x59>\nmov    (%rcx),%edx\nmov    %edx,%edi\nsar    $0x1f,%edi\nmov    %edi,%esi\nxor    %edx,%esi\nsub    %edi,%esi\nadd    %esi,%eax\ntest   %edx,%edx\nje     22 <func0+0x22>\nmov    %r8d,%esi\nneg    %esi\ntest   %edx,%edx\ncmovs  %esi,%r8d\njmp    25 <func0+0x25>\nmov    $0x1,%r8d\nmov    $0x0,%eax\nimul   %r8d,%eax\nretq\nmov    $0xffff8000,%eax\nretq"
    },
    {
        "task_id": 128,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\nje     63 <func0+0x63>\njle    60 <func0+0x60>\nlea    -0x1(%rsi),%eax\nxor    %r8d,%r8d\nlea    0x4(%rdi,%rax,4),%r9\nmov    $0x1,%eax\njmp    32 <func0+0x32>\nnopl   0x0(%rax)\nmov    %eax,%ecx\nneg    %ecx\ntest   %edx,%edx\ncmovs  %ecx,%eax\nadd    $0x4,%rdi\ncmp    %r9,%rdi\nje     51 <func0+0x51>\nmov    (%rdi),%edx\nmov    %edx,%esi\nsar    $0x1f,%esi\nmov    %esi,%ecx\nxor    %edx,%ecx\nsub    %esi,%ecx\nadd    %ecx,%r8d\ntest   %edx,%edx\njne    20 <func0+0x20>\nadd    $0x4,%rdi\nxor    %eax,%eax\ncmp    %r9,%rdi\njne    32 <func0+0x32>\nimul   %r8d,%eax\nretq\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nxor    %eax,%eax\nretq\nmov    $0xffff8000,%eax\nretq"
    },
    {
        "task_id": 128,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\nje     63 <func0+0x63>\njle    60 <func0+0x60>\nlea    -0x1(%rsi),%eax\nxor    %r8d,%r8d\nlea    0x4(%rdi,%rax,4),%r9\nmov    $0x1,%eax\njmp    32 <func0+0x32>\nnopl   0x0(%rax)\nmov    %eax,%ecx\nneg    %ecx\ntest   %edx,%edx\ncmovs  %ecx,%eax\nadd    $0x4,%rdi\ncmp    %rdi,%r9\nje     51 <func0+0x51>\nmov    (%rdi),%edx\nmov    %edx,%esi\nsar    $0x1f,%esi\nmov    %esi,%ecx\nxor    %edx,%ecx\nsub    %esi,%ecx\nadd    %ecx,%r8d\ntest   %edx,%edx\njne    20 <func0+0x20>\nadd    $0x4,%rdi\nxor    %eax,%eax\ncmp    %rdi,%r9\njne    32 <func0+0x32>\nimul   %r8d,%eax\nretq\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nxor    %eax,%eax\nretq\nmov    $0xffff8000,%eax\nretq"
    },
    {
        "task_id": 129,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %edx,-0x30(%rbp)\nmov    %rcx,-0x38(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    73 <func0+0x73>\nmovl   $0x0,-0x18(%rbp)\njmp    67 <func0+0x67>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    $0x1,%eax\njne    63 <func0+0x63>\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x10(%rbp)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     2c <func0+0x2c>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     23 <func0+0x23>\nmov    -0x2c(%rbp),%eax\nimul   %eax,%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njle    de <func0+0xde>\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    de <func0+0xde>\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x14(%rbp)\njge    145 <func0+0x145>\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    145 <func0+0x145>\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njle    1a7 <func0+0x1a7>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nsub    $0x4,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    1a7 <func0+0x1a7>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nsub    $0x4,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x10(%rbp)\njge    20e <func0+0x20e>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njle    20e <func0+0x20e>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x38(%rbp),%rax\nmov    -0x30(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  228 <func0+0x228>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    278 <func0+0x278>\nmov    -0x1c(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    25b <func0+0x25b>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\njmp    274 <func0+0x274>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     235 <func0+0x235>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 129,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %edx,%ebx\nmov    %rcx,%r12\ntest   %esi,%esi\njle    57 <func0+0x57>\nlea    -0x1(%rsi),%r11d\nmov    $0x0,%ebp\nmov    $0x0,%r13d\njmp    4c <func0+0x4c>\nmov    %r10,%rax\ncmpl   $0x1,(%rdx,%rax,4)\ncmove  %eax,%r8d\ncmove  %ecx,%r9d\nlea    0x1(%rax),%r10\ncmp    %r11,%rax\njne    28 <func0+0x28>\nlea    0x1(%rbp),%rax\ncmp    %r11,%rbp\nje     57 <func0+0x57>\nmov    %rax,%rbp\nmov    %ebp,%ecx\nmov    (%rdi,%rbp,8),%rdx\nmov    %r13,%rax\njmp    2b <func0+0x2b>\nmov    %esi,%ebp\nimul   %esi,%ebp\ntest   %r9d,%r9d\njle    74 <func0+0x74>\nmovslq %r9d,%rdx\nmovslq %r8d,%rax\nmov    -0x8(%rdi,%rdx,8),%rdx\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\nsub    $0x1,%esi\ncmp    %r9d,%esi\njle    8f <func0+0x8f>\nmovslq %r9d,%rdx\nmovslq %r8d,%rax\nmov    0x8(%rdi,%rdx,8),%rdx\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\ntest   %r8d,%r8d\njle    a7 <func0+0xa7>\nmovslq %r9d,%rdx\nmovslq %r8d,%rax\nmov    (%rdi,%rdx,8),%rdx\nmov    -0x4(%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\ncmp    %r8d,%esi\njle    c0 <func0+0xc0>\nmovslq %r9d,%r9\nmovslq %r8d,%r8\nmov    (%rdi,%r9,8),%rax\nmov    0x4(%rax,%r8,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\nmov    %ebx,(%r12)\nmovslq %ebx,%rdi\nshl    $0x2,%rdi\ncallq  d0 <func0+0xd0>\ntest   %ebx,%ebx\njle    fa <func0+0xfa>\nlea    -0x1(%rbx),%edi\nmov    $0x0,%edx\nmov    $0x1,%esi\njmp    e6 <func0+0xe6>\nmov    %rcx,%rdx\ntest   $0x1,%dl\nmov    %esi,%ecx\ncmovne %ebp,%ecx\nmov    %ecx,(%rax,%rdx,4)\nlea    0x1(%rdx),%rcx\ncmp    %rdx,%rdi\njne    e3 <func0+0xe3>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 129,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nlea    -0x1(%rsi),%r13d\npush   %r12\nmov    %rcx,%r12\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmov    %edx,%ebx\nsub    $0x8,%rsp\ntest   %esi,%esi\njle    60 <func0+0x60>\nlea    -0x1(%rsi),%edx\nxor    %esi,%esi\nmov    %rdx,%r13\nnopl   (%rax)\nmov    (%rdi,%rsi,8),%r8\nmovslq %esi,%rcx\nxor    %eax,%eax\njmp    3b <func0+0x3b>\nnopl   0x0(%rax,%rax,1)\nmov    %r11,%rax\ncmpl   $0x1,(%r8,%rax,4)\nlea    0x1(%rax),%r11\ncmove  %eax,%r9d\ncmove  %rcx,%r10\ncmp    %rdx,%rax\njne    38 <func0+0x38>\nlea    0x1(%rsi),%rax\ncmp    %rsi,%rdx\nje     60 <func0+0x60>\nmov    %rax,%rsi\njmp    28 <func0+0x28>\nnop\nimul   %ebp,%ebp\ntest   %r10d,%r10d\nje     7b <func0+0x7b>\nmovslq %r10d,%rdx\nmovslq %r9d,%rax\nmov    -0x8(%rdi,%rdx,8),%rdx\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\ncmp    %r10d,%r13d\njle    93 <func0+0x93>\nmovslq %r10d,%rdx\nmovslq %r9d,%rax\nmov    0x8(%rdi,%rdx,8),%rdx\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\ntest   %r9d,%r9d\nje     ab <func0+0xab>\nmovslq %r10d,%rdx\nmovslq %r9d,%rax\nmov    (%rdi,%rdx,8),%rdx\nmov    -0x4(%rdx,%rax,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\ncmp    %r9d,%r13d\njle    c1 <func0+0xc1>\nmov    (%rdi,%r10,8),%rax\nmovslq %r9d,%r9\nmov    0x4(%rax,%r9,4),%eax\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\nmov    %ebx,(%r12)\nmovslq %ebx,%rdi\nshl    $0x2,%rdi\ncallq  d1 <func0+0xd1>\nlea    -0x1(%rbx),%edi\nxor    %ecx,%ecx\nmov    $0x1,%esi\ntest   %ebx,%ebx\njg     eb <func0+0xeb>\njmp    ff <func0+0xff>\nnopl   0x0(%rax)\nmov    %rdx,%rcx\ntest   $0x1,%cl\nmov    %esi,%edx\ncmovne %ebp,%edx\nmov    %edx,(%rax,%rcx,4)\nlea    0x1(%rcx),%rdx\ncmp    %rcx,%rdi\njne    e8 <func0+0xe8>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 129,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nlea    -0x1(%rsi),%r14d\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %edx,0x14(%rsp)\nmov    %rcx,0x18(%rsp)\ntest   %esi,%esi\njle    308 <func0+0x308>\nlea    -0x1(%rsi),%eax\nmov    %esi,%r15d\nxor    %edi,%edi\nmov    %esi,%r13d\nmov    %rax,%r14\nshr    $0x2,%r15d\nmov    %rax,0x8(%rsp)\nand    $0xfffffffc,%r13d\nmov    (%r12,%rdi,8),%rax\nshl    $0x4,%r15\npcmpeqd %xmm9,%xmm9\nmov    %edi,%edx\nmovdqa 0x0(%rip),%xmm7\n00\nmovdqa 0x0(%rip),%xmm8\n00 00\ncmp    $0xa,%r14d\njbe    2df <func0+0x2df>\nnop\nmovd   %edi,%xmm5\nmovd   %ebp,%xmm6\nlea    (%r15,%rax,1),%r9\nmov    %rax,%rcx\npshufd $0x0,%xmm5,%xmm11\npshufd $0x0,%xmm6,%xmm2\npxor   %xmm1,%xmm1\nmovdqa 0x0(%rip),%xmm6\n00\nmovdqa 0x0(%rip),%xmm5\n00\nmovdqa %xmm9,%xmm3\nnopl   0x0(%rax,%rax,1)\nmovdqu (%rcx),%xmm0\nmovdqa %xmm5,%xmm4\nadd    $0x10,%rcx\npaddd  %xmm7,%xmm5\nmovdqa %xmm11,%xmm10\npcmpeqd %xmm8,%xmm0\nmovdqa %xmm0,%xmm13\npand   %xmm0,%xmm4\nmovdqa %xmm0,%xmm12\npandn  %xmm3,%xmm13\npand   %xmm0,%xmm10\npandn  %xmm2,%xmm12\nmovdqa %xmm13,%xmm3\nmovdqa %xmm12,%xmm2\npor    %xmm4,%xmm3\nmovdqa %xmm6,%xmm4\npor    %xmm10,%xmm2\npand   %xmm0,%xmm4\npandn  %xmm1,%xmm0\npaddd  %xmm7,%xmm6\nmovdqa %xmm0,%xmm1\npor    %xmm4,%xmm1\ncmp    %rcx,%r9\njne    a8 <func0+0xa8>\nmovdqa %xmm3,%xmm4\nmovd   %xmm1,%ebx\npsrldq $0x8,%xmm4\nmovdqa %xmm4,%xmm0\npcmpgtd %xmm3,%xmm0\npand   %xmm0,%xmm4\npandn  %xmm3,%xmm0\nmovdqa %xmm0,%xmm3\npor    %xmm4,%xmm3\nmovdqa %xmm3,%xmm4\npsrldq $0x4,%xmm4\nmovdqa %xmm4,%xmm0\npcmpgtd %xmm3,%xmm0\npand   %xmm0,%xmm4\npandn  %xmm3,%xmm0\npor    %xmm4,%xmm0\nmovd   %xmm0,%ecx\npshufd $0x55,%xmm1,%xmm0\ncmp    $0xffffffff,%ecx\nmovd   %xmm0,%r10d\ncmovne %ecx,%r8d\nmovd   %xmm0,%ecx\nmovdqa %xmm1,%xmm0\ncmp    %r10d,%ebx\npunpckhdq %xmm1,%xmm0\ncmovae %ebx,%ecx\nmovd   %xmm0,%r9d\ncmp    %r9d,%ecx\njb     2f0 <func0+0x2f0>\npshufd $0x55,%xmm2,%xmm0\nmovd   %xmm2,%r11d\ncmp    %r10d,%ebx\nmovd   %xmm0,%ebp\ncmovb  %ebp,%r11d\npshufd $0xff,%xmm1,%xmm1\npshufd $0xff,%xmm2,%xmm2\ncmp    %r9d,%ecx\ncmovb  %r9d,%ecx\nmovd   %xmm1,%r9d\nmovd   %xmm2,%ebp\ncmp    %r9d,%ecx\nmov    %r13d,%r9d\ncmovae %r11d,%ebp\ncmp    %r13d,%esi\nje     2c1 <func0+0x2c1>\nmovslq %r9d,%r10\ncmpl   $0x1,(%rax,%r10,4)\nlea    0x0(,%r10,4),%rcx\n00\nlea    0x1(%r9),%r10d\ncmove  %r9d,%r8d\ncmove  %edx,%ebp\ncmp    %r10d,%esi\njle    2c1 <func0+0x2c1>\ncmpl   $0x1,0x4(%rax,%rcx,1)\ncmove  %r10d,%r8d\nlea    0x2(%r9),%r10d\ncmove  %edx,%ebp\ncmp    %r10d,%esi\njle    2c1 <func0+0x2c1>\ncmpl   $0x1,0x8(%rax,%rcx,1)\ncmove  %r10d,%r8d\nlea    0x3(%r9),%r10d\ncmove  %edx,%ebp\ncmp    %r10d,%esi\njle    2c1 <func0+0x2c1>\ncmpl   $0x1,0xc(%rax,%rcx,1)\ncmove  %r10d,%r8d\nlea    0x4(%r9),%r10d\ncmove  %edx,%ebp\ncmp    %esi,%r10d\njge    2c1 <func0+0x2c1>\ncmpl   $0x1,0x10(%rax,%rcx,1)\ncmove  %r10d,%r8d\nlea    0x5(%r9),%r10d\ncmove  %edx,%ebp\ncmp    %esi,%r10d\njge    2c1 <func0+0x2c1>\ncmpl   $0x1,0x14(%rax,%rcx,1)\ncmove  %r10d,%r8d\nlea    0x6(%r9),%r10d\ncmove  %edx,%ebp\ncmp    %esi,%r10d\njge    2c1 <func0+0x2c1>\ncmpl   $0x1,0x18(%rax,%rcx,1)\ncmove  %r10d,%r8d\nlea    0x7(%r9),%r10d\ncmove  %edx,%ebp\ncmp    %r10d,%esi\njle    2c1 <func0+0x2c1>\ncmpl   $0x1,0x1c(%rax,%rcx,1)\ncmove  %r10d,%r8d\nlea    0x8(%r9),%r10d\ncmove  %edx,%ebp\ncmp    %r10d,%esi\njle    2c1 <func0+0x2c1>\ncmpl   $0x1,0x20(%rax,%rcx,1)\ncmove  %r10d,%r8d\nlea    0x9(%r9),%r10d\ncmove  %edx,%ebp\ncmp    %r10d,%esi\njle    2c1 <func0+0x2c1>\ncmpl   $0x1,0x24(%rax,%rcx,1)\ncmove  %r10d,%r8d\ncmove  %edx,%ebp\nadd    $0xa,%r9d\ncmp    %r9d,%esi\njle    2c1 <func0+0x2c1>\ncmpl   $0x1,0x28(%rax,%rcx,1)\ncmove  %r9d,%r8d\ncmove  %edx,%ebp\nlea    0x1(%rdi),%rax\ncmp    0x8(%rsp),%rdi\nje     308 <func0+0x308>\nmov    %rax,%rdi\nmov    (%r12,%rdi,8),%rax\nmov    %edi,%edx\ncmp    $0xa,%r14d\nja     70 <func0+0x70>\nxor    %r9d,%r9d\njmpq   1c8 <func0+0x1c8>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovdqa %xmm2,%xmm0\npunpckhdq %xmm2,%xmm0\nmovd   %xmm0,%r11d\njmpq   19b <func0+0x19b>\nnopw   0x0(%rax,%rax,1)\nmov    %esi,%ebx\nimul   %esi,%ebx\ntest   %ebp,%ebp\njle    324 <func0+0x324>\nmovslq %ebp,%rdx\nmovslq %r8d,%rax\nmov    -0x8(%r12,%rdx,8),%rdx\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\ncmp    %ebp,%r14d\njle    33c <func0+0x33c>\nmovslq %ebp,%rdx\nmovslq %r8d,%rax\nmov    0x8(%r12,%rdx,8),%rdx\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\ntest   %r8d,%r8d\njle    354 <func0+0x354>\nmovslq %ebp,%rdx\nmovslq %r8d,%rax\nmov    (%r12,%rdx,8),%rdx\nmov    -0x4(%rdx,%rax,4),%eax\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\ncmp    %r8d,%r14d\njle    36d <func0+0x36d>\nmovslq %ebp,%rbp\nmovslq %r8d,%r8\nmov    (%r12,%rbp,8),%rax\nmov    0x4(%rax,%r8,4),%eax\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\nmovslq 0x14(%rsp),%rdi\nmov    0x18(%rsp),%rax\nmov    %edi,(%rax)\nmov    %rdi,%r15\nshl    $0x2,%rdi\ncallq  385 <func0+0x385>\ntest   %r15d,%r15d\njle    44c <func0+0x44c>\nlea    -0x1(%r15),%edx\ncmp    $0x2,%edx\njbe    45b <func0+0x45b>\nmovd   %ebx,%xmm7\nshr    $0x2,%r15d\nmov    %rax,%rdx\npxor   %xmm4,%xmm4\nmov    %r15d,%ecx\nmovdqa 0x0(%rip),%xmm1\n00\nmovdqa 0x0(%rip),%xmm5\n00\npshufd $0x0,%xmm7,%xmm6\nshl    $0x4,%rcx\nmovdqa 0x0(%rip),%xmm2\n00\nadd    %rax,%rcx\nnopl   0x0(%rax)\nmovdqa %xmm1,%xmm0\nmovdqa %xmm2,%xmm3\npaddd  %xmm5,%xmm1\nadd    $0x10,%rdx\npand   %xmm2,%xmm0\npcmpeqd %xmm4,%xmm0\npand   %xmm0,%xmm3\npandn  %xmm6,%xmm0\npor    %xmm3,%xmm0\nmovups %xmm0,-0x10(%rdx)\ncmp    %rcx,%rdx\njne    3d8 <func0+0x3d8>\nmov    0x14(%rsp),%edi\nmov    %edi,%edx\nand    $0xfffffffc,%edx\ntest   $0x3,%dil\nje     44c <func0+0x44c>\nmovslq %edx,%rcx\nmov    %edi,%r11d\nlea    (%rax,%rcx,4),%rcx\nmovl   $0x1,(%rcx)\nlea    0x1(%rdx),%ecx\ncmp    %r11d,%ecx\njge    44c <func0+0x44c>\nmovslq %ecx,%r8\nmov    $0x1,%edi\nand    $0x1,%ecx\ncmove  %edi,%ebx\nadd    $0x2,%edx\nmov    %ebx,(%rax,%r8,4)\ncmp    %edx,%r11d\njle    44c <func0+0x44c>\nmovslq %edx,%rdx\nmov    %edi,(%rax,%rdx,4)\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    0x14(%rsp),%r11d\nmov    %rax,%rcx\nxor    %edx,%edx\njmp    41e <func0+0x41e>"
    },
    {
        "task_id": 130,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  23 <func0+0x23>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovl   $0x1,(%rax)\ncmpl   $0x0,-0x14(%rbp)\njne    40 <func0+0x40>\nmov    -0x8(%rbp),%rax\njmpq   fb <func0+0xfb>\nmov    -0x8(%rbp),%rax\nadd    $0x4,%rax\nmovl   $0x3,(%rax)\nmovl   $0x2,-0xc(%rbp)\njmpq   eb <func0+0xeb>\nmov    -0xc(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    8d <func0+0x8d>\nmov    -0xc(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,%ecx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nlea    0x1(%rcx),%edx\nmov    %edx,(%rax)\njmp    e7 <func0+0xe7>\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x8(%rax),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nadd    %edx,%eax\nlea    0x1(%rax),%edx\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\nmov    %eax,%esi\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nadd    %esi,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njle    5a <func0+0x5a>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 130,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nlea    0x1(%rdi),%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  16 <func0+0x16>\nmovl   $0x1,(%rax)\ntest   %ebx,%ebx\nje     75 <func0+0x75>\nmovl   $0x3,0x4(%rax)\ncmp    $0x1,%ebx\njle    75 <func0+0x75>\nlea    -0x2(%rbx),%r8d\nadd    $0x3,%r8\nmov    $0x2,%edx\njmp    5f <func0+0x5f>\nmov    -0x8(%rax,%rdx,4),%esi\nadd    -0x4(%rax,%rdx,4),%esi\nlea    0x1(%rdx),%edi\nmov    %edi,%ecx\nshr    $0x1f,%ecx\nadd    %edi,%ecx\nsar    %ecx\nlea    0x1(%rsi,%rcx,1),%ecx\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %r8,%rdx\nje     75 <func0+0x75>\ntest   $0x1,%dl\njne    3b <func0+0x3b>\nmov    %edx,%ecx\nshr    $0x1f,%ecx\nadd    %edx,%ecx\nsar    %ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax,%rdx,4)\njmp    56 <func0+0x56>\npop    %rbx\nretq"
    },
    {
        "task_id": 130,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  16 <func0+0x16>\nmovl   $0x1,(%rax)\ntest   %ebx,%ebx\nje     75 <func0+0x75>\nmovl   $0x3,0x4(%rax)\ncmp    $0x1,%ebx\njle    75 <func0+0x75>\nlea    -0x2(%rbx),%edi\nmov    $0x2,%edx\nadd    $0x3,%rdi\njmp    53 <func0+0x53>\nnopw   0x0(%rax,%rax,1)\nmov    %edx,%ecx\nsar    %ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdi,%rdx\nje     75 <func0+0x75>\nlea    0x1(%rdx),%ecx\ntest   $0x1,%dl\nje     40 <func0+0x40>\nmov    -0x8(%rax,%rdx,4),%esi\nsar    %ecx\nadd    -0x4(%rax,%rdx,4),%esi\nlea    0x1(%rsi,%rcx,1),%ecx\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdi,%rdx\njne    53 <func0+0x53>\npop    %rbx\nretq"
    },
    {
        "task_id": 130,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nadd    $0x1,%edi\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  16 <func0+0x16>\nmovl   $0x1,(%rax)\ntest   %ebx,%ebx\nje     75 <func0+0x75>\nmovl   $0x3,0x4(%rax)\ncmp    $0x1,%ebx\njle    75 <func0+0x75>\nlea    -0x2(%rbx),%edi\nmov    $0x2,%edx\nadd    $0x3,%rdi\njmp    53 <func0+0x53>\nnopw   0x0(%rax,%rax,1)\nmov    %edx,%ecx\nsar    %ecx\nadd    $0x1,%ecx\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%rdi\nje     75 <func0+0x75>\nlea    0x1(%rdx),%ecx\ntest   $0x1,%dl\nje     40 <func0+0x40>\nmov    -0x8(%rax,%rdx,4),%esi\nsar    %ecx\nadd    -0x4(%rax,%rdx,4),%esi\nlea    0x1(%rsi,%rcx,1),%ecx\nmov    %ecx,(%rax,%rdx,4)\nadd    $0x1,%rdx\ncmp    %rdx,%rdi\njne    53 <func0+0x53>\npop    %rbx\nretq"
    },
    {
        "task_id": 131,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x1,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    8a <func0+0x8a>\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%ecx\nsar    $0x2,%ecx\nmov    %edx,%eax\nsar    $0x1f,%eax\nsub    %eax,%ecx\nmov    %ecx,%eax\nshl    $0x2,%eax\nadd    %ecx,%eax\nadd    %eax,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    6c <func0+0x6c>\nmovl   $0x1,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nimul   -0x4(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     1b <func0+0x1b>\ncmpl   $0x0,-0x8(%rbp)\nje     9b <func0+0x9b>\nmov    -0xc(%rbp),%eax\njmp    a0 <func0+0xa0>\nmov    $0x0,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 131,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    75 <func0+0x75>\nmov    $0x0,%esi\nmov    $0x1,%ecx\njmp    30 <func0+0x30>\nmovslq %edi,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edi,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\ncmp    $0x9,%edi\njle    6d <func0+0x6d>\nmov    %eax,%edi\nmovslq %edi,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edi,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,4),%eax\nadd    %eax,%eax\nmov    %edi,%edx\nsub    %eax,%edx\nmov    %edx,%eax\nmov    %edx,%r8d\nshr    $0x1f,%r8d\nlea    (%rdx,%r8,1),%edx\nand    $0x1,%edx\nsub    %r8d,%edx\ncmp    $0x1,%edx\njne    14 <func0+0x14>\nimul   %eax,%ecx\nmov    %edx,%esi\njmp    14 <func0+0x14>\ntest   %esi,%esi\ncmove  %esi,%ecx\nmov    %ecx,%eax\nretq\nmov    $0x0,%ecx\njmp    72 <func0+0x72>"
    },
    {
        "task_id": 131,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %r9d,%r9d\ntest   %edi,%edi\njle    5c <func0+0x5c>\nmov    $0x1,%r8d\nmov    $0xcccccccd,%ecx\njmp    22 <func0+0x22>\nnopl   0x0(%rax,%rax,1)\n00\nmov    %eax,%edi\nmov    %edi,%eax\nmov    %edi,%esi\nmov    %rax,%rdx\nimul   %rcx,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%esi\nmov    %esi,%edx\nmov    %edi,%esi\nand    $0x1,%esi\nje     48 <func0+0x48>\nimul   %edx,%r8d\nmov    %esi,%r9d\nimul   %rcx,%rax\nshr    $0x23,%rax\ncmp    $0x9,%edi\njg     20 <func0+0x20>\ntest   %r9d,%r9d\ncmovne %r8d,%r9d\nmov    %r9d,%eax\nretq"
    },
    {
        "task_id": 131,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %r9d,%r9d\ntest   %edi,%edi\njle    5c <func0+0x5c>\nmov    $0x1,%r8d\nmov    $0xcccccccd,%ecx\njmp    22 <func0+0x22>\nnopl   0x0(%rax,%rax,1)\n00\nmov    %eax,%edi\nmov    %edi,%eax\nmov    %edi,%esi\nmov    %rax,%rdx\nimul   %rcx,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%esi\nmov    %esi,%edx\nmov    %edi,%esi\nand    $0x1,%esi\nje     48 <func0+0x48>\nimul   %edx,%r8d\nmov    %esi,%r9d\nimul   %rcx,%rax\nshr    $0x23,%rax\ncmp    $0x9,%edi\njg     20 <func0+0x20>\ntest   %r9d,%r9d\ncmovne %r8d,%r9d\nmov    %r9d,%eax\nretq"
    },
    {
        "task_id": 132,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    89 <func0+0x89>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5b,%al\njne    40 <func0+0x40>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5d,%al\njne    58 <func0+0x58>\nsubl   $0x1,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njns    65 <func0+0x65>\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njle    73 <func0+0x73>\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x1c(%rbp)\njge    85 <func0+0x85>\nmov    $0x1,%eax\njmp    a5 <func0+0xa5>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  9b <func0+0x9b>\ncmp    %rax,%rbx\njb     28 <func0+0x28>\nmov    $0x0,%eax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 132,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%rsi\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nmov    %rsi,%rdx\nlea    -0x1(%rsi,%rcx,1),%rdi\nmov    $0x0,%ecx\nmov    $0x0,%eax\nmov    $0x0,%r8d\njmp    56 <func0+0x56>\ncmp    $0x5d,%sil\nsete   %sil\nmovzbl %sil,%esi\nsub    %esi,%eax\ntest   %eax,%eax\ncmovs  %r8d,%eax\ncmp    %eax,%ecx\ncmovl  %eax,%ecx\nadd    $0x1,%rdx\nlea    -0x1(%rcx),%esi\ncmp    %esi,%eax\njl     6f <func0+0x6f>\ncmp    %rdi,%rdx\nje     69 <func0+0x69>\nmovzbl (%rdx),%esi\ncmp    $0x5b,%sil\njne    32 <func0+0x32>\nadd    $0x1,%eax\njmp    40 <func0+0x40>\nmov    $0x0,%eax\nretq\nmov    $0x1,%eax\nretq"
    },
    {
        "task_id": 132,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncallq  d <func0+0xd>\nmov    %rbx,%rdi\nxor    %ecx,%ecx\nxor    %edx,%edx\nadd    %rbx,%rax\nxor    %r8d,%r8d\njmp    44 <func0+0x44>\nnopl   0x0(%rax)\ncmp    $0x5d,%sil\nsete   %sil\nmovzbl %sil,%esi\nsub    %esi,%edx\ntest   %edx,%edx\ncmovs  %r8d,%edx\ncmp    %edx,%ecx\ncmovl  %edx,%ecx\nadd    $0x1,%rdi\nlea    -0x1(%rcx),%esi\ncmp    %esi,%edx\njl     68 <func0+0x68>\ncmp    %rdi,%rax\nje     60 <func0+0x60>\nmovzbl (%rdi),%esi\ncmp    $0x5b,%sil\njne    20 <func0+0x20>\nadd    $0x1,%edx\njmp    2e <func0+0x2e>\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %eax,%eax\npop    %rbx\nretq\nnopl   0x0(%rax)\nmov    $0x1,%eax\npop    %rbx\nretq"
    },
    {
        "task_id": 132,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncallq  d <func0+0xd>\nmov    %rbx,%rdi\nxor    %ecx,%ecx\nxor    %edx,%edx\nadd    %rbx,%rax\nxor    %r8d,%r8d\njmp    44 <func0+0x44>\nnopl   0x0(%rax)\ncmp    $0x5d,%sil\nsete   %sil\nmovzbl %sil,%esi\nsub    %esi,%edx\ntest   %edx,%edx\ncmovs  %r8d,%edx\ncmp    %edx,%ecx\ncmovl  %edx,%ecx\nadd    $0x1,%rdi\nlea    -0x1(%rcx),%esi\ncmp    %esi,%edx\njl     68 <func0+0x68>\ncmp    %rdi,%rax\nje     60 <func0+0x60>\nmovzbl (%rdi),%esi\ncmp    $0x5b,%sil\njne    20 <func0+0x20>\nadd    $0x1,%edx\njmp    2e <func0+0x2e>\nnopw   0x0(%rax,%rax,1)\n00 00\nxor    %eax,%eax\npop    %rbx\nretq\nnopl   0x0(%rax)\nmov    $0x1,%eax\npop    %rbx\nretq"
    },
    {
        "task_id": 133,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    78 <func0+0x78>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncallq  45 <func0+0x45>\ncvttsd2si %xmm0,%ebx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncallq  6a <func0+0x6a>\ncvttsd2si %xmm0,%eax\nimul   %ebx,%eax\nadd    %eax,-0x18(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     24 <func0+0x24>\nmov    -0x18(%rbp),%eax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 133,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    79 <func0+0x79>\nmov    %rdi,%rdx\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rsi\nmov    $0x0,%ecx\nmovss  0x0(%rip),%xmm4\n00\nmovss  0x0(%rip),%xmm3\n00\nmovss  0x0(%rip),%xmm5\n00\njmp    44 <func0+0x44>\ncvttss2si %xmm0,%eax\nimul   %eax,%eax\nadd    %eax,%ecx\nadd    $0x4,%rdx\ncmp    %rsi,%rdx\nje     7e <func0+0x7e>\nmovss  (%rdx),%xmm2\nmovaps %xmm2,%xmm0\nmovaps %xmm2,%xmm1\nandps  %xmm3,%xmm1\nucomiss %xmm1,%xmm4\njbe    32 <func0+0x32>\ncvttss2si %xmm2,%eax\npxor   %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\ncmpnless %xmm1,%xmm0\nandps  %xmm5,%xmm0\naddss  %xmm0,%xmm1\nmovaps %xmm3,%xmm0\nandnps %xmm2,%xmm0\norps   %xmm1,%xmm0\njmp    32 <func0+0x32>\nmov    $0x0,%ecx\nmov    %ecx,%eax\nretq"
    },
    {
        "task_id": 133,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    80 <func0+0x80>\nlea    -0x1(%rsi),%eax\nmovss  0x0(%rip),%xmm4\n00\nxor    %r8d,%r8d\nmovss  0x0(%rip),%xmm3\n00\nmovss  0x0(%rip),%xmm5\n00\nlea    0x4(%rdi,%rax,4),%rdx\nnopl   0x0(%rax,%rax,1)\nmovss  (%rdi),%xmm0\nmovaps %xmm0,%xmm1\nandps  %xmm3,%xmm1\nucomiss %xmm1,%xmm4\njbe    66 <func0+0x66>\ncvttss2si %xmm0,%eax\npxor   %xmm1,%xmm1\nmovaps %xmm0,%xmm2\nmovaps %xmm3,%xmm6\nandnps %xmm0,%xmm6\nmovaps %xmm6,%xmm0\ncvtsi2ss %eax,%xmm1\ncmpnless %xmm1,%xmm2\nandps  %xmm5,%xmm2\naddss  %xmm2,%xmm1\norps   %xmm1,%xmm0\ncvttss2si %xmm0,%eax\nadd    $0x4,%rdi\nimul   %eax,%eax\nadd    %eax,%r8d\ncmp    %rdx,%rdi\njne    30 <func0+0x30>\nmov    %r8d,%eax\nretq\nnopl   (%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 133,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    80 <func0+0x80>\nlea    -0x1(%rsi),%eax\nmovss  0x0(%rip),%xmm4\n00\nxor    %r8d,%r8d\nmovss  0x0(%rip),%xmm3\n00\nmovss  0x0(%rip),%xmm5\n00\nlea    0x4(%rdi,%rax,4),%rdx\nnopl   0x0(%rax,%rax,1)\nmovss  (%rdi),%xmm0\nmovaps %xmm0,%xmm1\nandps  %xmm3,%xmm1\nucomiss %xmm1,%xmm4\njbe    66 <func0+0x66>\ncvttss2si %xmm0,%eax\npxor   %xmm1,%xmm1\nmovaps %xmm0,%xmm2\nmovaps %xmm3,%xmm6\nandnps %xmm0,%xmm6\nmovaps %xmm6,%xmm0\ncvtsi2ss %eax,%xmm1\ncmpnless %xmm1,%xmm2\nandps  %xmm5,%xmm2\naddss  %xmm2,%xmm1\norps   %xmm1,%xmm0\ncvttss2si %xmm0,%eax\nadd    $0x4,%rdi\nimul   %eax,%eax\nadd    %eax,%r8d\ncmp    %rdi,%rdx\njne    30 <func0+0x30>\nmov    %r8d,%eax\nretq\nnopl   (%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 134,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  1c <func0+0x1c>\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    2f <func0+0x2f>\nmov    $0x0,%eax\njmpq   c3 <func0+0xc3>\nmov    -0x4(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x6(%rbp)\ncallq  4a <func0+0x4a>\nmov    (%rax),%rax\nmovzbl -0x6(%rbp),%edx\nmovzbl %dl,%edx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\njne    70 <func0+0x70>\nmov    $0x0,%eax\njmp    c3 <func0+0xc3>\ncmpl   $0x1,-0x4(%rbp)\njne    7d <func0+0x7d>\nmov    $0x1,%eax\njmp    c3 <func0+0xc3>\nmov    -0x4(%rbp),%eax\ncltq\nlea    -0x2(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x5(%rbp)\ncallq  98 <func0+0x98>\nmov    (%rax),%rax\nmovzbl -0x5(%rbp),%edx\nmovzbl %dl,%edx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\nje     be <func0+0xbe>\nmov    $0x0,%eax\njmp    c3 <func0+0xc3>\nmov    $0x1,%eax\nleaveq\nretq"
    },
    {
        "task_id": 134,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%rbx\nmov    %ebx,%r12d\ntest   %ebx,%ebx\nje     62 <func0+0x62>\nmovslq %ebx,%r13\ncallq  35 <func0+0x35>\nmov    (%rax),%rax\nmovzbl -0x1(%rbp,%r13,1),%edx\ntestb  $0x4,0x1(%rax,%rdx,2)\nje     70 <func0+0x70>\ncmp    $0x1,%ebx\nje     62 <func0+0x62>\nmovzbl -0x2(%rbp,%r13,1),%edx\nmovzwl (%rax,%rdx,2),%r12d\nshr    $0xa,%r12w\nxor    $0x1,%r12d\nand    $0x1,%r12d\nmov    %r12d,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nmov    $0x0,%r12d\njmp    62 <func0+0x62>"
    },
    {
        "task_id": 134,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\ncallq  16 <func0+0x16>\nmov    %eax,%r12d\ntest   %eax,%eax\nje     53 <func0+0x53>\nmovslq %eax,%r13\ncallq  25 <func0+0x25>\nmovzbl -0x1(%rbp,%r13,1),%edx\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%rdx,2)\nje     68 <func0+0x68>\ncmp    $0x1,%r12d\nje     53 <func0+0x53>\nmovzbl -0x2(%rbp,%r13,1),%edx\nmovzwl (%rax,%rdx,2),%r12d\nshr    $0xa,%r12w\nxor    $0x1,%r12d\nand    $0x1,%r12d\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nxor    %r12d,%r12d\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 134,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\ncallq  16 <func0+0x16>\nmov    %eax,%r12d\ntest   %eax,%eax\nje     53 <func0+0x53>\nmovslq %eax,%r13\ncallq  25 <func0+0x25>\nmovzbl -0x1(%rbp,%r13,1),%edx\nmov    (%rax),%rax\ntestb  $0x4,0x1(%rax,%rdx,2)\nje     68 <func0+0x68>\ncmp    $0x1,%r12d\nje     53 <func0+0x53>\nmovzbl -0x2(%rbp,%r13,1),%edx\nmovzwl (%rax,%rdx,2),%r12d\nshr    $0xa,%r12w\nxor    $0x1,%r12d\nand    $0x1,%r12d\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nxor    %r12d,%r12d\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\nretq"
    },
    {
        "task_id": 135,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0xffffffff,-0x8(%rbp)\nmovl   $0x1,-0x4(%rbp)\njmp    59 <func0+0x59>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    55 <func0+0x55>\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1f <func0+0x1f>\nmov    -0x8(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 135,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    30 <func0+0x30>\nlea    -0x2(%rsi),%ecx\nadd    $0x2,%rcx\nmov    $0x1,%eax\nmov    $0xffffffff,%edx\nmov    -0x4(%rdi,%rax,4),%esi\ncmp    %esi,(%rdi,%rax,4)\ncmovl  %eax,%edx\nadd    $0x1,%rax\ncmp    %rcx,%rax\njne    1a <func0+0x1a>\nmov    %edx,%eax\nretq\nmov    $0xffffffff,%edx\njmp    2d <func0+0x2d>"
    },
    {
        "task_id": 135,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    40 <func0+0x40>\nlea    -0x2(%rsi),%edx\nmov    $0x1,%eax\nmov    $0xffffffff,%r8d\nadd    $0x2,%rdx\nnopl   0x0(%rax,%rax,1)\nmov    -0x4(%rdi,%rax,4),%ecx\ncmp    %ecx,(%rdi,%rax,4)\ncmovl  %eax,%r8d\nadd    $0x1,%rax\ncmp    %rdx,%rax\njne    20 <func0+0x20>\nmov    %r8d,%eax\nretq\nnopl   0x0(%rax,%rax,1)\n00\nmov    $0xffffffff,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 135,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x1,%esi\njle    1a8 <func0+0x1a8>\nlea    -0x2(%rsi),%eax\nlea    -0x1(%rsi),%ecx\ncmp    $0x2,%eax\njbe    1ae <func0+0x1ae>\nmov    %ecx,%edx\nmovdqa 0x0(%rip),%xmm2\n00\nmov    %rdi,%rax\npxor   %xmm3,%xmm3\nshr    $0x2,%edx\nmovdqa 0x0(%rip),%xmm4\n00\nshl    $0x4,%rdx\nadd    %rdi,%rdx\nnop\nmovdqu (%rax),%xmm0\nmovdqu 0x4(%rax),%xmm5\nmovdqa %xmm2,%xmm1\nadd    $0x10,%rax\npaddd  %xmm4,%xmm2\npcmpgtd %xmm5,%xmm0\npand   %xmm0,%xmm1\npandn  %xmm3,%xmm0\nmovdqa %xmm0,%xmm3\npor    %xmm1,%xmm3\ncmp    %rdx,%rax\njne    40 <func0+0x40>\nmovdqa %xmm3,%xmm1\nmov    $0xffffffff,%edx\nmov    %ecx,%r8d\npsrldq $0x8,%xmm1\nmovdqa %xmm1,%xmm0\npcmpgtd %xmm3,%xmm0\npand   %xmm0,%xmm1\npandn  %xmm3,%xmm0\npor    %xmm0,%xmm1\nmovdqa %xmm1,%xmm2\npsrldq $0x4,%xmm2\nmovdqa %xmm2,%xmm0\npcmpgtd %xmm1,%xmm0\npand   %xmm0,%xmm2\npandn  %xmm1,%xmm0\npor    %xmm2,%xmm0\nmovd   %xmm0,%eax\ntest   %eax,%eax\ncmove  %edx,%eax\nand    $0xfffffffc,%r8d\nlea    0x1(%r8),%edx\ncmp    %r8d,%ecx\nje     1a0 <func0+0x1a0>\nmovslq %edx,%r8\nlea    0x1(%rdx),%r9d\npush   %rbx\nshl    $0x2,%r8\nlea    (%rdi,%r8,1),%r10\ncmp    %r9d,%ecx\njle    1bd <func0+0x1bd>\ncmp    %edx,%esi\njle    1bd <func0+0x1bd>\nmov    (%r10),%r11d\ncmp    %r11d,-0x4(%r10)\nmov    0x4(%rdi,%r8,1),%r10d\ncmovg  %edx,%eax\nlea    0x2(%rdx),%r8d\ncmp    %r10d,%r11d\ncmovg  %r9d,%eax\nlea    0x3(%rdx),%r9d\ncmp    %r9d,%ecx\njg     150 <func0+0x150>\nmovslq %r8d,%rdx\nmov    -0x4(%rdi,%rdx,4),%ebx\ncmp    %ebx,(%rdi,%rdx,4)\nlea    0x1(%r8),%edx\ncmovl  %r8d,%eax\ncmp    %edx,%esi\njle    14a <func0+0x14a>\nmovslq %edx,%rcx\nmov    -0x4(%rdi,%rcx,4),%ebx\ncmp    %ebx,(%rdi,%rcx,4)\ncmovge %eax,%edx\nlea    0x2(%r8),%eax\ncmp    %eax,%esi\njle    1c5 <func0+0x1c5>\nmovslq %eax,%rcx\nmov    (%rdi,%rcx,4),%ebx\ncmp    %ebx,-0x4(%rdi,%rcx,4)\ncmovle %edx,%eax\npop    %rbx\nretq\nnopl   0x0(%rax)\nmovslq %r8d,%rbx\nmov    (%rdi,%rbx,4),%r11d\ncmp    %r11d,%r10d\nmov    0x4(%rdi,%rbx,4),%r10d\ncmovg  %r8d,%eax\nlea    0x4(%rdx),%r8d\ncmp    %r10d,%r11d\ncmovg  %r9d,%eax\nlea    0x5(%rdx),%r9d\ncmp    %r9d,%ecx\njle    10e <func0+0x10e>\nmovslq %r8d,%rcx\nmov    (%rdi,%rcx,4),%r11d\ncmp    %r10d,%r11d\ncmovge %eax,%r8d\ncmp    0x4(%rdi,%rcx,4),%r11d\nmov    %r8d,%eax\nlea    0x6(%rdx),%r8d\ncmovg  %r9d,%eax\njmpq   10e <func0+0x10e>\nnopw   0x0(%rax,%rax,1)\nretq\nnopl   0x0(%rax)\nmov    $0xffffffff,%eax\nretq\nmov    $0x1,%edx\nmov    $0xffffffff,%eax\njmpq   ca <func0+0xca>\nmov    %edx,%r8d\njmpq   10e <func0+0x10e>\nmov    %edx,%eax\npop    %rbx\nretq"
    },
    {
        "task_id": 136,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (int[]){0, 1}));\n\n    func0((int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (int[]){0, 1}));\n\n    func0((int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (int[]){-2, 1}));\n\n    func0((int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (int[]){-7, 2}));\n\n    func0((int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (int[]){-9, 2}));\n\n    func0((int[]){}, 0, result);\n    assert(issame(result, (int[]){0, 0}));\n\n    func0((int[]){0}, 1, result);\n    assert(issame(result, (int[]){0, 0}));\n\n    func0((int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (int[]){-1, 0}));\n\n    func0((int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (int[]){-1, 0}));\n\n    func0((int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (int[]){-3, 1}));\n\n    func0((int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (int[]){-3, 1}));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmpq   d9 <func0+0xd9>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njns    81 <func0+0x81>\ncmpl   $0x0,-0xc(%rbp)\nje     68 <func0+0x68>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njge    81 <func0+0x81>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njle    d5 <func0+0xd5>\ncmpl   $0x0,-0x8(%rbp)\nje     bc <func0+0xbc>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x8(%rbp)\njle    d5 <func0+0xd5>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     2d <func0+0x2d>\nmov    -0x28(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x28(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 136,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (int[]){0, 1}));\n\n    func0((int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (int[]){0, 1}));\n\n    func0((int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (int[]){-2, 1}));\n\n    func0((int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (int[]){-7, 2}));\n\n    func0((int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (int[]){-9, 2}));\n\n    func0((int[]){}, 0, result);\n    assert(issame(result, (int[]){0, 0}));\n\n    func0((int[]){0}, 1, result);\n    assert(issame(result, (int[]){0, 0}));\n\n    func0((int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (int[]){-1, 0}));\n\n    func0((int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (int[]){-1, 0}));\n\n    func0((int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (int[]){-3, 1}));\n\n    func0((int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (int[]){-3, 1}));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    48 <func0+0x48>\nmov    %rdi,%rcx\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%r8\nmov    $0x0,%esi\nmov    $0x0,%edi\njmp    36 <func0+0x36>\ncmp    %edi,%eax\njg     27 <func0+0x27>\ntest   %edi,%edi\njne    2d <func0+0x2d>\nmov    %eax,%edi\njmp    2d <func0+0x2d>\nmov    %eax,%esi\nadd    $0x4,%rcx\ncmp    %r8,%rcx\nje     52 <func0+0x52>\nmov    (%rcx),%eax\ntest   %eax,%eax\njs     1f <func0+0x1f>\njle    2d <func0+0x2d>\ncmp    %esi,%eax\njl     2b <func0+0x2b>\ntest   %esi,%esi\nje     2b <func0+0x2b>\njmp    2d <func0+0x2d>\nmov    $0x0,%esi\nmov    $0x0,%edi\nmov    %edi,(%rdx)\nmov    %esi,0x4(%rdx)\nretq"
    },
    {
        "task_id": 136,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (int[]){0, 1}));\n\n    func0((int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (int[]){0, 1}));\n\n    func0((int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (int[]){-2, 1}));\n\n    func0((int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (int[]){-7, 2}));\n\n    func0((int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (int[]){-9, 2}));\n\n    func0((int[]){}, 0, result);\n    assert(issame(result, (int[]){0, 0}));\n\n    func0((int[]){0}, 1, result);\n    assert(issame(result, (int[]){0, 0}));\n\n    func0((int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (int[]){-1, 0}));\n\n    func0((int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (int[]){-1, 0}));\n\n    func0((int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (int[]){-3, 1}));\n\n    func0((int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (int[]){-3, 1}));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    50 <func0+0x50>\nlea    -0x1(%rsi),%eax\nxor    %ecx,%ecx\nxor    %esi,%esi\nlea    0x4(%rdi,%rax,4),%r8\nnopl   0x0(%rax)\nmov    (%rdi),%eax\ntest   %eax,%eax\njs     40 <func0+0x40>\nje     2a <func0+0x2a>\ntest   %ecx,%ecx\nje     28 <func0+0x28>\ncmp    %ecx,%eax\njge    2a <func0+0x2a>\nmov    %eax,%ecx\nadd    $0x4,%rdi\ncmp    %rdi,%r8\njne    18 <func0+0x18>\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nretq\nnopl   0x0(%rax)\ncmp    %esi,%eax\njg     48 <func0+0x48>\ntest   %esi,%esi\njne    2a <func0+0x2a>\nmov    %eax,%esi\njmp    2a <func0+0x2a>\nnopl   0x0(%rax)\nxor    %ecx,%ecx\nxor    %esi,%esi\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nretq"
    },
    {
        "task_id": 136,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (int[]){0, 1}));\n\n    func0((int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (int[]){0, 1}));\n\n    func0((int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (int[]){-2, 1}));\n\n    func0((int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (int[]){-7, 2}));\n\n    func0((int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (int[]){-9, 2}));\n\n    func0((int[]){}, 0, result);\n    assert(issame(result, (int[]){0, 0}));\n\n    func0((int[]){0}, 1, result);\n    assert(issame(result, (int[]){0, 0}));\n\n    func0((int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (int[]){-1, 0}));\n\n    func0((int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (int[]){-1, 0}));\n\n    func0((int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (int[]){-3, 1}));\n\n    func0((int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (int[]){-3, 1}));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    50 <func0+0x50>\nlea    -0x1(%rsi),%eax\nxor    %ecx,%ecx\nxor    %esi,%esi\nlea    0x4(%rdi,%rax,4),%r8\nnopl   0x0(%rax)\nmov    (%rdi),%eax\ntest   %eax,%eax\njs     40 <func0+0x40>\nje     2a <func0+0x2a>\ntest   %ecx,%ecx\nje     28 <func0+0x28>\ncmp    %ecx,%eax\njge    2a <func0+0x2a>\nmov    %eax,%ecx\nadd    $0x4,%rdi\ncmp    %r8,%rdi\njne    18 <func0+0x18>\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nretq\nnopl   0x0(%rax)\ncmp    %esi,%eax\njg     48 <func0+0x48>\ntest   %esi,%esi\njne    2a <func0+0x2a>\nmov    %eax,%esi\njmp    2a <func0+0x2a>\nnopl   0x0(%rax)\nxor    %ecx,%ecx\nxor    %esi,%esi\nmov    %esi,(%rdx)\nmov    %ecx,0x4(%rdx)\nretq"
    },
    {
        "task_id": 137,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncallq  2f <func0+0x2f>\nmov    %rax,-0x28(%rbp)\nmov    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncallq  3f <func0+0x3f>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x38(%rbp)\njmp    74 <func0+0x74>\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2c,%al\njne    70 <func0+0x70>\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x2e,(%rax)\naddl   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    4c <func0+0x4c>\nmovl   $0x0,-0x34(%rbp)\njmp    b9 <func0+0xb9>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2c,%al\njne    b5 <func0+0xb5>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x2e,(%rax)\naddl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    91 <func0+0x91>\nlea    -0x30(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  e0 <func0+0xe0>\nmovq   %xmm0,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     118 <func0+0x118>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  100 <func0+0x100>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncallq  10c <func0+0x10c>\nlea    0x0(%rip),%rax\njmpq   1af <func0+0x1af>\nlea    -0x30(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  12b <func0+0x12b>\nmovq   %xmm0,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     160 <func0+0x160>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  14b <func0+0x14b>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncallq  157 <func0+0x157>\nlea    0x0(%rip),%rax\njmp    1af <func0+0x1af>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  16c <func0+0x16c>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncallq  178 <func0+0x178>\nmovsd  -0x18(%rbp),%xmm0\nucomisd -0x10(%rbp),%xmm0\njp     199 <func0+0x199>\nmovsd  -0x18(%rbp),%xmm0\nucomisd -0x10(%rbp),%xmm0\njne    199 <func0+0x199>\nlea    0x0(%rip),%rax\njmp    1af <func0+0x1af>\nmovsd  -0x18(%rbp),%xmm0\ncomisd -0x10(%rbp),%xmm0\njbe    1ab <func0+0x1ab>\nmov    -0x48(%rbp),%rax\njmp    1af <func0+0x1af>\nmov    -0x50(%rbp),%rax\nmov    -0x8(%rbp),%rcx\nxor    %fs:0x28,%rcx\n00 00\nje     1c3 <func0+0x1c3>\ncallq  1c3 <func0+0x1c3>\nleaveq\nretq"
    },
    {
        "task_id": 137,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,%r12\nmov    %rsi,%r13\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncallq  29 <func0+0x29>\nmov    %rax,%rbx\nmov    %r13,%rdi\ncallq  34 <func0+0x34>\nmov    %rax,%rbp\nmovzbl (%rbx),%edx\ntest   %dl,%dl\nje     58 <func0+0x58>\nmov    %rbx,%rax\njmp    4e <func0+0x4e>\nadd    $0x1,%rax\nmovzbl (%rax),%edx\ntest   %dl,%dl\nje     58 <func0+0x58>\ncmp    $0x2c,%dl\njne    43 <func0+0x43>\nmovb   $0x2e,(%rax)\njmp    43 <func0+0x43>\nmovzbl 0x0(%rbp),%edx\ntest   %dl,%dl\nje     7a <func0+0x7a>\nmov    %rbp,%rax\njmp    70 <func0+0x70>\nadd    $0x1,%rax\nmovzbl (%rax),%edx\ntest   %dl,%dl\nje     7a <func0+0x7a>\ncmp    $0x2c,%dl\njne    65 <func0+0x65>\nmovb   $0x2e,(%rax)\njmp    65 <func0+0x65>\nlea    0x10(%rsp),%rsi\nmov    %rbx,%rdi\ncallq  87 <func0+0x87>\nmovsd  %xmm0,(%rsp)\nmov    0x10(%rsp),%rax\ncmpb   $0x0,(%rax)\njne    e4 <func0+0xe4>\nlea    0x10(%rsp),%rsi\nmov    %rbp,%rdi\ncallq  a3 <func0+0xa3>\nmovsd  %xmm0,0x8(%rsp)\nmov    0x10(%rsp),%rax\ncmpb   $0x0,(%rax)\njne    116 <func0+0x116>\nmov    %rbx,%rdi\ncallq  bb <func0+0xbb>\nmov    %rbp,%rdi\ncallq  c3 <func0+0xc3>\nmovsd  (%rsp),%xmm1\nucomisd 0x8(%rsp),%xmm1\njnp    12f <func0+0x12f>\nmovsd  (%rsp),%xmm3\ncomisd 0x8(%rsp),%xmm3\nmov    %r13,%rax\ncmova  %r12,%rax\njmp    fb <func0+0xfb>\nmov    %rbx,%rdi\ncallq  ec <func0+0xec>\nmov    %rbp,%rdi\ncallq  f4 <func0+0xf4>\nlea    0x0(%rip),%rax\nmov    0x18(%rsp),%rcx\nxor    %fs:0x28,%rcx\n00 00\njne    13a <func0+0x13a>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nmov    %rbx,%rdi\ncallq  11e <func0+0x11e>\nmov    %rbp,%rdi\ncallq  126 <func0+0x126>\nlea    0x0(%rip),%rax\njmp    fb <func0+0xfb>\njne    d0 <func0+0xd0>\nlea    0x0(%rip),%rax\njmp    fb <func0+0xfb>\ncallq  13f <.LC1+0x131>"
    },
    {
        "task_id": 137,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncallq  2b <func0+0x2b>\nmov    %rbp,%rdi\nmov    %rax,%r12\ncallq  36 <func0+0x36>\nmovzbl (%r12),%edx\nmov    %rax,%r13\ntest   %dl,%dl\nje     5c <func0+0x5c>\nmov    %r12,%rax\nnopl   (%rax)\ncmp    $0x2c,%dl\njne    50 <func0+0x50>\nmovb   $0x2e,(%rax)\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\njne    48 <func0+0x48>\nmovzbl 0x0(%r13),%edx\ntest   %dl,%dl\nje     84 <func0+0x84>\nmov    %r13,%rax\nnopl   0x0(%rax,%rax,1)\n00\ncmp    $0x2c,%dl\njne    78 <func0+0x78>\nmovb   $0x2e,(%rax)\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\njne    70 <func0+0x70>\nlea    0x10(%rsp),%r14\nmov    %r12,%rdi\nmov    %r14,%rsi\ncallq  94 <func0+0x94>\nmov    0x10(%rsp),%rax\nmovsd  %xmm0,(%rsp)\ncmpb   $0x0,(%rax)\njne    f8 <func0+0xf8>\nmov    %r14,%rsi\nmov    %r13,%rdi\ncallq  ae <func0+0xae>\nmov    0x10(%rsp),%rax\ncmpb   $0x0,(%rax)\njne    f8 <func0+0xf8>\nmov    %r12,%rdi\nmovsd  %xmm0,0x8(%rsp)\ncallq  c6 <func0+0xc6>\nmov    %r13,%rdi\ncallq  ce <func0+0xce>\nmovsd  (%rsp),%xmm1\nmovsd  0x8(%rsp),%xmm0\nucomisd %xmm0,%xmm1\njnp    130 <func0+0x130>\nmovsd  (%rsp),%xmm2\nmov    %rbp,%rax\ncomisd %xmm0,%xmm2\ncmova  %rbx,%rax\njmp    10f <func0+0x10f>\nnopl   0x0(%rax)\nmov    %r12,%rdi\ncallq  100 <func0+0x100>\nmov    %r13,%rdi\ncallq  108 <func0+0x108>\nlea    0x0(%rip),%rax\nmov    0x18(%rsp),%rcx\nxor    %fs:0x28,%rcx\n00 00\njne    13b <func0+0x13b>\nadd    $0x20,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nnopl   0x0(%rax)\njne    df <func0+0xdf>\nlea    0x0(%rip),%rax\njmp    10f <func0+0x10f>\ncallq  140 <.LC1+0x132>"
    },
    {
        "task_id": 137,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncallq  2b <func0+0x2b>\nmov    %rbp,%rdi\nmov    %rax,%r12\ncallq  36 <func0+0x36>\nmovzbl (%r12),%edx\nmov    %rax,%r13\ntest   %dl,%dl\nje     5d <func0+0x5d>\nmov    %r12,%rax\nnopl   (%rax)\ncmp    $0x2c,%dl\nje     138 <func0+0x138>\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\njne    48 <func0+0x48>\nmovzbl 0x0(%r13),%edx\ntest   %dl,%dl\nje     85 <func0+0x85>\nmov    %r13,%rax\nnopl   0x0(%rax)\ncmp    $0x2c,%dl\nje     150 <func0+0x150>\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\njne    70 <func0+0x70>\nlea    0x10(%rsp),%r14\nmov    %r12,%rdi\nmov    %r14,%rsi\ncallq  95 <func0+0x95>\nmov    0x10(%rsp),%rax\nmovsd  %xmm0,(%rsp)\ncmpb   $0x0,(%rax)\njne    100 <func0+0x100>\nmov    %r14,%rsi\nmov    %r13,%rdi\ncallq  af <func0+0xaf>\nmov    0x10(%rsp),%rax\ncmpb   $0x0,(%rax)\njne    100 <func0+0x100>\nmov    %r12,%rdi\nmovsd  %xmm0,0x8(%rsp)\ncallq  c7 <func0+0xc7>\nmov    %r13,%rdi\ncallq  cf <func0+0xcf>\nmovsd  (%rsp),%xmm1\nmovsd  0x8(%rsp),%xmm0\nucomisd %xmm0,%xmm1\njnp    170 <func0+0x170>\nmovsd  (%rsp),%xmm2\nmov    %rbp,%rax\ncomisd %xmm0,%xmm2\ncmova  %rbx,%rax\njmp    117 <func0+0x117>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    %r12,%rdi\ncallq  108 <func0+0x108>\nmov    %r13,%rdi\ncallq  110 <func0+0x110>\nlea    0x0(%rip),%rax\nmov    0x18(%rsp),%rcx\nxor    %fs:0x28,%rcx\n00 00\njne    17f <func0+0x17f>\nadd    $0x20,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nnopl   0x0(%rax)\nmovb   $0x2e,(%rax)\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\njne    48 <func0+0x48>\njmpq   5d <func0+0x5d>\nmovb   $0x2e,(%rax)\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\njne    70 <func0+0x70>\njmpq   85 <func0+0x85>\nnopl   0x0(%rax,%rax,1)\n00\njne    e4 <func0+0xe4>\nlea    0x0(%rip),%rax\njmp    117 <func0+0x117>\ncallq  184 <.LC1+0x176>"
    },
    {
        "task_id": 138,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    22 <func0+0x22>\ncmpl   $0x7,-0x4(%rbp)\njle    22 <func0+0x22>\nmov    $0x1,%eax\njmp    27 <func0+0x27>\nmov    $0x0,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 138,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%edx\nxor    $0x1,%edx\ncmp    $0x7,%edi\nsetg   %al\nmovzbl %al,%eax\nand    %edx,%eax\nretq"
    },
    {
        "task_id": 138,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x7,%edi\nnot    %edi\nsetg   %al\nand    %eax,%edi\nmovzbl %dil,%eax\nretq"
    },
    {
        "task_id": 138,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    $0x7,%edi\nnot    %edi\nsetg   %al\nand    %eax,%edi\nmovzbl %dil,%eax\nretq"
    },
    {
        "task_id": 139,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmovq   $0x1,-0x10(%rbp)\n00\nmovq   $0x1,-0x8(%rbp)\n00\nmovl   $0x1,-0x14(%rbp)\njmp    46 <func0+0x46>\nmov    -0x14(%rbp),%eax\ncltq\nmov    -0x10(%rbp),%rdx\nimul   %rdx,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nimul   -0x10(%rbp),%rax\nmov    %rax,-0x8(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    24 <func0+0x24>\nmov    -0x8(%rbp),%rax\npop    %rbp\nretq"
    },
    {
        "task_id": 139,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    33 <func0+0x33>\nlea    -0x1(%rdi),%esi\nadd    $0x2,%rsi\nmov    $0x1,%eax\nmov    $0x1,%ecx\nmov    $0x1,%edx\nimul   %rax,%rdx\nimul   %rdx,%rcx\nadd    $0x1,%rax\ncmp    %rsi,%rax\njne    1e <func0+0x1e>\nmov    %rcx,%rax\nretq\nmov    $0x1,%ecx\njmp    2f <func0+0x2f>"
    },
    {
        "task_id": 139,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    38 <func0+0x38>\nlea    -0x1(%rdi),%ecx\nmov    $0x1,%eax\nmov    $0x1,%r8d\nmov    $0x1,%edx\nadd    $0x2,%rcx\nnop\nimul   %rax,%rdx\nadd    $0x1,%rax\nimul   %rdx,%r8\ncmp    %rcx,%rax\njne    20 <func0+0x20>\nmov    %r8,%rax\nretq\nnopl   (%rax)\nmov    $0x1,%r8d\nmov    %r8,%rax\nretq"
    },
    {
        "task_id": 139,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %edi,%edi\njle    38 <func0+0x38>\nlea    -0x1(%rdi),%ecx\nmov    $0x1,%eax\nmov    $0x1,%r8d\nmov    $0x1,%edx\nadd    $0x2,%rcx\nnop\nimul   %rax,%rdx\nadd    $0x1,%rax\nimul   %rdx,%r8\ncmp    %rcx,%rax\njne    20 <func0+0x20>\nmov    %r8,%rax\nretq\nnopl   (%rax)\nmov    $0x1,%r8d\nmov    %r8,%rax\nretq"
    },
    {
        "task_id": 140,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmpq   e7 <func0+0xe7>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\njne    4c <func0+0x4c>\naddl   $0x1,-0x1c(%rbp)\njmpq   e3 <func0+0xe3>\ncmpl   $0x1,-0x1c(%rbp)\njne    68 <func0+0x68>\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x5f,(%rax)\ncmpl   $0x2,-0x1c(%rbp)\njne    9a <func0+0x9a>\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x5f,(%rax)\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x5f,(%rax)\ncmpl   $0x2,-0x1c(%rbp)\njle    b6 <func0+0xb6>\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x2d,(%rax)\nmovl   $0x0,-0x1c(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmovzbl (%rcx),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  f9 <func0+0xf9>\ncmp    %rax,%rbx\njb     2f <func0+0x2f>\ncmpl   $0x1,-0x1c(%rbp)\njne    11e <func0+0x11e>\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x5f,(%rax)\ncmpl   $0x2,-0x1c(%rbp)\njne    150 <func0+0x150>\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x5f,(%rax)\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x5f,(%rax)\ncmpl   $0x2,-0x1c(%rbp)\njle    16c <func0+0x16c>\nmov    -0x18(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x2d,(%rax)\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 140,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r9\nmov    $0x0,%r8d\nmov    $0x0,%edx\nmov    $0x0,%r10d\nmov    $0xffffffffffffffff,%r11\nmov    $0x0,%eax\njmp    5d <func0+0x5d>\nadd    $0x1,%r10d\njmp    59 <func0+0x59>\nlea    0x1(%rdx),%ecx\nmovslq %edx,%rdx\nmovb   $0x5f,(%rsi,%rdx,1)\njmp    44 <func0+0x44>\njle    9a <func0+0x9a>\nlea    0x1(%rdx),%ecx\nmovslq %edx,%rdx\nmovb   $0x2d,(%rsi,%rdx,1)\nlea    0x1(%rcx),%edx\nmovzbl (%r9,%r8,1),%edi\nmovslq %ecx,%rcx\nmov    %dil,(%rsi,%rcx,1)\nmov    $0x0,%r10d\nadd    $0x1,%r8\nmov    %r11,%rcx\nmov    %r9,%rdi\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nsub    $0x1,%rcx\ncmp    %r8,%rcx\njbe    9e <func0+0x9e>\ncmpb   $0x20,(%r9,%r8,1)\nje     26 <func0+0x26>\ncmp    $0x1,%r10d\nje     2c <func0+0x2c>\ncmp    $0x2,%r10d\njne    38 <func0+0x38>\nmovslq %edx,%rcx\nmovb   $0x5f,(%rsi,%rcx,1)\nlea    0x2(%rdx),%ecx\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovb   $0x5f,(%rsi,%rdx,1)\njmp    44 <func0+0x44>\nmov    %edx,%ecx\njmp    44 <func0+0x44>\ncmp    $0x1,%r10d\nje     c0 <func0+0xc0>\ncmp    $0x2,%r10d\njne    cc <func0+0xcc>\nmovslq %edx,%rax\nmovb   $0x5f,(%rsi,%rax,1)\nlea    0x2(%rdx),%eax\nadd    $0x1,%edx\nmovslq %edx,%rdx\nmovb   $0x5f,(%rsi,%rdx,1)\njmp    d8 <func0+0xd8>\nlea    0x1(%rdx),%eax\nmovslq %edx,%rdx\nmovb   $0x5f,(%rsi,%rdx,1)\njmp    d8 <func0+0xd8>\njle    df <func0+0xdf>\nlea    0x1(%rdx),%eax\nmovslq %edx,%rdx\nmovb   $0x2d,(%rsi,%rdx,1)\ncltq\nmovb   $0x0,(%rsi,%rax,1)\nretq\nmov    %edx,%eax\njmp    d8 <func0+0xd8>"
    },
    {
        "task_id": 140,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nmov    %rsi,%r13\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x8,%rsp\ncallq  1e <func0+0x1e>\nxor    %edx,%edx\nxor    %ecx,%ecx\njmp    6a <func0+0x6a>\nnopl   0x0(%rax)\nlea    0x1(%r12),%ecx\nmovslq %ecx,%rax\nadd    %r13,%rax\ncmp    $0x1,%edx\nje     90 <func0+0x90>\ncmp    $0x2,%edx\njne    80 <func0+0x80>\nlea    0x2(%r12),%ecx\nmovb   $0x5f,(%rsi)\nmovb   $0x5f,(%rax)\nmovslq %ecx,%rax\nadd    %r13,%rax\nmovzbl 0x0(%rbp,%rbx,1),%edx\nlea    0x1(%rcx),%r12d\nmov    %rbp,%rdi\nmov    %dl,(%rax)\ncallq  61 <func0+0x61>\nxor    %edx,%edx\nmovslq %r12d,%rcx\nadd    $0x1,%rbx\nlea    0x0(%r13,%rcx,1),%rsi\ncmp    %rbx,%rax\njbe    98 <func0+0x98>\ncmpb   $0x20,0x0(%rbp,%rbx,1)\njne    28 <func0+0x28>\nadd    $0x1,%edx\njmp    66 <func0+0x66>\njle    ec <func0+0xec>\nmovb   $0x2d,(%rsi)\njmp    4e <func0+0x4e>\nnopw   0x0(%rax,%rax,1)\n00 00\nmovb   $0x5f,(%rsi)\njmp    4e <func0+0x4e>\nnopl   (%rax)\ncmp    $0x1,%edx\nje     e0 <func0+0xe0>\ncmp    $0x2,%edx\njne    d0 <func0+0xd0>\nlea    0x1(%r12),%eax\nmovb   $0x5f,(%rsi)\nadd    $0x2,%r12d\ncltq\nmovslq %r12d,%rcx\nmovb   $0x5f,0x0(%r13,%rax,1)\nmovb   $0x0,0x0(%r13,%rcx,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopw   0x0(%rax,%rax,1)\njle    b9 <func0+0xb9>\nadd    $0x1,%r12d\nmovb   $0x2d,(%rsi)\nmovslq %r12d,%rcx\njmp    b9 <func0+0xb9>\nxchg   %ax,%ax\nadd    $0x1,%r12d\nmovb   $0x5f,(%rsi)\nmovslq %r12d,%rcx\njmp    b9 <func0+0xb9>\nmov    %rsi,%rax\nmov    %r12d,%ecx\njmpq   4e <func0+0x4e>"
    },
    {
        "task_id": 140,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\nmov    %rsi,%r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ncallq  19 <func0+0x19>\ntest   %rax,%rax\nje     f0 <func0+0xf0>\nmov    %r13,%rsi\nxor    %ebx,%ebx\nxor    %ebp,%ebp\nxor    %edx,%edx\njmp    77 <func0+0x77>\nnopl   (%rax)\nlea    0x1(%rbp),%ecx\nmovslq %ecx,%rax\nadd    %r13,%rax\ncmp    $0x1,%edx\nje     90 <func0+0x90>\ncmp    $0x2,%edx\njne    88 <func0+0x88>\nlea    0x2(%rbp),%ecx\nmovb   $0x5f,(%rsi)\nmovb   $0x5f,(%rax)\nmovslq %ecx,%rax\nadd    %r13,%rax\nmovzbl (%r12,%rbx,1),%edx\nmov    %r12,%rdi\nlea    0x1(%rcx),%ebp\nmov    %dl,(%rax)\ncallq  64 <func0+0x64>\nxor    %edx,%edx\nmovslq %ebp,%rcx\nadd    $0x1,%rbx\nlea    0x0(%r13,%rcx,1),%rsi\ncmp    %rax,%rbx\njae    98 <func0+0x98>\ncmpb   $0x20,(%r12,%rbx,1)\njne    30 <func0+0x30>\nadd    $0x1,%edx\njmp    66 <func0+0x66>\nnopl   0x0(%rax,%rax,1)\njle    f4 <func0+0xf4>\nmovb   $0x2d,(%rsi)\njmp    52 <func0+0x52>\nnop\nmovb   $0x5f,(%rsi)\njmp    52 <func0+0x52>\nnopl   (%rax)\ncmp    $0x1,%edx\nje     e0 <func0+0xe0>\ncmp    $0x2,%edx\njne    d0 <func0+0xd0>\nlea    0x1(%rbp),%eax\nmovb   $0x5f,(%rsi)\nadd    $0x2,%ebp\ncltq\nmovslq %ebp,%rcx\nmovb   $0x5f,0x0(%r13,%rax,1)\nmovb   $0x0,0x0(%r13,%rcx,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\njle    b6 <func0+0xb6>\nadd    $0x1,%ebp\nmovb   $0x2d,(%rsi)\nmovslq %ebp,%rcx\njmp    b6 <func0+0xb6>\nnopl   (%rax)\nadd    $0x1,%ebp\nmovb   $0x5f,(%rsi)\nmovslq %ebp,%rcx\njmp    b6 <func0+0xb6>\nnopl   0x0(%rax,%rax,1)\nxor    %ecx,%ecx\njmp    b6 <func0+0xb6>\nmov    %rsi,%rax\nmov    %ebp,%ecx\njmpq   52 <func0+0x52>"
    },
    {
        "task_id": 141,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  2a <func0+0x2a>\nmov    %eax,-0xc(%rbp)\ncmpl   $0x4,-0xc(%rbp)\njg     3f <func0+0x3f>\nlea    0x0(%rip),%rax\njmpq   144 <func0+0x144>\nmov    -0x28(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,-0x19(%rbp)\ncmpb   $0x40,-0x19(%rbp)\njle    61 <func0+0x61>\ncmpb   $0x5a,-0x19(%rbp)\njle    5b <func0+0x5b>\ncmpb   $0x60,-0x19(%rbp)\njle    61 <func0+0x61>\ncmpb   $0x7a,-0x19(%rbp)\njle    6d <func0+0x6d>\nlea    0x0(%rip),%rax\njmpq   144 <func0+0x144>\nmov    -0xc(%rbp),%eax\ncltq\nlea    -0x4(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  94 <func0+0x94>\ntest   %eax,%eax\nje     cf <func0+0xcf>\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  ab <func0+0xab>\ntest   %eax,%eax\nje     cf <func0+0xcf>\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  c2 <func0+0xc2>\ntest   %eax,%eax\nje     cf <func0+0xcf>\nlea    0x0(%rip),%rax\njmp    144 <func0+0x144>\nmovl   $0x0,-0x10(%rbp)\njmp    120 <func0+0x120>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    104 <func0+0x104>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x39,%al\njg     104 <func0+0x104>\naddl   $0x1,-0x18(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2e,%al\njne    11c <func0+0x11c>\naddl   $0x1,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     d8 <func0+0xd8>\ncmpl   $0x3,-0x18(%rbp)\njg     134 <func0+0x134>\ncmpl   $0x1,-0x14(%rbp)\nje     13d <func0+0x13d>\nlea    0x0(%rip),%rax\njmp    144 <func0+0x144>\nlea    0x0(%rip),%rax\nleaveq\nretq"
    },
    {
        "task_id": 141,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %rdi,%r8\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nmov    %rcx,%rax\nnot    %rax\nsub    $0x1,%rax\nlea    0x0(%rip),%rdx\ncmp    $0x4,%eax\njle    106 <func0+0x106>\nmovzbl (%r8),%edx\nlea    -0x5b(%rdx),%ecx\ncmp    $0x5,%cl\njbe    ff <func0+0xff>\nsub    $0x41,%edx\ncmp    $0x39,%dl\nja     ff <func0+0xff>\nmovslq %eax,%rdx\nlea    -0x4(%r8,%rdx,1),%r9\nmov    $0x5,%ecx\nlea    0x0(%rip),%rdi\nmov    %r9,%rsi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %dl\nsbb    $0x0,%dl\ntest   %dl,%dl\nje     ab <func0+0xab>\nmov    $0x5,%ecx\nlea    0x0(%rip),%rdi\nmov    %r9,%rsi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %dl\nsbb    $0x0,%dl\ntest   %dl,%dl\nje     ab <func0+0xab>\nmov    $0x5,%ecx\nlea    0x0(%rip),%rdi\nmov    %r9,%rsi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %cl\nsbb    $0x0,%cl\nlea    0x0(%rip),%rdx\ntest   %cl,%cl\njne    106 <func0+0x106>\nmov    %r8,%rdx\nlea    -0x1(%rax),%eax\nlea    0x1(%r8,%rax,1),%r8\nmov    $0x0,%edi\nmov    $0x0,%esi\njmp    d5 <func0+0xd5>\ncmp    $0x2e,%al\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%edi\nadd    $0x1,%rdx\ncmp    %r8,%rdx\nje     e5 <func0+0xe5>\nmovzbl (%rdx),%eax\nlea    -0x30(%rax),%ecx\ncmp    $0x9,%cl\nja     c2 <func0+0xc2>\nadd    $0x1,%esi\njmp    cc <func0+0xcc>\ncmp    $0x3,%esi\njg     f6 <func0+0xf6>\nlea    0x0(%rip),%rdx\ncmp    $0x1,%edi\nje     106 <func0+0x106>\nlea    0x0(%rip),%rdx\njmp    106 <func0+0x106>\nlea    0x0(%rip),%rdx\nmov    %rdx,%rax\nretq"
    },
    {
        "task_id": 141,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncallq  d <func0+0xd>\nlea    0x0(%rip),%r8\ncmp    $0x4,%eax\njle    ab <func0+0xab>\nmovzbl (%rbx),%edx\nlea    -0x5b(%rdx),%ecx\ncmp    $0x5,%cl\njbe    b0 <func0+0xb0>\nsub    $0x41,%edx\ncmp    $0x39,%dl\nja     b0 <func0+0xb0>\nmovslq %eax,%rdx\nmov    $0x5,%ecx\nlea    0x0(%rip),%rdi\nlea    -0x4(%rbx,%rdx,1),%r9\nmov    %r9,%rsi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %dl\nsbb    $0x0,%dl\ntest   %dl,%dl\njne    c0 <func0+0xc0>\nsub    $0x1,%eax\nmov    %rbx,%rdi\nxor    %esi,%esi\nxor    %ecx,%ecx\nlea    0x1(%rbx,%rax,1),%r8\njmp    7c <func0+0x7c>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%rdi\nadd    $0x1,%ecx\ncmp    %rdi,%r8\nje     9a <func0+0x9a>\nmovzbl (%rdi),%eax\nlea    -0x30(%rax),%edx\ncmp    $0x9,%dl\njbe    70 <func0+0x70>\ncmp    $0x2e,%al\nsete   %al\nadd    $0x1,%rdi\nmovzbl %al,%eax\nadd    %eax,%esi\ncmp    %rdi,%r8\njne    7c <func0+0x7c>\ncmp    $0x3,%ecx\njg     b0 <func0+0xb0>\nlea    0x0(%rip),%r8\ncmp    $0x1,%esi\njne    b0 <func0+0xb0>\nmov    %r8,%rax\npop    %rbx\nretq\nlea    0x0(%rip),%r8\npop    %rbx\nmov    %r8,%rax\nretq\nnopl   0x0(%rax)\nmov    $0x5,%ecx\nlea    0x0(%rip),%rdi\nmov    %r9,%rsi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %dl\nsbb    $0x0,%dl\ntest   %dl,%dl\nje     57 <func0+0x57>\nmov    $0x5,%ecx\nlea    0x0(%rip),%rdi\nmov    %r9,%rsi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %dl\nsbb    $0x0,%dl\ntest   %dl,%dl\nje     57 <func0+0x57>\njmp    ab <func0+0xab>"
    },
    {
        "task_id": 141,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncallq  d <func0+0xd>\nlea    0x0(%rip),%r9\ncmp    $0x4,%eax\njle    4af <func0+0x4af>\nmovzbl (%rbx),%edx\nlea    -0x5b(%rdx),%ecx\ncmp    $0x5,%cl\njbe    4a8 <func0+0x4a8>\nlea    -0x41(%rdx),%ecx\ncmp    $0x39,%cl\nja     4a8 <func0+0x4a8>\nmovslq %eax,%rcx\nlea    0x0(%rip),%rdi\nlea    -0x4(%rbx,%rcx,1),%r8\nmov    $0x5,%ecx\nmov    %r8,%rsi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %cl\nsbb    $0x0,%cl\ntest   %cl,%cl\njne    4b8 <func0+0x4b8>\nlea    -0x1(%rax),%ecx\ncmp    $0xe,%ecx\njbe    5b0 <func0+0x5b0>\nmov    %eax,%ecx\npxor   %xmm2,%xmm2\nmovdqa 0x0(%rip),%xmm8\n00 00\nmovdqa 0x0(%rip),%xmm7\n00\nshr    $0x4,%ecx\nmovdqa %xmm2,%xmm10\npxor   %xmm4,%xmm4\nmov    %rbx,%rdx\nshl    $0x4,%rcx\nmovdqa 0x0(%rip),%xmm6\n00\nmovdqa 0x0(%rip),%xmm5\n00\npxor   %xmm3,%xmm3\nadd    %rbx,%rcx\nnopl   0x0(%rax)\nmovdqu (%rdx),%xmm0\nmovdqu (%rdx),%xmm9\nmovdqa %xmm4,%xmm11\nadd    $0x10,%rdx\npaddb  %xmm8,%xmm0\npcmpeqb %xmm6,%xmm9\npsubusb %xmm7,%xmm0\npcmpeqb %xmm4,%xmm0\nmovdqa %xmm0,%xmm1\npand   %xmm5,%xmm0\npcmpeqb %xmm4,%xmm1\npand   %xmm9,%xmm1\npcmpgtb %xmm1,%xmm11\nmovdqa %xmm1,%xmm9\npunpcklbw %xmm11,%xmm9\npunpckhbw %xmm11,%xmm1\nmovdqa %xmm3,%xmm11\npcmpgtw %xmm9,%xmm11\nmovdqa %xmm9,%xmm12\npunpcklwd %xmm11,%xmm12\npunpckhwd %xmm11,%xmm9\nmovdqa %xmm1,%xmm11\npsubd  %xmm12,%xmm2\npsubd  %xmm9,%xmm2\nmovdqa %xmm3,%xmm9\npcmpgtw %xmm1,%xmm9\npunpcklwd %xmm9,%xmm11\npunpckhwd %xmm9,%xmm1\nmovdqa %xmm0,%xmm9\npsubd  %xmm11,%xmm2\nmovdqa %xmm3,%xmm11\npsubd  %xmm1,%xmm2\nmovdqa %xmm4,%xmm1\npcmpgtb %xmm0,%xmm1\npunpcklbw %xmm1,%xmm9\npunpckhbw %xmm1,%xmm0\npcmpgtw %xmm9,%xmm11\nmovdqa %xmm9,%xmm1\npunpcklwd %xmm11,%xmm1\npunpckhwd %xmm11,%xmm9\npaddd  %xmm10,%xmm1\nmovdqa %xmm0,%xmm10\npaddd  %xmm9,%xmm1\nmovdqa %xmm3,%xmm9\npcmpgtw %xmm0,%xmm9\npunpcklwd %xmm9,%xmm10\npunpckhwd %xmm9,%xmm0\npaddd  %xmm10,%xmm1\npaddd  %xmm0,%xmm1\nmovdqa %xmm1,%xmm10\ncmp    %rcx,%rdx\njne    b0 <func0+0xb0>\nmovdqa %xmm2,%xmm0\npsrldq $0x8,%xmm1\nmov    %eax,%esi\npsrldq $0x8,%xmm0\npaddd  %xmm10,%xmm1\nand    $0xfffffff0,%esi\npaddd  %xmm0,%xmm2\nmovdqa %xmm1,%xmm10\nmovdqa %xmm2,%xmm0\npsrldq $0x4,%xmm10\npsrldq $0x4,%xmm0\npaddd  %xmm10,%xmm1\npaddd  %xmm0,%xmm2\nmovd   %xmm1,%edx\nmovd   %xmm2,%ecx\ntest   $0xf,%al\nje     490 <func0+0x490>\nmovslq %esi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    220 <func0+0x220>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\njmp    223 <func0+0x223>\nxor    %esi,%esi\nxor    %ecx,%ecx\nxor    %edx,%edx\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    $0x1,%edx\nadd    $0x1,%esi\ncmp    %esi,%eax\njle    490 <func0+0x490>\nmovslq %esi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    500 <func0+0x500>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nlea    0x1(%rsi),%edi\ncmp    %edi,%eax\njle    490 <func0+0x490>\nmovslq %edi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    510 <func0+0x510>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nlea    0x2(%rsi),%edi\ncmp    %edi,%eax\njle    490 <func0+0x490>\nmovslq %edi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    520 <func0+0x520>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nlea    0x3(%rsi),%edi\ncmp    %edi,%eax\njle    490 <func0+0x490>\nmovslq %edi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    530 <func0+0x530>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nlea    0x4(%rsi),%edi\ncmp    %edi,%eax\njle    490 <func0+0x490>\nmovslq %edi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    540 <func0+0x540>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nlea    0x5(%rsi),%edi\ncmp    %edi,%eax\njle    490 <func0+0x490>\nmovslq %edi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    550 <func0+0x550>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nlea    0x6(%rsi),%edi\ncmp    %edi,%eax\njle    490 <func0+0x490>\nmovslq %edi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    560 <func0+0x560>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nlea    0x7(%rsi),%edi\ncmp    %edi,%eax\njle    490 <func0+0x490>\nmovslq %edi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    570 <func0+0x570>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nlea    0x8(%rsi),%edi\ncmp    %edi,%eax\njle    490 <func0+0x490>\nmovslq %edi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    580 <func0+0x580>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nlea    0x9(%rsi),%edi\ncmp    %edi,%eax\njle    490 <func0+0x490>\nmovslq %edi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    590 <func0+0x590>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nlea    0xa(%rsi),%edi\ncmp    %edi,%eax\njle    490 <func0+0x490>\nmovslq %edi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    5a0 <func0+0x5a0>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nlea    0xb(%rsi),%edi\ncmp    %edi,%eax\njle    490 <func0+0x490>\nmovslq %edi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    5d0 <func0+0x5d0>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nlea    0xc(%rsi),%edi\ncmp    %edi,%eax\njle    490 <func0+0x490>\nmovslq %edi,%rdi\nmovzbl (%rbx,%rdi,1),%edi\nlea    -0x30(%rdi),%r8d\ncmp    $0x9,%r8b\njbe    5d8 <func0+0x5d8>\ncmp    $0x2e,%dil\nsete   %dil\nmovzbl %dil,%edi\nadd    %edi,%ecx\nadd    $0xd,%esi\ncmp    %esi,%eax\njle    490 <func0+0x490>\nmovslq %esi,%rsi\nmovzbl (%rbx,%rsi,1),%eax\nlea    -0x30(%rax),%esi\ncmp    $0x9,%sil\nja     5e0 <func0+0x5e0>\nadd    $0x1,%edx\nnop\ncmp    $0x3,%edx\njg     4a8 <func0+0x4a8>\nlea    0x0(%rip),%r9\ncmp    $0x1,%ecx\nje     4af <func0+0x4af>\nnopl   0x0(%rax)\nlea    0x0(%rip),%r9\nmov    %r9,%rax\npop    %rbx\nretq\nnopl   0x0(%rax)\nmov    $0x5,%ecx\nlea    0x0(%rip),%rdi\nmov    %r8,%rsi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %cl\nsbb    $0x0,%cl\ntest   %cl,%cl\nje     5f <func0+0x5f>\nmov    $0x5,%ecx\nlea    0x0(%rip),%rdi\nmov    %r8,%rsi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %cl\nsbb    $0x0,%cl\ntest   %cl,%cl\nje     5f <func0+0x5f>\njmp    4af <func0+0x4af>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%edx\njmpq   251 <func0+0x251>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%edx\njmpq   27f <func0+0x27f>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%edx\njmpq   2ad <func0+0x2ad>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%edx\njmpq   2db <func0+0x2db>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%edx\njmpq   309 <func0+0x309>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%edx\njmpq   337 <func0+0x337>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%edx\njmpq   365 <func0+0x365>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%edx\njmpq   393 <func0+0x393>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%edx\njmpq   3c1 <func0+0x3c1>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%edx\njmpq   3ef <func0+0x3ef>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%edx\njmpq   41d <func0+0x41d>\nnopl   0x0(%rax,%rax,1)\n00\nsub    $0x30,%edx\ncmp    $0x9,%dl\njbe    211 <func0+0x211>\nxor    %ecx,%ecx\nxor    %edx,%edx\nmov    $0x1,%esi\njmpq   22e <func0+0x22e>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%edx\njmpq   447 <func0+0x447>\nadd    $0x1,%edx\njmpq   471 <func0+0x471>\ncmp    $0x2e,%al\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ecx\njmpq   490 <func0+0x490>"
    },
    {
        "task_id": 142,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmpq   f7 <func0+0xf7>\nmov    -0x4(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %rax,%rdx\nmov    %ecx,%eax\nsar    $0x1f,%eax\nmov    %edx,%esi\nsub    %eax,%esi\nmov    %esi,%eax\nmov    %eax,%edx\nadd    %edx,%edx\nadd    %eax,%edx\nmov    %ecx,%eax\nsub    %edx,%eax\ntest   %eax,%eax\njne    83 <func0+0x83>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nimul   %edx,%eax\nadd    %eax,-0x8(%rbp)\njmp    f3 <func0+0xf3>\nmov    -0x4(%rbp),%eax\nand    $0x3,%eax\ntest   %eax,%eax\njne    da <func0+0xda>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nimul   %edx,%eax\nadd    %eax,-0x8(%rbp)\njmp    f3 <func0+0xf3>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     22 <func0+0x22>\nmov    -0x8(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 142,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    61 <func0+0x61>\nlea    -0x1(%rsi),%r8d\nmov    $0x0,%edx\nmov    $0x0,%ecx\njmp    36 <func0+0x36>\ntest   $0x3,%dl\njne    5c <func0+0x5c>\nmov    (%rdi,%rdx,4),%esi\nmov    %esi,%eax\nimul   %esi,%eax\nimul   %esi,%eax\nadd    %eax,%ecx\nlea    0x1(%rdx),%rax\ncmp    %r8,%rdx\nje     66 <func0+0x66>\nmov    %rax,%rdx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nlea    (%rax,%rax,2),%eax\ncmp    %edx,%eax\njne    18 <func0+0x18>\nmov    (%rdi,%rdx,4),%eax\nimul   %eax,%eax\nadd    %eax,%ecx\njmp    2a <func0+0x2a>\nadd    (%rdi,%rdx,4),%ecx\njmp    2a <func0+0x2a>\nmov    $0x0,%ecx\nmov    %ecx,%eax\nretq"
    },
    {
        "task_id": 142,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    68 <func0+0x68>\nsub    $0x1,%esi\nxor    %eax,%eax\nxor    %r8d,%r8d\njmp    2a <func0+0x2a>\nnopw   0x0(%rax,%rax,1)\nimul   %edx,%edx\nadd    %edx,%r8d\nlea    0x1(%rax),%rdx\ncmp    %rsi,%rax\nje     53 <func0+0x53>\nmov    %rdx,%rax\nimul   $0xaaaaaaab,%eax,%ecx\nmov    (%rdi,%rax,4),%edx\ncmp    $0x55555555,%ecx\njbe    18 <func0+0x18>\ntest   $0x3,%al\njne    60 <func0+0x60>\nmov    %edx,%ecx\nimul   %edx,%ecx\nimul   %ecx,%edx\nadd    %edx,%r8d\nlea    0x1(%rax),%rdx\ncmp    %rsi,%rax\njne    27 <func0+0x27>\nmov    %r8d,%eax\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    %edx,%r8d\njmp    1e <func0+0x1e>\nnopl   (%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 142,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    68 <func0+0x68>\nsub    $0x1,%esi\nxor    %eax,%eax\nxor    %r8d,%r8d\njmp    2a <func0+0x2a>\nnopw   0x0(%rax,%rax,1)\nimul   %edx,%edx\nadd    %edx,%r8d\nlea    0x1(%rax),%rdx\ncmp    %rsi,%rax\nje     53 <func0+0x53>\nmov    %rdx,%rax\nimul   $0xaaaaaaab,%eax,%ecx\nmov    (%rdi,%rax,4),%edx\ncmp    $0x55555555,%ecx\njbe    18 <func0+0x18>\ntest   $0x3,%al\njne    60 <func0+0x60>\nmov    %edx,%ecx\nimul   %edx,%ecx\nimul   %ecx,%edx\nadd    %edx,%r8d\nlea    0x1(%rax),%rdx\ncmp    %rsi,%rax\njne    27 <func0+0x27>\nmov    %r8d,%eax\nretq\nnopw   0x0(%rax,%rax,1)\n00 00\nadd    %edx,%r8d\njmp    1e <func0+0x1e>\nnopl   (%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nretq"
    },
    {
        "task_id": 143,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmpq   f4 <func0+0xf4>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x20,%al\nje     52 <func0+0x52>\naddl   $0x1,-0x14(%rbp)\njmpq   f0 <func0+0xf0>\ncmpl   $0x1,-0x14(%rbp)\njle    89 <func0+0x89>\nmovb   $0x1,-0x15(%rbp)\nmovl   $0x2,-0x8(%rbp)\njmp    7c <func0+0x7c>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    78 <func0+0x78>\nmovb   $0x0,-0x15(%rbp)\njmp    8d <func0+0x8d>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    65 <func0+0x65>\njmp    8d <func0+0x8d>\nmovb   $0x0,-0x15(%rbp)\ncmpb   $0x0,-0x15(%rbp)\nje     e9 <func0+0xe9>\ncmpl   $0x0,-0x10(%rbp)\njle    af <func0+0xaf>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x20,(%rax)\nmov    -0x14(%rbp),%eax\ncltq\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rdx\nsub    %rdx,%rcx\nmov    -0x28(%rbp),%rdx\nlea    (%rcx,%rdx,1),%rsi\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x30(%rbp),%rdx\nadd    %rdx,%rcx\nmov    %rax,%rdx\nmov    %rcx,%rdi\ncallq  e3 <func0+0xe3>\nmov    -0x14(%rbp),%eax\nadd    %eax,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    35 <func0+0x35>\ncmpl   $0x1,-0x14(%rbp)\njle    143 <func0+0x143>\nmovb   $0x1,-0x15(%rbp)\nmovl   $0x2,-0x8(%rbp)\njmp    136 <func0+0x136>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x8(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    132 <func0+0x132>\nmovb   $0x0,-0x15(%rbp)\njmp    147 <func0+0x147>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    11f <func0+0x11f>\njmp    147 <func0+0x147>\nmovb   $0x0,-0x15(%rbp)\ncmpb   $0x0,-0x15(%rbp)\nje     1a3 <func0+0x1a3>\ncmpl   $0x0,-0x10(%rbp)\njle    169 <func0+0x169>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x20,(%rax)\nmov    -0x14(%rbp),%eax\ncltq\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rdx\nsub    %rdx,%rcx\nmov    -0x28(%rbp),%rdx\nlea    (%rcx,%rdx,1),%rsi\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x30(%rbp),%rdx\nadd    %rdx,%rcx\nmov    %rax,%rdx\nmov    %rcx,%rdi\ncallq  19d <func0+0x19d>\nmov    -0x14(%rbp),%eax\nadd    %eax,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\nleaveq\nretq"
    },
    {
        "task_id": 143,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%r14\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     b1 <func0+0xb1>\nmov    %rdi,%r12\nmov    $0x0,%r13d\nmov    $0x0,%ebx\nmov    $0x0,%ebp\njmp    3f <func0+0x3f>\nadd    $0x1,%ebx\nadd    $0x1,%rbp\nmovzbl (%r12,%rbp,1),%eax\ntest   %al,%al\nje     86 <func0+0x86>\ncmp    $0x20,%al\njne    2f <func0+0x2f>\ncmp    $0x1,%ebx\njg     4f <func0+0x4f>\nmov    $0x0,%ebx\njmp    32 <func0+0x32>\ncmp    $0x3,%ebx\njle    f3 <func0+0xf3>\ntest   $0x1,%bl\nje     7f <func0+0x7f>\nmov    $0x2,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebx,%eax\njg     f3 <func0+0xf3>\nmov    %ebx,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    62 <func0+0x62>\nmov    %edx,%ebx\njmp    32 <func0+0x32>\nmov    $0x0,%ebx\njmp    32 <func0+0x32>\ncmp    $0x1,%ebx\njle    e2 <func0+0xe2>\ncmp    $0x3,%ebx\njle    b9 <func0+0xb9>\ntest   $0x1,%bl\nje     e2 <func0+0xe2>\nmov    $0x2,%ecx\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %ebx,%eax\njg     b9 <func0+0xb9>\nmov    %ebx,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    9a <func0+0x9a>\njmp    e2 <func0+0xe2>\nmov    $0x0,%r13d\njmp    e2 <func0+0xe2>\ntest   %r13d,%r13d\njle    ca <func0+0xca>\nmovslq %r13d,%rax\nmovb   $0x20,(%r14,%rax,1)\nlea    0x1(%r13),%r13d\nmovslq %ebx,%rdx\nmovslq %r13d,%rdi\nadd    %r14,%rdi\nsub    %rdx,%rbp\nlea    (%r12,%rbp,1),%rsi\ncallq  df <func0+0xdf>\nadd    %ebx,%r13d\nmovslq %r13d,%r13\nmovb   $0x0,(%r14,%r13,1)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\ntest   %r13d,%r13d\njle    104 <func0+0x104>\nmovslq %r13d,%rax\nmovb   $0x20,(%r14,%rax,1)\nlea    0x1(%r13),%r13d\nmovslq %ebx,%rdx\nmovslq %r13d,%rdi\nadd    %r14,%rdi\nmov    %rbp,%rsi\nsub    %rdx,%rsi\nadd    %r12,%rsi\ncallq  11b <func0+0x11b>\nadd    %ebx,%r13d\nmov    $0x0,%ebx\njmpq   32 <func0+0x32>"
    },
    {
        "task_id": 143,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     c2 <func0+0xc2>\nmov    %rdi,%rbp\nxor    %r13d,%r13d\nxor    %ecx,%ecx\nxor    %ebx,%ebx\njmp    40 <func0+0x40>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%ecx\nadd    $0x1,%rbx\nmovzbl 0x0(%rbp,%rbx,1),%eax\ntest   %al,%al\nje     5c <func0+0x5c>\ncmp    $0x20,%al\njne    30 <func0+0x30>\ncmp    $0x1,%ecx\njg     d8 <func0+0xd8>\nadd    $0x1,%rbx\nxor    %ecx,%ecx\nmovzbl 0x0(%rbp,%rbx,1),%eax\ntest   %al,%al\njne    40 <func0+0x40>\ncmp    $0x1,%ecx\njle    bc <func0+0xbc>\ncmp    $0x3,%ecx\njle    8d <func0+0x8d>\nmov    $0x2,%esi\ntest   $0x1,%cl\njne    81 <func0+0x81>\njmp    bc <func0+0xbc>\nnopw   0x0(%rax,%rax,1)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     bc <func0+0xbc>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    78 <func0+0x78>\ntest   %r13d,%r13d\nje     140 <func0+0x140>\nlea    0x1(%r13),%eax\nmovslq %r13d,%r13\nmovslq %eax,%rdi\nmovb   $0x20,(%r12,%r13,1)\nlea    (%rcx,%rax,1),%r13d\nadd    %r12,%rdi\nmovslq %ecx,%rdx\nsub    %rdx,%rbx\nlea    0x0(%rbp,%rbx,1),%rsi\ncallq  bc <func0+0xbc>\nmovslq %r13d,%r13\nadd    %r13,%r12\nmovb   $0x0,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopw   0x0(%rax,%rax,1)\ncmp    $0x3,%ecx\njle    109 <func0+0x109>\ntest   $0x1,%cl\nje     4d <func0+0x4d>\nmov    $0x2,%esi\njmp    fd <func0+0xfd>\nnopl   (%rax)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     4d <func0+0x4d>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    f0 <func0+0xf0>\ntest   %r13d,%r13d\nje     150 <func0+0x150>\nlea    0x1(%r13),%eax\nmovslq %r13d,%r13\nmovslq %eax,%rdi\nmovb   $0x20,(%r12,%r13,1)\nlea    (%rax,%rcx,1),%r13d\nadd    %r12,%rdi\nmovslq %ecx,%rdx\nmov    %rbx,%rsi\nsub    %rdx,%rsi\nadd    %rbp,%rsi\ncallq  135 <func0+0x135>\nxor    %ecx,%ecx\njmpq   33 <func0+0x33>\nnopl   0x0(%rax)\nmov    %ecx,%r13d\nmov    %r12,%rdi\njmpq   ac <func0+0xac>\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,%r13d\nmov    %r12,%rdi\njmp    124 <func0+0x124>"
    },
    {
        "task_id": 143,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     c2 <func0+0xc2>\nmov    %rdi,%rbp\nxor    %r13d,%r13d\nxor    %ecx,%ecx\nxor    %ebx,%ebx\njmp    40 <func0+0x40>\nnopl   0x0(%rax,%rax,1)\n00\nadd    $0x1,%ecx\nadd    $0x1,%rbx\nmovzbl 0x0(%rbp,%rbx,1),%eax\ntest   %al,%al\nje     5c <func0+0x5c>\ncmp    $0x20,%al\njne    30 <func0+0x30>\ncmp    $0x1,%ecx\njg     d8 <func0+0xd8>\nadd    $0x1,%rbx\nxor    %ecx,%ecx\nmovzbl 0x0(%rbp,%rbx,1),%eax\ntest   %al,%al\njne    40 <func0+0x40>\ncmp    $0x1,%ecx\njle    bc <func0+0xbc>\ncmp    $0x3,%ecx\njle    8d <func0+0x8d>\nmov    $0x2,%esi\ntest   $0x1,%cl\njne    81 <func0+0x81>\njmp    bc <func0+0xbc>\nnopw   0x0(%rax,%rax,1)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     bc <func0+0xbc>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    78 <func0+0x78>\ntest   %r13d,%r13d\nje     140 <func0+0x140>\nlea    0x1(%r13),%eax\nmovslq %r13d,%r13\nmovslq %eax,%rdi\nmovb   $0x20,(%r12,%r13,1)\nlea    (%rcx,%rax,1),%r13d\nadd    %r12,%rdi\nmovslq %ecx,%rdx\nsub    %rdx,%rbx\nlea    0x0(%rbp,%rbx,1),%rsi\ncallq  bc <func0+0xbc>\nmovslq %r13d,%r13\nadd    %r13,%r12\nmovb   $0x0,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nretq\nnopw   0x0(%rax,%rax,1)\ncmp    $0x3,%ecx\njle    109 <func0+0x109>\ntest   $0x1,%cl\nje     4d <func0+0x4d>\nmov    $0x2,%esi\njmp    fd <func0+0xfd>\nnopl   (%rax)\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\nje     4d <func0+0x4d>\nadd    $0x1,%esi\nmov    %esi,%eax\nimul   %esi,%eax\ncmp    %ecx,%eax\njle    f0 <func0+0xf0>\ntest   %r13d,%r13d\nje     150 <func0+0x150>\nlea    0x1(%r13),%eax\nmovslq %r13d,%r13\nmovslq %eax,%rdi\nmovb   $0x20,(%r12,%r13,1)\nlea    (%rax,%rcx,1),%r13d\nadd    %r12,%rdi\nmovslq %ecx,%rdx\nmov    %rbx,%rsi\nsub    %rdx,%rsi\nadd    %rbp,%rsi\ncallq  135 <func0+0x135>\nxor    %ecx,%ecx\njmpq   33 <func0+0x33>\nnopl   0x0(%rax)\nmov    %ecx,%r13d\nmov    %r12,%rdi\njmpq   ac <func0+0xac>\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,%r13d\nmov    %r12,%rdi\njmp    124 <func0+0x124>"
    },
    {
        "task_id": 144,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x110,%rsp\nmov    %rdi,-0x108(%rbp)\nmov    %rsi,-0x110(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0xf8(%rbp)\n00 00 00\njmp    64 <func0+0x64>\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x108(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xf8(%rbp),%eax\ncltq\nmov    %dl,-0xe0(%rbp,%rax,1)\naddl   $0x1,-0xf8(%rbp)\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x108(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njne    38 <func0+0x38>\nmov    -0xf8(%rbp),%eax\ncltq\nmovb   $0x0,-0xe0(%rbp,%rax,1)\n00\nlea    -0xe0(%rbp),%rax\nmov    %rax,%rdi\ncallq  9d <func0+0x9d>\nmov    %eax,-0xf0(%rbp)\nmovl   $0x0,-0xf4(%rbp)\n00 00 00\naddl   $0x1,-0xf8(%rbp)\njmp    e6 <func0+0xe6>\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x108(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xf4(%rbp),%eax\ncltq\nmov    %dl,-0x70(%rbp,%rax,1)\naddl   $0x1,-0xf8(%rbp)\naddl   $0x1,-0xf4(%rbp)\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x108(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    b6 <func0+0xb6>\nmov    -0xf4(%rbp),%eax\ncltq\nmovb   $0x0,-0x70(%rbp,%rax,1)\nlea    -0x70(%rbp),%rax\nmov    %rax,%rdi\ncallq  119 <func0+0x119>\nmov    %eax,-0xec(%rbp)\nmovl   $0x0,-0xf8(%rbp)\n00 00 00\njmp    157 <func0+0x157>\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x110(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xf8(%rbp),%eax\ncltq\nmov    %dl,-0xe0(%rbp,%rax,1)\naddl   $0x1,-0xf8(%rbp)\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x110(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njne    12b <func0+0x12b>\nmov    -0xf8(%rbp),%eax\ncltq\nmovb   $0x0,-0xe0(%rbp,%rax,1)\n00\nlea    -0xe0(%rbp),%rax\nmov    %rax,%rdi\ncallq  190 <func0+0x190>\nmov    %eax,-0xe8(%rbp)\nmovl   $0x0,-0xf4(%rbp)\n00 00 00\naddl   $0x1,-0xf8(%rbp)\njmp    1d9 <func0+0x1d9>\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x110(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0xf4(%rbp),%eax\ncltq\nmov    %dl,-0x70(%rbp,%rax,1)\naddl   $0x1,-0xf8(%rbp)\naddl   $0x1,-0xf4(%rbp)\nmov    -0xf8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x110(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1a9 <func0+0x1a9>\nmov    -0xf4(%rbp),%eax\ncltq\nmovb   $0x0,-0x70(%rbp,%rax,1)\nlea    -0x70(%rbp),%rax\nmov    %rax,%rdi\ncallq  20c <func0+0x20c>\nmov    %eax,-0xe4(%rbp)\nmov    -0xf0(%rbp),%eax\nimul   -0xe8(%rbp),%eax\nmov    -0xec(%rbp),%edx\nmov    %edx,%ecx\nimul   -0xe4(%rbp),%ecx\ncltd\nidiv   %ecx\nmov    %edx,%eax\ntest   %eax,%eax\njne    23e <func0+0x23e>\nmov    $0x1,%eax\njmp    243 <func0+0x243>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rsi\nxor    %fs:0x28,%rsi\n00 00\nje     257 <func0+0x257>\ncallq  257 <func0+0x257>\nleaveq\nretq"
    },
    {
        "task_id": 144,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xe0,%rsp\nmov    %rdi,%rbp\nmov    %rsi,%rbx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xd8(%rsp)\n00\nxor    %eax,%eax\nmovzbl (%rdi),%edx\ncmp    $0x2f,%dl\nje     194 <func0+0x194>\nmov    $0x1,%eax\nlea    -0x1(%rsp),%rcx\nmov    %dl,(%rcx,%rax,1)\nmov    %eax,%r13d\nadd    $0x1,%rax\nmovzbl -0x1(%rbp,%rax,1),%edx\ncmp    $0x2f,%dl\njne    42 <func0+0x42>\nmovslq %r13d,%rax\nmovb   $0x0,(%rsp,%rax,1)\nmov    %rsp,%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncallq  6f <func0+0x6f>\nmov    %rax,%r12\nlea    0x1(%r13),%eax\ncltq\nmovzbl 0x0(%rbp,%rax,1),%eax\ntest   %al,%al\nje     19f <func0+0x19f>\nmov    $0x1,%ecx\nlea    0x6f(%rsp),%rsi\nmovslq %r13d,%r13\nadd    %r13,%rbp\nmov    %al,(%rsi,%rcx,1)\nmov    %ecx,%edx\nadd    $0x1,%rcx\nmovzbl 0x0(%rbp,%rcx,1),%eax\ntest   %al,%al\njne    95 <func0+0x95>\nmovslq %edx,%rdx\nmovb   $0x0,0x70(%rsp,%rdx,1)\nlea    0x70(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncallq  c3 <func0+0xc3>\nmov    %rax,%r13\nmovzbl (%rbx),%eax\ncmp    $0x2f,%al\nje     1a9 <func0+0x1a9>\nmov    $0x1,%ecx\nlea    -0x1(%rsp),%rdx\nmov    %al,(%rdx,%rcx,1)\nmov    %ecx,%ebp\nadd    $0x1,%rcx\nmovzbl -0x1(%rbx,%rcx,1),%eax\ncmp    $0x2f,%al\njne    db <func0+0xdb>\nmovslq %ebp,%rax\nmovb   $0x0,(%rsp,%rax,1)\nmov    %rsp,%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncallq  106 <func0+0x106>\nmov    %rax,%r14\nlea    0x1(%rbp),%eax\ncltq\nmovzbl (%rbx,%rax,1),%eax\ntest   %al,%al\nje     1b3 <func0+0x1b3>\nmov    $0x1,%ecx\nlea    0x6f(%rsp),%rsi\nmovslq %ebp,%rbp\nadd    %rbp,%rbx\nmov    %al,(%rsi,%rcx,1)\nmov    %ecx,%edx\nadd    $0x1,%rcx\nmovzbl (%rbx,%rcx,1),%eax\ntest   %al,%al\njne    12a <func0+0x12a>\nmovslq %edx,%rdx\nmovb   $0x0,0x70(%rsp,%rdx,1)\nlea    0x70(%rsp),%rdi\nmov    $0xa,%edx\nmov    $0x0,%esi\ncallq  157 <func0+0x157>\nmov    %rax,%rdx\nmov    %r14d,%eax\nimul   %r12d,%eax\nimul   %edx,%r13d\ncltd\nidiv   %r13d\ntest   %edx,%edx\nsete   %al\nmovzbl %al,%eax\nmov    0xd8(%rsp),%rdi\n00\nxor    %fs:0x28,%rdi\n00 00\njne    1ba <func0+0x1ba>\nadd    $0xe0,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\nmov    $0x0,%r13d\njmpq   56 <func0+0x56>\nmov    $0x0,%edx\njmpq   a7 <func0+0xa7>\nmov    $0x0,%ebp\njmpq   ed <func0+0xed>\nmov    $0x0,%edx\njmp    13b <func0+0x13b>\ncallq  1bf <func0+0x1bf>"
    },
    {
        "task_id": 144,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0xf8,%rsp\nmovzbl (%rdi),%edx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xe8(%rsp)\n00\nxor    %eax,%eax\ncmp    $0x2f,%dl\nje     1b8 <func0+0x1b8>\nmov    $0x1,%eax\nlea    0xf(%rsp),%rdi\nnopl   0x0(%rax)\nmov    %dl,(%rdi,%rax,1)\nmovslq %eax,%rcx\nadd    $0x1,%rax\nmovzbl -0x1(%rbp,%rax,1),%edx\ncmp    $0x2f,%dl\njne    48 <func0+0x48>\nlea    0x1(%rcx),%r15d\nmovslq %r15d,%r14\nlea    0x10(%rsp),%r13\nmov    $0xa,%edx\nxor    %esi,%esi\nmovb   $0x0,0x10(%rsp,%rcx,1)\nmov    %r13,%rdi\ncallq  7c <func0+0x7c>\nmov    %rax,0x8(%rsp)\nmovzbl 0x0(%rbp,%r14,1),%eax\ntest   %al,%al\nje     1d0 <func0+0x1d0>\nmovslq %r15d,%r15\nmov    $0x1,%ecx\nlea    0x7f(%rsp),%rdx\nadd    %r15,%rbp\nnop\nmov    %al,(%rdx,%rcx,1)\nmovslq %ecx,%rsi\nadd    $0x1,%rcx\nmovzbl -0x1(%rbp,%rcx,1),%eax\ntest   %al,%al\njne    a0 <func0+0xa0>\nlea    0x80(%rsp),%r14\n00\nmovb   $0x0,0x80(%rsp,%rsi,1)\n00\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %r14,%rdi\ncallq  d2 <func0+0xd2>\nmovzbl (%r12),%esi\nmov    %rax,%rbp\ncmp    $0x2f,%sil\nje     1e0 <func0+0x1e0>\nmov    $0x1,%ecx\nlea    0xf(%rsp),%rdi\nxchg   %ax,%ax\nmov    %sil,(%rdi,%rcx,1)\nmovslq %ecx,%rax\nadd    $0x1,%rcx\nmovzbl -0x1(%r12,%rcx,1),%esi\ncmp    $0x2f,%sil\njne    f0 <func0+0xf0>\nlea    0x1(%rax),%ebx\nmovslq %ebx,%r15\nxor    %esi,%esi\nmov    %r13,%rdi\nmov    $0xa,%edx\nmovb   $0x0,0x10(%rsp,%rax,1)\ncallq  121 <func0+0x121>\nmovzbl (%r12,%r15,1),%esi\nmov    %rax,%r13\ntest   %sil,%sil\nje     1f8 <func0+0x1f8>\nmovslq %ebx,%r8\nmov    $0x1,%ecx\nlea    0x7f(%rsp),%rdx\nadd    %r8,%r12\nnopw   0x0(%rax,%rax,1)\nmov    %sil,(%rdx,%rcx,1)\nmovslq %ecx,%rax\nadd    $0x1,%rcx\nmovzbl -0x1(%r12,%rcx,1),%esi\ntest   %sil,%sil\njne    148 <func0+0x148>\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %r14,%rdi\nmovb   $0x0,0x80(%rsp,%rax,1)\n00\ncallq  175 <func0+0x175>\nmov    %rax,%r8\nmov    0x8(%rsp),%eax\nimul   %r8d,%ebp\nimul   %r13d,%eax\ncltd\nidiv   %ebp\nxor    %eax,%eax\ntest   %edx,%edx\nsete   %al\nmov    0xe8(%rsp),%rbx\n00\nxor    %fs:0x28,%rbx\n00 00\njne    1ff <func0+0x1ff>\nadd    $0xf8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%r14d\nmov    $0x1,%r15d\nxor    %ecx,%ecx\njmpq   63 <func0+0x63>\nnopl   0x0(%rax,%rax,1)\nxor    %esi,%esi\njmpq   b3 <func0+0xb3>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    $0x1,%r15d\nmov    $0x1,%ebx\nxor    %eax,%eax\njmpq   10d <func0+0x10d>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\njmpq   15e <func0+0x15e>\ncallq  204 <func0+0x204>"
    },
    {
        "task_id": 144,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0xf8,%rsp\nmovzbl (%rdi),%edx\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xe8(%rsp)\n00\nxor    %eax,%eax\ncmp    $0x2f,%dl\nje     1b8 <func0+0x1b8>\nmov    $0x1,%eax\nlea    0xf(%rsp),%rdi\nnopl   0x0(%rax)\nmov    %dl,(%rdi,%rax,1)\nmovslq %eax,%rcx\nadd    $0x1,%rax\nmovzbl -0x1(%rbp,%rax,1),%edx\ncmp    $0x2f,%dl\njne    48 <func0+0x48>\nlea    0x1(%rcx),%r15d\nmovslq %r15d,%r14\nlea    0x10(%rsp),%r13\nmov    $0xa,%edx\nxor    %esi,%esi\nmovb   $0x0,0x10(%rsp,%rcx,1)\nmov    %r13,%rdi\ncallq  7c <func0+0x7c>\nmov    %rax,0x8(%rsp)\nmovzbl 0x0(%rbp,%r14,1),%eax\ntest   %al,%al\nje     1d0 <func0+0x1d0>\nmovslq %r15d,%r15\nmov    $0x1,%ecx\nlea    0x7f(%rsp),%rdx\nadd    %r15,%rbp\nnop\nmov    %al,(%rdx,%rcx,1)\nmovslq %ecx,%rsi\nadd    $0x1,%rcx\nmovzbl -0x1(%rbp,%rcx,1),%eax\ntest   %al,%al\njne    a0 <func0+0xa0>\nlea    0x80(%rsp),%r14\n00\nmovb   $0x0,0x80(%rsp,%rsi,1)\n00\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %r14,%rdi\ncallq  d2 <func0+0xd2>\nmovzbl (%r12),%esi\nmov    %rax,%rbp\ncmp    $0x2f,%sil\nje     1e0 <func0+0x1e0>\nmov    $0x1,%ecx\nlea    0xf(%rsp),%rdi\nxchg   %ax,%ax\nmov    %sil,(%rdi,%rcx,1)\nmovslq %ecx,%rax\nadd    $0x1,%rcx\nmovzbl -0x1(%r12,%rcx,1),%esi\ncmp    $0x2f,%sil\njne    f0 <func0+0xf0>\nlea    0x1(%rax),%ebx\nmovslq %ebx,%r15\nxor    %esi,%esi\nmov    %r13,%rdi\nmov    $0xa,%edx\nmovb   $0x0,0x10(%rsp,%rax,1)\ncallq  121 <func0+0x121>\nmovzbl (%r12,%r15,1),%esi\nmov    %rax,%r13\ntest   %sil,%sil\nje     1f8 <func0+0x1f8>\nmovslq %ebx,%r8\nmov    $0x1,%ecx\nlea    0x7f(%rsp),%rdx\nadd    %r8,%r12\nnopw   0x0(%rax,%rax,1)\nmov    %sil,(%rdx,%rcx,1)\nmovslq %ecx,%rax\nadd    $0x1,%rcx\nmovzbl -0x1(%r12,%rcx,1),%esi\ntest   %sil,%sil\njne    148 <func0+0x148>\nmov    $0xa,%edx\nxor    %esi,%esi\nmov    %r14,%rdi\nmovb   $0x0,0x80(%rsp,%rax,1)\n00\ncallq  175 <func0+0x175>\nmov    %rax,%r8\nmov    0x8(%rsp),%eax\nimul   %r8d,%ebp\nimul   %r13d,%eax\ncltd\nidiv   %ebp\nxor    %eax,%eax\ntest   %edx,%edx\nsete   %al\nmov    0xe8(%rsp),%rbx\n00\nxor    %fs:0x28,%rbx\n00 00\njne    1ff <func0+0x1ff>\nadd    $0xf8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%r14d\nmov    $0x1,%r15d\nxor    %ecx,%ecx\njmpq   63 <func0+0x63>\nnopl   0x0(%rax,%rax,1)\nxor    %esi,%esi\njmpq   b3 <func0+0xb3>\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    $0x1,%r15d\nmov    $0x1,%ebx\nxor    %eax,%eax\njmpq   10d <func0+0x10d>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\njmpq   15e <func0+0x15e>\ncallq  204 <func0+0x204>"
    },
    {
        "task_id": 145,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %esi,-0x4c(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x4c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  33 <func0+0x33>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x3c(%rbp)\njmpq   109 <func0+0x109>\nmov    -0x3c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltd\nxor    %edx,%eax\nsub    %edx,%eax\nlea    -0x14(%rbp),%rcx\nmov    %eax,%edx\nlea    0x0(%rip),%rsi\nmov    %rcx,%rdi\nmov    $0x0,%eax\ncallq  78 <func0+0x78>\nmovl   $0x0,-0x38(%rbp)\nlea    -0x14(%rbp),%rax\nmov    %rax,%rdi\ncallq  8b <func0+0x8b>\nmov    %eax,-0x24(%rbp)\nmovl   $0x1,-0x34(%rbp)\njmp    ae <func0+0xae>\nmov    -0x34(%rbp),%eax\ncltq\nmovzbl -0x14(%rbp,%rax,1),%eax\nmovsbl %al,%eax\nsub    $0x30,%eax\nadd    %eax,-0x38(%rbp)\naddl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     97 <func0+0x97>\nmov    -0x3c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njle    df <func0+0xdf>\nmovzbl -0x14(%rbp),%eax\nmovsbl %al,%eax\nsub    $0x30,%eax\nadd    %eax,-0x38(%rbp)\njmp    ec <func0+0xec>\nmovzbl -0x14(%rbp),%eax\nmovsbl %al,%eax\nsub    $0x30,%eax\nsub    %eax,-0x38(%rbp)\nmov    -0x3c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncmp    -0x4c(%rbp),%eax\njl     43 <func0+0x43>\nmovl   $0x0,-0x30(%rbp)\njmpq   233 <func0+0x233>\nmovl   $0x1,-0x2c(%rbp)\njmpq   223 <func0+0x223>\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    21f <func0+0x21f>\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x28(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x2c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x28(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x2c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x48(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x4c(%rbp),%eax\njl     12d <func0+0x12d>\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x4c(%rbp),%eax\njl     121 <func0+0x121>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncallq  24b <func0+0x24b>\nmov    -0x48(%rbp),%rax\nmov    -0x8(%rbp),%rsi\nxor    %fs:0x28,%rsi\n00 00\nje     263 <func0+0x263>\ncallq  263 <func0+0x263>\nleaveq\nretq"
    },
    {
        "task_id": 145,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,%rbp\nmov    %esi,%r14d\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nmovslq %esi,%rdi\nshl    $0x2,%rdi\ncallq  34 <func0+0x34>\nmov    %rax,%rbx\ntest   %r14d,%r14d\njle    171 <func0+0x171>\nmov    %rbp,%r12\nmov    %rax,%r13\nmov    %r14d,0x1c(%rsp)\nlea    -0x1(%r14),%eax\nlea    0x4(%rbp,%rax,4),%rax\nmov    %rax,0x10(%rsp)\nlea    0x2c(%rsp),%r15\njmp    8b <func0+0x8b>\nmov    $0x0,%edx\njmpq   fe <func0+0xfe>\nmovsbl 0x2c(%rsp),%eax\nsub    $0x30,%eax\nsub    %eax,%edx\nmov    %edx,0x0(%r13)\nadd    $0x4,%r12\nadd    $0x4,%r13\ncmp    0x10(%rsp),%r12\nje     11a <func0+0x11a>\nmov    %r12,0x8(%rsp)\nmov    (%r12),%eax\nsar    $0x1f,%eax\nmov    %eax,%r8d\nxor    (%r12),%r8d\nsub    %eax,%r8d\nlea    0x0(%rip),%rcx\nmov    $0xc,%edx\nmov    $0x1,%esi\nmov    %r15,%rdi\nmov    $0x0,%eax\ncallq  bf <func0+0xbf>\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nmov    %r15,%rdi\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nsub    $0x1,%rcx\ncmp    $0x1,%ecx\njle    60 <func0+0x60>\nlea    0x2d(%rsp),%rax\nlea    -0x2(%rcx),%edx\nlea    0x2e(%rsp,%rdx,1),%rsi\nmov    $0x0,%edx\nmovsbl (%rax),%ecx\nlea    -0x30(%rdx,%rcx,1),%edx\nadd    $0x1,%rax\ncmp    %rsi,%rax\njne    ee <func0+0xee>\nmov    0x8(%rsp),%rax\ncmpl   $0x0,(%rax)\njle    6a <func0+0x6a>\nmovsbl 0x2c(%rsp),%eax\nlea    -0x30(%rdx,%rax,1),%edx\njmpq   74 <func0+0x74>\nmov    $0x0,%edi\nmov    0x1c(%rsp),%eax\nlea    -0x2(%rax),%esi\nmov    $0x0,%r8d\njmp    166 <func0+0x166>\nlea    0x1(%rax),%rdx\ncmp    %rax,%rsi\nje     15e <func0+0x15e>\nmov    %rdx,%rax\nmov    (%rbx,%rax,4),%ecx\nmov    0x4(%rbx,%rax,4),%edx\ncmp    %edx,%ecx\njle    12e <func0+0x12e>\nmov    %ecx,0x4(%rbx,%rax,4)\nmov    %edx,(%rbx,%rax,4)\nmov    0x4(%rbp,%rax,4),%edx\nmov    0x0(%rbp,%rax,4),%ecx\nmov    %ecx,0x4(%rbp,%rax,4)\nmov    %edx,0x0(%rbp,%rax,4)\njmp    12e <func0+0x12e>\nadd    $0x1,%edi\ncmp    %edi,%r14d\nje     171 <func0+0x171>\nmov    %r8,%rax\ncmp    $0x1,%r14d\njg     13a <func0+0x13a>\njmp    15e <func0+0x15e>\nmov    %rbx,%rdi\ncallq  179 <func0+0x179>\nmov    0x38(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    19b <func0+0x19b>\nmov    %rbp,%rax\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\ncallq  1a0 <func0+0x1a0>"
    },
    {
        "task_id": 145,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\nmovslq %esi,%rdi\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nshl    $0x2,%rdi\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\ncallq  34 <func0+0x34>\nmov    %rax,%rbp\ntest   %ebx,%ebx\njle    171 <func0+0x171>\nmov    %rax,%r12\nlea    -0x1(%rbx),%eax\nlea    0x1c(%rsp),%r13\nmov    %r14,%r15\nlea    0x4(%r14,%rax,4),%rax\nmov    %rax,(%rsp)\nlea    0x1e(%rsp),%rax\nmov    %rax,0x8(%rsp)\nmov    (%r15),%eax\nmov    (%r15),%r8d\nmov    $0xc,%edx\nmov    $0x1,%esi\nlea    0x0(%rip),%rcx\nmov    %r13,%rdi\nsar    $0x1f,%eax\nxor    %eax,%r8d\nsub    %eax,%r8d\nxor    %eax,%eax\ncallq  8a <func0+0x8a>\nmov    %r13,%rdx\nmov    (%rdx),%ecx\nadd    $0x4,%rdx\nlea    -0x1010101(%rcx),%eax\nnot    %ecx\nand    %ecx,%eax\nand    $0x80808080,%eax\nje     8d <func0+0x8d>\nmov    %eax,%ecx\nshr    $0x10,%ecx\ntest   $0x8080,%eax\ncmove  %ecx,%eax\nlea    0x2(%rdx),%rcx\ncmove  %rcx,%rdx\nmov    %eax,%edi\nadd    %al,%dil\nsbb    $0x3,%rdx\nsub    %r13,%rdx\ncmp    $0x1,%rdx\njbe    1a0 <func0+0x1a0>\nlea    -0x2(%rdx),%esi\nlea    0x1d(%rsp),%rax\nadd    0x8(%rsp),%rsi\nxor    %edx,%edx\nxchg   %ax,%ax\nmovsbl (%rax),%ecx\nadd    $0x1,%rax\nlea    -0x30(%rdx,%rcx,1),%edx\ncmp    %rax,%rsi\njne    e0 <func0+0xe0>\nmovsbl 0x1c(%rsp),%eax\nsub    $0x30,%eax\nlea    (%rdx,%rax,1),%ecx\nsub    %eax,%edx\nmov    (%r15),%eax\ntest   %eax,%eax\ncmovg  %ecx,%edx\nadd    $0x4,%r15\nadd    $0x4,%r12\nmov    %edx,-0x4(%r12)\ncmp    %r15,(%rsp)\njne    60 <func0+0x60>\nxor    %edi,%edi\nlea    -0x2(%rbx),%esi\nnopl   0x0(%rax)\nxor    %eax,%eax\ncmp    $0x1,%ebx\njne    13b <func0+0x13b>\njmp    16a <func0+0x16a>\nnopl   0x0(%rax)\nmov    %rdx,%rax\nmov    0x0(%rbp,%rax,4),%ecx\nmov    0x4(%rbp,%rax,4),%edx\ncmp    %edx,%ecx\njle    161 <func0+0x161>\nmov    %ecx,0x4(%rbp,%rax,4)\nmov    (%r14,%rax,4),%ecx\nmov    %edx,0x0(%rbp,%rax,4)\nmov    0x4(%r14,%rax,4),%edx\nmov    %ecx,0x4(%r14,%rax,4)\nmov    %edx,(%r14,%rax,4)\nlea    0x1(%rax),%rdx\ncmp    %rax,%rsi\njne    138 <func0+0x138>\nadd    $0x1,%edi\ncmp    %edi,%ebx\njne    128 <func0+0x128>\nmov    %rbp,%rdi\ncallq  179 <func0+0x179>\nmov    0x28(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    1a7 <func0+0x1a7>\nadd    $0x38,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax,%rax,1)\nxor    %edx,%edx\njmpq   f0 <func0+0xf0>\ncallq  1ac <func0+0x1ac>"
    },
    {
        "task_id": 145,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\nmovslq %esi,%rdi\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x38,%rsp\nmov    %edi,0xc(%rsp)\nshl    $0x2,%rdi\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\ncallq  38 <func0+0x38>\nmov    %rax,%rbp\ntest   %ebx,%ebx\njle    1e3 <func0+0x1e3>\nmov    %ebx,%eax\nmov    %r14,%r15\nmov    %rbp,%rbx\nsub    $0x1,%eax\nlea    0x1c(%rsp),%r13\nlea    0x0(%rip),%r12\nlea    0x4(%r14,%rax,4),%rax\nmov    %rax,(%rsp)\njmpq   11c <func0+0x11c>\nnopl   0x0(%rax,%rax,1)\n00\nmovsbl 0x1d(%rsp),%eax\nsub    $0x30,%eax\ncmp    $0x2,%edx\nje     f6 <func0+0xf6>\nmovsbl 0x1e(%rsp),%edx\nlea    -0x30(%rax,%rdx,1),%eax\ncmp    $0x3,%ecx\nje     f6 <func0+0xf6>\nmovsbl 0x1f(%rsp),%edx\nlea    -0x30(%rax,%rdx,1),%eax\ncmp    $0x4,%ecx\nje     f6 <func0+0xf6>\nmovsbl 0x20(%rsp),%edx\nlea    -0x30(%rax,%rdx,1),%eax\ncmp    $0x5,%ecx\nje     f6 <func0+0xf6>\nmovsbl 0x21(%rsp),%edx\nlea    -0x30(%rax,%rdx,1),%eax\ncmp    $0x6,%ecx\nje     f6 <func0+0xf6>\nmovsbl 0x22(%rsp),%edx\nlea    -0x30(%rax,%rdx,1),%eax\ncmp    $0x7,%ecx\nje     f6 <func0+0xf6>\nmovsbl 0x23(%rsp),%edx\nlea    -0x30(%rax,%rdx,1),%eax\ncmp    $0x8,%ecx\nje     f6 <func0+0xf6>\nmovsbl 0x24(%rsp),%edx\nlea    -0x30(%rax,%rdx,1),%eax\ncmp    $0x9,%ecx\nje     f6 <func0+0xf6>\nmovsbl 0x25(%rsp),%edx\nlea    -0x30(%rax,%rdx,1),%eax\ncmp    $0xb,%ecx\njne    f6 <func0+0xf6>\nmovsbl 0x26(%rsp),%edx\nlea    -0x30(%rax,%rdx,1),%eax\nmovsbl 0x1c(%rsp),%edx\nsub    $0x30,%edx\nlea    (%rax,%rdx,1),%ecx\nsub    %edx,%eax\nmov    (%r15),%edx\ntest   %edx,%edx\ncmovg  %ecx,%eax\nadd    $0x4,%r15\nadd    $0x4,%rbx\nmov    %eax,-0x4(%rbx)\ncmp    (%rsp),%r15\nje     190 <func0+0x190>\nmov    (%r15),%eax\nmov    (%r15),%r8d\nmov    $0xc,%edx\nmov    %r12,%rcx\nmov    $0x1,%esi\nmov    %r13,%rdi\nsar    $0x1f,%eax\nxor    %eax,%r8d\nsub    %eax,%r8d\nxor    %eax,%eax\ncallq  142 <func0+0x142>\nmov    %r13,%rdx\nmov    (%rdx),%ecx\nadd    $0x4,%rdx\nlea    -0x1010101(%rcx),%eax\nnot    %ecx\nand    %ecx,%eax\nand    $0x80808080,%eax\nje     145 <func0+0x145>\nmov    %eax,%ecx\nshr    $0x10,%ecx\ntest   $0x8080,%eax\ncmove  %ecx,%eax\nlea    0x2(%rdx),%rcx\ncmove  %rcx,%rdx\nmov    %eax,%edi\nadd    %al,%dil\nsbb    $0x3,%rdx\nsub    %r13,%rdx\nmov    %edx,%ecx\ncmp    $0x1,%rdx\nja     70 <func0+0x70>\nxor    %eax,%eax\njmpq   f6 <func0+0xf6>\nmov    0xc(%rsp),%eax\nxor    %edi,%edi\nlea    -0x2(%rax),%esi\ncmp    $0x1,%eax\nje     1e3 <func0+0x1e3>\nxchg   %ax,%ax\nxor    %eax,%eax\njmp    1ab <func0+0x1ab>\nnopl   0x0(%rax)\nmov    %rdx,%rax\nmov    0x0(%rbp,%rax,4),%ecx\nmov    0x4(%rbp,%rax,4),%edx\ncmp    %edx,%ecx\njle    1d1 <func0+0x1d1>\nmov    %ecx,0x4(%rbp,%rax,4)\nmov    (%r14,%rax,4),%ecx\nmov    %edx,0x0(%rbp,%rax,4)\nmov    0x4(%r14,%rax,4),%edx\nmov    %ecx,0x4(%r14,%rax,4)\nmov    %edx,(%r14,%rax,4)\nlea    0x1(%rax),%rdx\ncmp    %rax,%rsi\njne    1a8 <func0+0x1a8>\nadd    $0x1,%edi\ncmp    %edi,0xc(%rsp)\njne    1a0 <func0+0x1a0>\nmov    %rbp,%rdi\ncallq  1eb <func0+0x1eb>\nmov    0x28(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    20d <func0+0x20d>\nadd    $0x38,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\ncallq  212 <func0+0x212>"
    },
    {
        "task_id": 146,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmpq   fc <func0+0xfc>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    $0xa,%eax\njle    f8 <func0+0xf8>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%ecx\nsar    $0x2,%ecx\nmov    %edx,%eax\nsar    $0x1f,%eax\nsub    %eax,%ecx\nmov    %ecx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%ecx\nmov    %ecx,%eax\nshl    $0x2,%eax\nadd    %ecx,%eax\nadd    %eax,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\njmp    c2 <func0+0xc2>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x9,-0xc(%rbp)\njg     a4 <func0+0xa4>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    f8 <func0+0xf8>\nmov    -0x8(%rbp),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    f8 <func0+0xf8>\naddl   $0x1,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     22 <func0+0x22>\nmov    -0x14(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 146,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    93 <func0+0x93>\nmov    %rdi,%r8\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rdi\nmov    $0x0,%r9d\njmp    28 <func0+0x28>\nadd    $0x4,%r8\ncmp    %rdi,%r8\nje     99 <func0+0x99>\nmov    (%r8),%esi\ncmp    $0xa,%esi\njle    1f <func0+0x1f>\nmov    %esi,%eax\nmov    %eax,%ecx\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nsar    $0x22,%rdx\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\ncmp    $0x63,%ecx\njg     32 <func0+0x32>\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    1f <func0+0x1f>\nmovslq %esi,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %esi,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,4),%eax\nadd    %eax,%eax\nsub    %eax,%esi\nmov    %esi,%eax\nshr    $0x1f,%eax\nadd    %eax,%esi\nand    $0x1,%esi\nsub    %eax,%esi\ncmp    $0x1,%esi\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%r9d\njmp    1f <func0+0x1f>\nmov    $0x0,%r9d\nmov    %r9d,%eax\nretq"
    },
    {
        "task_id": 146,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    65 <func0+0x65>\nlea    -0x1(%rsi),%eax\nxor    %r9d,%r9d\nmov    $0xcccccccd,%esi\nlea    0x4(%rdi,%rax,4),%r8\njmp    29 <func0+0x29>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rdi\ncmp    %r8,%rdi\nje     61 <func0+0x61>\nmov    (%rdi),%ecx\ncmp    $0xa,%ecx\njle    20 <func0+0x20>\nmov    %ecx,%eax\nnopw   0x0(%rax,%rax,1)\nmov    %eax,%eax\nmov    %rax,%rdx\nimul   %rsi,%rax\nshr    $0x23,%rax\ncmp    $0x63,%edx\njg     38 <func0+0x38>\ntest   $0x1,%al\nje     20 <func0+0x20>\nand    $0x1,%ecx\ncmp    $0x1,%ecx\nsbb    $0xffffffff,%r9d\nadd    $0x4,%rdi\ncmp    %r8,%rdi\njne    29 <func0+0x29>\nmov    %r9d,%eax\nretq\nxor    %r9d,%r9d\nmov    %r9d,%eax\nretq"
    },
    {
        "task_id": 146,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %esi,%esi\njle    65 <func0+0x65>\nlea    -0x1(%rsi),%eax\nxor    %r9d,%r9d\nmov    $0xcccccccd,%esi\nlea    0x4(%rdi,%rax,4),%r8\njmp    29 <func0+0x29>\nnopw   0x0(%rax,%rax,1)\nadd    $0x4,%rdi\ncmp    %r8,%rdi\nje     61 <func0+0x61>\nmov    (%rdi),%ecx\ncmp    $0xa,%ecx\njle    20 <func0+0x20>\nmov    %ecx,%eax\nnopw   0x0(%rax,%rax,1)\nmov    %eax,%eax\nmov    %rax,%rdx\nimul   %rsi,%rax\nshr    $0x23,%rax\ncmp    $0x63,%edx\njg     38 <func0+0x38>\ntest   $0x1,%al\nje     20 <func0+0x20>\nand    $0x1,%ecx\ncmp    $0x1,%ecx\nsbb    $0xffffffff,%r9d\nadd    $0x4,%rdi\ncmp    %r8,%rdi\njne    29 <func0+0x29>\nmov    %r9d,%eax\nretq\nxor    %r9d,%r9d\nmov    %r9d,%eax\nretq"
    },
    {
        "task_id": 147,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %edi,-0x64(%rbp)\nmov    -0x64(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  21 <func0+0x21>\nmov    %rax,-0x28(%rbp)\nmov    -0x64(%rbp),%eax\nadd    $0x1,%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncallq  39 <func0+0x39>\nmov    %rax,-0x20(%rbp)\nmov    -0x64(%rbp),%eax\nadd    $0x1,%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncallq  51 <func0+0x51>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x54(%rbp)\njmp    b0 <func0+0xb0>\nmov    -0x54(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    $0x4,%esi\nmov    $0x3,%edi\ncallq  82 <func0+0x82>\nmov    %rax,(%rbx)\nmov    -0x54(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    $0x4,%esi\nmov    $0x3,%edi\ncallq  a9 <func0+0xa9>\nmov    %rax,(%rbx)\naddl   $0x1,-0x54(%rbp)\nmov    -0x54(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    5e <func0+0x5e>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nlea    0x8(%rax),%rdx\nmovl   $0x0,(%rdx)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nadd    $0x4,%rax\nmov    (%rdx),%edx\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rdx\nmov    (%rdx),%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nlea    0x8(%rax),%rdx\nmovl   $0x0,(%rdx)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nadd    $0x4,%rax\nmov    (%rdx),%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rdx\nmov    (%rdx),%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmovl   $0x1,-0x50(%rbp)\njmpq   23e <func0+0x23e>\nmov    -0x50(%rbp),%eax\nimul   %eax,%eax\nsub    -0x50(%rbp),%eax\nlea    0x1(%rax),%ecx\nmov    -0x50(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rsi\nmovslq %ecx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %rax,%rdx\nmov    %ecx,%eax\nsar    $0x1f,%eax\nmov    %edx,%ebx\nsub    %eax,%ebx\nmov    %ebx,%eax\nmov    %eax,%edx\nadd    %edx,%edx\nadd    %eax,%edx\nmov    %ecx,%eax\nsub    %edx,%eax\nmov    %eax,(%rsi)\nmovl   $0x0,-0x4c(%rbp)\njmp    1bd <func0+0x1bd>\nmov    -0x50(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x4c(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    -0x50(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%rdx\nmov    -0x4c(%rbp),%ecx\nmovslq %ecx,%rcx\nshl    $0x2,%rcx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x4c(%rbp)\ncmpl   $0x2,-0x4c(%rbp)\njle    16c <func0+0x16c>\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x50(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nlea    -0x4(%rdx),%rcx\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rcx\n00\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    -0x50(%rbp),%ecx\nmovslq %ecx,%rcx\nshl    $0x2,%rcx\nlea    -0x4(%rcx),%rsi\nmov    -0x28(%rbp),%rcx\nadd    %rsi,%rcx\nmov    (%rcx),%ecx\nmovslq %ecx,%rcx\nshl    $0x2,%rcx\nadd    %rcx,%rax\nadd    $0x1,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0x50(%rbp)\nmov    -0x50(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    11a <func0+0x11a>\nmovl   $0x1,-0x48(%rbp)\njmpq   455 <func0+0x455>\nmovl   $0x1,-0x44(%rbp)\njmpq   39b <func0+0x39b>\nmovl   $0x0,-0x40(%rbp)\njmp    2bc <func0+0x2bc>\nmov    -0x44(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x40(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    -0x44(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%rdx\nmov    -0x40(%rbp),%ecx\nmovslq %ecx,%rcx\nshl    $0x2,%rcx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x40(%rbp)\ncmpl   $0x2,-0x40(%rbp)\njle    26b <func0+0x26b>\ncmpl   $0x0,-0x44(%rbp)\njle    397 <func0+0x397>\nmovl   $0x0,-0x3c(%rbp)\njmpq   38d <func0+0x38d>\nmov    -0x44(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rsi\nmov    -0x44(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x3c(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmovslq %ecx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %rax,%rdx\nmov    %ecx,%eax\nsar    $0x1f,%eax\nmov    %edx,%ebx\nsub    %eax,%ebx\nmov    %ebx,%eax\nmov    %eax,%edx\nadd    %edx,%edx\nadd    %eax,%edx\nmov    %ecx,%eax\nsub    %edx,%eax\nmovslq %eax,%rdx\nshl    $0x2,%rdx\nadd    %rsi,%rdx\nmov    (%rdx),%ecx\nmov    -0x44(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x3,%rdx\nlea    -0x8(%rdx),%rsi\nmov    -0x20(%rbp),%rdx\nadd    %rsi,%rdx\nmov    (%rdx),%rdx\nmov    -0x3c(%rbp),%esi\nmovslq %esi,%rsi\nshl    $0x2,%rsi\nadd    %rsi,%rdx\nmov    (%rdx),%edx\nmov    -0x44(%rbp),%esi\nmovslq %esi,%rsi\nlea    0x0(,%rsi,8),%rdi\n00\nmov    -0x18(%rbp),%rsi\nadd    %rdi,%rsi\nmov    (%rsi),%rsi\ncltq\nshl    $0x2,%rax\nadd    %rsi,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x2,-0x3c(%rbp)\njle    2d8 <func0+0x2d8>\naddl   $0x1,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    262 <func0+0x262>\nmovl   $0x0,-0x38(%rbp)\njmpq   445 <func0+0x445>\nmovl   $0x0,-0x34(%rbp)\njmp    437 <func0+0x437>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x34(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmov    -0x38(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%rdx\nmov    -0x34(%rbp),%ecx\nmovslq %ecx,%rcx\nshl    $0x2,%rcx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x34(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nadd    %rdx,%rax\nmovl   $0x0,(%rax)\naddl   $0x1,-0x34(%rbp)\ncmpl   $0x2,-0x34(%rbp)\njle    3bc <func0+0x3bc>\naddl   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    3b3 <func0+0x3b3>\naddl   $0x1,-0x48(%rbp)\ncmpl   $0x2,-0x48(%rbp)\njle    256 <func0+0x256>\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    (%rax),%eax\nmov    %eax,-0x2c(%rbp)\nmovl   $0x0,-0x30(%rbp)\njmp    4c6 <func0+0x4c6>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncallq  4a3 <func0+0x4a3>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncallq  4c2 <func0+0x4c2>\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    484 <func0+0x484>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncallq  4da <func0+0x4da>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncallq  4e6 <func0+0x4e6>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  4f2 <func0+0x4f2>\nmov    -0x2c(%rbp),%eax\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 147,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %edi,%r13d\nmovslq %edi,%rdi\nshl    $0x2,%rdi\ncallq  21 <func0+0x21>\nmov    %rax,%r14\nlea    0x1(%r13),%eax\ncltq\nlea    0x0(,%rax,8),%rbx\n00\nmov    %rbx,0x8(%rsp)\nmov    %rbx,%rdi\ncallq  3f <func0+0x3f>\nmov    %rax,%rbp\nmov    %rbx,%rdi\ncallq  4a <func0+0x4a>\nmov    %rax,%rbx\ntest   %r13d,%r13d\njs     93 <func0+0x93>\nmov    %r13d,%eax\nlea    0x8(,%rax,8),%r15\n00\nmov    $0x0,%r12d\nmov    $0x4,%esi\nmov    $0x3,%edi\ncallq  72 <func0+0x72>\nmov    %rax,0x0(%rbp,%r12,1)\nmov    $0x4,%esi\nmov    $0x3,%edi\ncallq  86 <func0+0x86>\nmov    %rax,(%rbx,%r12,1)\nadd    $0x8,%r12\ncmp    %r12,%r15\njne    63 <func0+0x63>\nmov    0x0(%rbp),%rax\nmovl   $0x0,0x8(%rax)\nmovl   $0x0,0x4(%rax)\nmovl   $0x0,(%rax)\nmov    (%rbx),%rax\nmovl   $0x0,0x8(%rax)\nmovl   $0x0,0x4(%rax)\nmovl   $0x0,(%rax)\ntest   %r13d,%r13d\njle    12c <func0+0x12c>\nlea    -0x1(%r13),%esi\nadd    $0x2,%rsi\nmov    $0x1,%edx\nmov    %edx,%ecx\nimul   %edx,%ecx\nsub    %edx,%ecx\nadd    $0x1,%ecx\nmovslq %ecx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %ecx,%edi\nsar    $0x1f,%edi\nsub    %edi,%eax\nlea    (%rax,%rax,2),%eax\nsub    %eax,%ecx\nmov    %ecx,%eax\nmov    %ecx,-0x4(%r14,%rdx,4)\nmov    -0x8(%rbp,%rdx,8),%rdi\nmov    0x0(%rbp,%rdx,8),%rcx\nmov    (%rdi),%r8d\nmov    %r8d,(%rcx)\nmov    0x4(%rdi),%r8d\nmov    %r8d,0x4(%rcx)\nmov    0x8(%rdi),%edi\nmov    %edi,0x8(%rcx)\ncltq\naddl   $0x1,(%rcx,%rax,4)\nadd    $0x1,%rdx\ncmp    %rdx,%rsi\njne    d4 <func0+0xd4>\nmov    $0x2,%r10d\nlea    -0x1(%r13),%r9d\nadd    $0x2,%r9\njmpq   1f0 <func0+0x1f0>\nadd    $0x1,%rcx\ncmp    %rcx,%r9\nje     1af <func0+0x1af>\nmov    -0x8(%rbx,%rcx,8),%rax\nmov    (%rbx,%rcx,8),%rsi\nmov    (%rax),%edx\nmov    %edx,(%rsi)\nmov    0x4(%rax),%edx\nmov    %edx,0x4(%rsi)\nmov    0x8(%rax),%eax\nmov    %eax,0x8(%rsi)\ntest   %ecx,%ecx\njle    13f <func0+0x13f>\nmov    -0x4(%r14,%rcx,4),%r8d\nmov    -0x8(%rbp,%rcx,8),%rdi\nmov    $0x0,%edx\nlea    (%r8,%rdx,1),%eax\nmovslq %eax,%r11\nimul   $0x55555556,%r11,%r11\nshr    $0x20,%r11\nmov    %eax,%r12d\nsar    $0x1f,%r12d\nsub    %r12d,%r11d\nlea    (%r11,%r11,2),%r11d\nsub    %r11d,%eax\ncltq\nmov    (%rdi,%rdx,4),%r11d\nadd    %r11d,(%rsi,%rax,4)\nadd    $0x1,%rdx\ncmp    $0x3,%rdx\njne    174 <func0+0x174>\njmp    13f <func0+0x13f>\njne    1ea <func0+0x1ea>\nmov    $0x0,%edx\nmov    (%rbx,%rdx,8),%rax\nmov    0x0(%rbp,%rdx,8),%rcx\nmov    (%rax),%esi\nmov    %esi,(%rcx)\nmovl   $0x0,(%rax)\nmov    0x4(%rax),%esi\nmov    %esi,0x4(%rcx)\nmovl   $0x0,0x4(%rax)\nmov    0x8(%rax),%esi\nmov    %esi,0x8(%rcx)\nmovl   $0x0,0x8(%rax)\nadd    $0x1,%rdx\ncmp    %edx,%r13d\njge    1b4 <func0+0x1b4>\nsub    $0x1,%r10d\nje     1ff <func0+0x1ff>\ntest   %r13d,%r13d\njle    1ad <func0+0x1ad>\nmov    $0x1,%ecx\njmpq   148 <func0+0x148>\nmov    0x8(%rsp),%rax\nmov    -0x8(%rbp,%rax,1),%rax\nmov    (%rax),%r15d\ntest   %r13d,%r13d\njs     23e <func0+0x23e>\nmov    %r13d,%r13d\nlea    0x8(,%r13,8),%r13\n00\nmov    $0x0,%r12d\nmov    0x0(%rbp,%r12,1),%rdi\ncallq  22c <func0+0x22c>\nmov    (%rbx,%r12,1),%rdi\ncallq  235 <func0+0x235>\nadd    $0x8,%r12\ncmp    %r13,%r12\njne    222 <func0+0x222>\nmov    %rbp,%rdi\ncallq  246 <func0+0x246>\nmov    %rbx,%rdi\ncallq  24e <func0+0x24e>\nmov    %r14,%rdi\ncallq  256 <func0+0x256>\nmov    %r15d,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 147,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmovslq %edi,%r14\npush   %r13\nlea    0x0(,%r14,4),%rdi\n00\npush   %r12\npush   %rbp\npush   %rbx\nmov    %r14,%rbx\nsub    $0x28,%rsp\nmov    %r14,0x18(%rsp)\ncallq  2a <func0+0x2a>\nmov    %rax,%rbp\nlea    0x1(%r14),%eax\nlea    0x8(,%r14,8),%r14\n00\ncltq\nlea    0x0(,%rax,8),%r15\n00\nmov    %r15,%rdi\nmov    %r15,0x10(%rsp)\ncallq  50 <func0+0x50>\nmov    %r15,%rdi\nxor    %r15d,%r15d\nmov    %rax,%r12\ncallq  5e <func0+0x5e>\nmov    %rax,%r13\ntest   %ebx,%ebx\njs     2a6 <func0+0x2a6>\nnopl   0x0(%rax)\nmov    $0x4,%esi\nmov    $0x3,%edi\ncallq  7f <func0+0x7f>\nmov    $0x4,%esi\nmov    $0x3,%edi\nmov    %rax,(%r12,%r15,1)\ncallq  92 <func0+0x92>\nmov    %rax,0x0(%r13,%r15,1)\nadd    $0x8,%r15\ncmp    %r15,%r14\njne    70 <func0+0x70>\nmov    (%r12),%r11\nmov    0x0(%r13),%r15\nmovq   $0x0,(%r11)\nmovl   $0x0,0x8(%r11)\n00\nmovq   $0x0,(%r15)\nmovl   $0x0,0x8(%r15)\n00\ntest   %ebx,%ebx\njle    12a <func0+0x12a>\nlea    -0x1(%rbx),%esi\nmov    %r11,%r8\nmov    $0x1,%ecx\nmov    $0xaaaaaaab,%edi\nadd    $0x1,%rsi\njmp    e7 <func0+0xe7>\nadd    $0x1,%rcx\nmov    %rdx,%r8\nlea    -0x1(%rcx),%edx\nmov    (%r8),%r9d\nimul   %ecx,%edx\nlea    0x1(%rdx),%eax\nmov    %rax,%rdx\nimul   %rdi,%rax\nshr    $0x21,%rax\nlea    (%rax,%rax,2),%eax\nsub    %eax,%edx\nmovslq %edx,%rax\nmov    (%r12,%rcx,8),%rdx\nmov    %eax,-0x4(%rbp,%rcx,4)\nmov    %r9d,(%rdx)\nmov    0x4(%r8),%r9d\nmov    %r9d,0x4(%rdx)\nmov    0x8(%r8),%r8d\nmov    %r8d,0x8(%rdx)\naddl   $0x1,(%rdx,%rax,4)\ncmp    %rcx,%rsi\njne    e0 <func0+0xe0>\nlea    -0x1(%rbx),%r14d\nmovl   $0x2,0xc(%rsp)\n00\nadd    $0x1,%r14\ntest   %ebx,%ebx\njle    20a <func0+0x20a>\nmov    %r11,%r10\nmov    %r15,%rax\nmov    $0x1,%r8d\nxchg   %ax,%ax\nmov    (%rax),%edx\nmov    0x0(%r13,%r8,8),%rcx\nmov    -0x4(%rbp,%r8,4),%esi\nmov    %edx,(%rcx)\nmov    0x4(%rax),%edx\nmov    %edx,0x4(%rcx)\nmov    0x8(%rax),%eax\nxor    %edx,%edx\nmov    %eax,0x8(%rcx)\nlea    (%rsi,%rdx,1),%eax\nmovslq %eax,%rdi\nmov    %eax,%r9d\nimul   $0x55555556,%rdi,%rdi\nsar    $0x1f,%r9d\nshr    $0x20,%rdi\nsub    %r9d,%edi\nlea    (%rdi,%rdi,2),%edi\nsub    %edi,%eax\nmov    (%r10,%rdx,4),%edi\nadd    $0x1,%rdx\ncltq\nadd    %edi,(%rcx,%rax,4)\ncmp    $0x3,%rdx\njne    16c <func0+0x16c>\ncmp    %r8,%r14\nje     1b8 <func0+0x1b8>\nmov    (%r12,%r8,8),%r10\nmov    %rcx,%rax\nadd    $0x1,%r8\njmp    150 <func0+0x150>\nnopl   0x0(%rax)\nmov    %r11,%rcx\nmov    %r15,%rax\nxor    %edx,%edx\njmp    1d1 <func0+0x1d1>\nnopw   0x0(%rax,%rax,1)\nmov    0x0(%r13,%rdx,8),%rax\nmov    (%r12,%rdx,8),%rcx\nmov    0x8(%rax),%esi\nmov    (%rax),%rdi\nadd    $0x1,%rdx\nmovq   $0x0,(%rax)\nmovl   $0x0,0x8(%rax)\nmov    %rdi,(%rcx)\nmov    %esi,0x8(%rcx)\ncmp    %edx,%ebx\njge    1c8 <func0+0x1c8>\ncmpl   $0x1,0xc(%rsp)\nje     230 <func0+0x230>\nmovl   $0x1,0xc(%rsp)\n00\ntest   %ebx,%ebx\njg     142 <func0+0x142>\njne    1f3 <func0+0x1f3>\nmov    0x8(%r15),%eax\nmov    (%r15),%rdx\nmovl   $0x0,0x8(%r15)\n00\nmovq   $0x0,(%r15)\nmov    %rdx,(%r11)\nmov    %eax,0x8(%r11)\njmp    1f3 <func0+0x1f3>\nnopl   0x0(%rax,%rax,1)\nmov    0x10(%rsp),%rax\nmov    -0x8(%r12,%rax,1),%rax\nmov    (%rax),%r14d\ntest   %ebx,%ebx\njs     27c <func0+0x27c>\nmov    0x18(%rsp),%rax\nxor    %r15d,%r15d\nmov    %r11,%rdi\nlea    0x8(,%rax,8),%rbx\n00\njmp    264 <func0+0x264>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    (%r12,%r15,1),%rdi\ncallq  269 <func0+0x269>\nmov    0x0(%r13,%r15,1),%rdi\nadd    $0x8,%r15\ncallq  277 <func0+0x277>\ncmp    %r15,%rbx\njne    260 <func0+0x260>\nmov    %r12,%rdi\ncallq  284 <func0+0x284>\nmov    %r13,%rdi\ncallq  28c <func0+0x28c>\nmov    %rbp,%rdi\ncallq  294 <func0+0x294>\nadd    $0x28,%rsp\nmov    %r14d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    (%r12),%r11\nmov    (%rax),%r15\nmovq   $0x0,(%r11)\nmovl   $0x0,0x8(%r11)\n00\nmovq   $0x0,(%r15)\nmovl   $0x0,0x8(%r15)\n00\njmpq   12a <func0+0x12a>"
    },
    {
        "task_id": 147,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmovslq %edi,%rbp\npush   %rbx\nlea    0x1(%rbp),%ebx\nlea    0x0(,%rbp,4),%rdi\n00\nmov    %rbp,%r15\nmovslq %ebx,%rbx\nshl    $0x3,%rbx\nsub    $0x18,%rsp\nmov    %rbp,0x8(%rsp)\ncallq  34 <func0+0x34>\nmov    %rbx,%rdi\nmov    %rbx,(%rsp)\nmov    %rax,%r14\ncallq  43 <func0+0x43>\nmov    %rbx,%rdi\nlea    0x8(,%rbp,8),%rbx\n00\nxor    %ebp,%ebp\nmov    %rax,%r12\ncallq  58 <func0+0x58>\nmov    %rax,%r13\ntest   %r15d,%r15d\njs     2d6 <func0+0x2d6>\nnopl   0x0(%rax)\nmov    $0x4,%esi\nmov    $0x3,%edi\ncallq  77 <func0+0x77>\nmov    $0x4,%esi\nmov    $0x3,%edi\nmov    %rax,(%r12,%rbp,1)\ncallq  8a <func0+0x8a>\nmov    %rax,0x0(%r13,%rbp,1)\nadd    $0x8,%rbp\ncmp    %rbx,%rbp\njne    68 <func0+0x68>\nmov    (%r12),%rax\nmov    0x0(%r13),%rbx\nmovq   $0x0,(%rax)\nmovl   $0x0,0x8(%rax)\nmovq   $0x0,(%rbx)\nmovl   $0x0,0x8(%rbx)\ntest   %r15d,%r15d\njle    12b <func0+0x12b>\nlea    -0x1(%r15),%edi\nxor    %ecx,%ecx\nxor    %r9d,%r9d\nmov    $0xaaaaaaab,%esi\njmp    e2 <func0+0xe2>\nnopl   0x0(%rax)\nmov    (%r12,%rax,8),%rdx\nmov    %rax,%rcx\nmov    (%rdx),%r9d\nlea    0x1(%rcx),%edx\nmov    (%r12,%rcx,8),%r8\nimul   %ecx,%edx\nlea    0x1(%rdx),%eax\nmov    %rax,%rdx\nimul   %rsi,%rax\nshr    $0x21,%rax\nlea    (%rax,%rax,2),%eax\nsub    %eax,%edx\nmovslq %edx,%rax\nmov    0x8(%r12,%rcx,8),%rdx\nmov    %eax,(%r14,%rcx,4)\nmov    %r9d,(%rdx)\nmov    0x4(%r8),%r9d\nmov    %r9d,0x4(%rdx)\nmov    0x8(%r8),%r8d\nmov    %r8d,0x8(%rdx)\naddl   $0x1,(%rdx,%rax,4)\nlea    0x1(%rcx),%rax\ncmp    %rdi,%rcx\njne    d8 <func0+0xd8>\nmov    $0x2,%r8d\nlea    -0x1(%r15),%r11d\nmov    %rbx,%rdx\nxor    %esi,%esi\ntest   %r15d,%r15d\njle    23e <func0+0x23e>\nnopl   0x0(%rax,%rax,1)\nmov    %rdx,%rax\nmov    0x8(%r13,%rsi,8),%rdx\nmov    (%rax),%ecx\nmov    %ecx,(%rdx)\nmov    0x4(%rax),%ecx\nmov    %ecx,0x4(%rdx)\nmovslq (%r14,%rsi,4),%rcx\nmov    0x8(%rax),%eax\nmov    %eax,0x8(%rdx)\nmov    %rcx,%rax\nimul   $0x55555556,%rcx,%rcx\nmov    %eax,%edi\nsar    $0x1f,%edi\nshr    $0x20,%rcx\nsub    %edi,%ecx\nmov    %eax,%edi\nlea    (%rcx,%rcx,2),%ecx\nsub    %ecx,%edi\nmovslq %edi,%rcx\nmov    (%r12,%rsi,8),%rdi\nmov    (%rdi),%r9d\nadd    %r9d,(%rdx,%rcx,4)\nlea    0x1(%rax),%ecx\nadd    $0x2,%eax\nmovslq %ecx,%r9\nmov    %ecx,%r10d\nimul   $0x55555556,%r9,%r9\nsar    $0x1f,%r10d\nshr    $0x20,%r9\nsub    %r10d,%r9d\nlea    (%r9,%r9,2),%r9d\nsub    %r9d,%ecx\nmov    0x4(%rdi),%r9d\nmovslq %ecx,%rcx\nadd    %r9d,(%rdx,%rcx,4)\nmovslq %eax,%rcx\nmov    %eax,%r9d\nimul   $0x55555556,%rcx,%rcx\nsar    $0x1f,%r9d\nshr    $0x20,%rcx\nsub    %r9d,%ecx\nlea    (%rcx,%rcx,2),%ecx\nsub    %ecx,%eax\nmov    0x8(%rdi),%ecx\ncltq\nadd    %ecx,(%rdx,%rax,4)\nmov    %rsi,%rax\nadd    $0x1,%rsi\ncmp    %r11,%rax\njne    148 <func0+0x148>\nxor    %eax,%eax\nnopl   (%rax)\nmov    0x0(%r13,%rax,8),%rdx\nmov    (%r12,%rax,8),%rcx\nadd    $0x1,%rax\nmov    0x8(%rdx),%esi\nmov    (%rdx),%rdi\nmovl   $0x0,0x8(%rdx)\nmovq   $0x0,(%rdx)\nmov    %rdi,(%rcx)\nmov    %esi,0x8(%rcx)\ncmp    %eax,%r15d\njge    1f8 <func0+0x1f8>\ncmp    $0x1,%r8d\nje     268 <func0+0x268>\nmov    $0x1,%r8d\nmov    %rbx,%rdx\nxor    %esi,%esi\ntest   %r15d,%r15d\njg     148 <func0+0x148>\njne    224 <func0+0x224>\nmov    0x0(%r13),%rax\nmov    (%r12),%rdx\nmov    0x8(%rax),%ecx\nmov    (%rax),%rsi\nmovl   $0x0,0x8(%rax)\nmovq   $0x0,(%rax)\nmov    %rsi,(%rdx)\nmov    %ecx,0x8(%rdx)\njmp    224 <func0+0x224>\nnopl   0x0(%rax)\nmov    (%rsp),%rax\nxor    %ebp,%ebp\nmov    -0x8(%r12,%rax,1),%rax\nmov    (%rax),%eax\nmov    %eax,(%rsp)\nmov    0x8(%rsp),%rax\nlea    0x8(,%rax,8),%rbx\n00\ntest   %r15d,%r15d\njs     2ac <func0+0x2ac>\nnopw   0x0(%rax,%rax,1)\nmov    (%r12,%rbp,1),%rdi\ncallq  299 <func0+0x299>\nmov    0x0(%r13,%rbp,1),%rdi\nadd    $0x8,%rbp\ncallq  2a7 <func0+0x2a7>\ncmp    %rbx,%rbp\njne    290 <func0+0x290>\nmov    %r12,%rdi\ncallq  2b4 <func0+0x2b4>\nmov    %r13,%rdi\ncallq  2bc <func0+0x2bc>\nmov    %r14,%rdi\ncallq  2c4 <func0+0x2c4>\nmov    (%rsp),%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    (%r12),%rax\nmov    0x0(%r13),%rbx\nmovq   $0x0,(%rax)\nmovl   $0x0,0x8(%rax)\nmovq   $0x0,(%rbx)\nmovl   $0x0,0x8(%rbx)\njmpq   12b <func0+0x12b>"
    },
    {
        "task_id": 148,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x90,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\nmov    %rdx,-0x88(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %rax,-0x50(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x48(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0xffffffff,-0x68(%rbp)\nmovl   $0xffffffff,-0x64(%rbp)\nmovl   $0x0,-0x60(%rbp)\njmp    e6 <func0+0xe6>\nmov    -0x60(%rbp),%eax\ncltq\nmov    -0x50(%rbp,%rax,8),%rax\nmov    -0x78(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  b5 <func0+0xb5>\ntest   %eax,%eax\njne    bf <func0+0xbf>\nmov    -0x60(%rbp),%eax\nmov    %eax,-0x68(%rbp)\nmov    -0x60(%rbp),%eax\ncltq\nmov    -0x50(%rbp,%rax,8),%rax\nmov    -0x80(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  d8 <func0+0xd8>\ntest   %eax,%eax\njne    e2 <func0+0xe2>\nmov    -0x60(%rbp),%eax\nmov    %eax,-0x64(%rbp)\naddl   $0x1,-0x60(%rbp)\ncmpl   $0x7,-0x60(%rbp)\njle    9c <func0+0x9c>\ncmpl   $0xffffffff,-0x68(%rbp)\nje     100 <func0+0x100>\ncmpl   $0xffffffff,-0x64(%rbp)\nje     100 <func0+0x100>\nmov    -0x68(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njne    117 <func0+0x117>\nmov    -0x88(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    $0x0,%eax\njmpq   1be <func0+0x1be>\nmov    -0x68(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    131 <func0+0x131>\nmov    -0x68(%rbp),%eax\nmov    %eax,-0x5c(%rbp)\nmov    -0x64(%rbp),%eax\nmov    %eax,-0x68(%rbp)\nmov    -0x5c(%rbp),%eax\nmov    %eax,-0x64(%rbp)\nmov    -0x64(%rbp),%eax\nsub    -0x68(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x88(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x88(%rbp),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njg     164 <func0+0x164>\nmov    -0x88(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    $0x0,%eax\njmp    1be <func0+0x1be>\nmov    -0x88(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncallq  17b <func0+0x17b>\nmov    %rax,-0x58(%rbp)\nmov    -0x68(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x60(%rbp)\njmp    1b2 <func0+0x1b2>\nmov    -0x60(%rbp),%eax\nsub    -0x68(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x60(%rbp),%eax\ncltq\nmov    -0x50(%rbp,%rax,8),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x60(%rbp)\nmov    -0x60(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njl     18a <func0+0x18a>\nmov    -0x58(%rbp),%rax\nmov    -0x8(%rbp),%rcx\nxor    %fs:0x28,%rcx\n00 00\nje     1d2 <func0+0x1d2>\ncallq  1d2 <func0+0x1d2>\nleaveq\nretq"
    },
    {
        "task_id": 148,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,%r15\nmov    %rsi,(%rsp)\nmov    %rdx,0x8(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %rax,0x10(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x18(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x30(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x48(%rsp)\nmov    $0x0,%ebx\nmov    $0xffffffff,%ebp\nmov    $0xffffffff,%r13d\nmov    0x10(%rsp,%rbx,8),%r12\nmov    %r15,%rsi\nmov    %r12,%rdi\ncallq  ae <func0+0xae>\ntest   %eax,%eax\ncmove  %ebx,%r13d\nmov    (%rsp),%rsi\nmov    %r12,%rdi\ncallq  c0 <func0+0xc0>\ntest   %eax,%eax\ncmove  %ebx,%ebp\nadd    $0x1,%rbx\ncmp    $0x8,%rbx\njne    9e <func0+0x9e>\ncmp    $0xffffffff,%r13d\nsete   %dl\ncmp    $0xffffffff,%ebp\nsete   %al\nor     %al,%dl\njne    164 <func0+0x164>\ncmp    %ebp,%r13d\nje     164 <func0+0x164>\njle    f3 <func0+0xf3>\nmov    %r13d,%eax\nmov    %ebp,%r13d\nmov    %eax,%ebp\nmov    %ebp,%eax\nsub    %r13d,%eax\nsub    $0x1,%eax\nmov    0x8(%rsp),%rcx\nmov    %eax,(%rcx)\ntest   %eax,%eax\njle    176 <func0+0x176>\ncltq\nlea    0x0(,%rax,8),%rdi\n00\ncallq  115 <func0+0x115>\nlea    0x1(%r13),%edx\ncmp    %edx,%ebp\njle    145 <func0+0x145>\nsub    $0x2,%ebp\nsub    %r13d,%ebp\nmovslq %r13d,%r13\nlea    0x10(%rsp,%r13,8),%rsi\nmov    $0x0,%edx\nmov    0x8(%rsi,%rdx,8),%rcx\nmov    %rcx,(%rax,%rdx,8)\nmov    %rdx,%rcx\nadd    $0x1,%rdx\ncmp    %rbp,%rcx\njne    130 <func0+0x130>\nmov    0x58(%rsp),%rcx\nxor    %fs:0x28,%rcx\n00 00\njne    183 <func0+0x183>\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    0x8(%rsp),%rax\nmovl   $0x0,(%rax)\nmov    $0x0,%eax\njmp    145 <func0+0x145>\nmovl   $0x0,(%rcx)\nmov    $0x0,%eax\njmp    145 <func0+0x145>\ncallq  188 <.LC7+0x159>"
    },
    {
        "task_id": 148,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    $0xffffffff,%r15d\npush   %r14\nmov    %rdi,%r14\nlea    0x0(%rip),%rdi\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\nmov    $0xffffffff,%ebp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x68,%rsp\nmov    %rdx,0x8(%rsp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %rdi,0x10(%rsp)\nmov    %rax,0x18(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x30(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x48(%rsp)\njmp    a5 <func0+0xa5>\nnopl   0x0(%rax)\nmov    0x10(%rsp,%rbx,8),%rdi\nmov    %r14,%rsi\nmov    %rdi,(%rsp)\ncallq  b1 <func0+0xb1>\nmov    (%rsp),%rdi\nmov    %r13,%rsi\ntest   %eax,%eax\ncmove  %ebx,%ebp\ncallq  c2 <func0+0xc2>\ntest   %eax,%eax\ncmove  %ebx,%r15d\nadd    $0x1,%rbx\ncmp    $0x8,%rbx\njne    a0 <func0+0xa0>\ncmp    $0xffffffff,%ebp\nsete   %cl\ncmp    $0xffffffff,%r15d\nsete   %al\nor     %al,%cl\njne    178 <func0+0x178>\ncmp    %r15d,%ebp\nje     178 <func0+0x178>\njg     168 <func0+0x168>\nmov    %r15d,%eax\nmov    0x8(%rsp),%rdx\nsub    %ebp,%eax\nsub    $0x1,%eax\nmov    %eax,(%rdx)\ntest   %eax,%eax\njle    178 <func0+0x178>\ncltq\nlea    0x0(,%rax,8),%rdi\n00\ncallq  114 <func0+0x114>\nlea    0x1(%rbp),%ecx\ncmp    %ecx,%r15d\njle    142 <func0+0x142>\nmovslq %ebp,%rbp\nmovslq %ecx,%rcx\nlea    0x10(%rsp),%rdi\nneg    %rbp\nlea    (%rax,%rbp,8),%r8\nxchg   %ax,%ax\nmov    (%rdi,%rcx,8),%rsi\nmov    %rsi,-0x8(%r8,%rcx,8)\nadd    $0x1,%rcx\ncmp    %ecx,%r15d\njg     130 <func0+0x130>\nmov    0x58(%rsp),%rdx\nxor    %fs:0x28,%rdx\n00 00\njne    187 <func0+0x187>\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\nmov    %ebp,%eax\nmov    %r15d,%ebp\nmov    %eax,%r15d\njmp    f2 <func0+0xf2>\nnopw   0x0(%rax,%rax,1)\nmov    0x8(%rsp),%rax\nmovl   $0x0,(%rax)\nxor    %eax,%eax\njmp    142 <func0+0x142>\ncallq  18c <.LC7+0x15d>"
    },
    {
        "task_id": 148,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nlea    0x0(%rip),%rcx\nmov    $0x1,%r15d\npush   %r14\nmovq   %rcx,%xmm0\nlea    0x0(%rip),%rcx\nmov    %rdx,%r14\npush   %r13\nlea    0x0(%rip),%rdx\nmov    %rsi,%r13\nmov    %rdi,%rsi\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x68,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmovq   %rax,%xmm1\nlea    0x0(%rip),%rax\npunpcklqdq %xmm1,%xmm0\nmovq   %rax,%xmm2\nlea    0x0(%rip),%rax\nmovq   %xmm0,%rbp\nmovaps %xmm0,0x10(%rsp)\nmovq   %rcx,%xmm0\nlea    0x0(%rip),%rcx\npunpcklqdq %xmm2,%xmm0\nmovq   %rax,%xmm3\nlea    0x0(%rip),%rax\nmov    %rbp,%rdi\nmovaps %xmm0,0x20(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm4\npunpcklqdq %xmm3,%xmm0\nmovaps %xmm0,0x30(%rsp)\nmovq   %rdx,%xmm0\npunpcklqdq %xmm4,%xmm0\nmovaps %xmm0,0x40(%rsp)\ncallq  c7 <func0+0xc7>\nmov    %rbp,%rdi\nmov    %r13,%rsi\ntest   %eax,%eax\nsetne  %bl\nxor    %ebp,%ebp\ncallq  d9 <func0+0xd9>\nmov    0x18(%rsp),%rdi\nneg    %ebx\nmov    %r12,%rsi\ntest   %eax,%eax\nsetne  %bpl\nmov    %rdi,0x8(%rsp)\ncallq  f3 <func0+0xf3>\nmov    0x8(%rsp),%rdi\nneg    %ebp\nmov    %r13,%rsi\ntest   %eax,%eax\ncmove  %r15d,%ebx\ncallq  108 <func0+0x108>\nmov    0x20(%rsp),%rdi\nmov    %r12,%rsi\ntest   %eax,%eax\ncmove  %r15d,%ebp\nmov    %rdi,0x8(%rsp)\nmov    $0x2,%r15d\ncallq  126 <func0+0x126>\nmov    0x8(%rsp),%rdi\nmov    %r13,%rsi\ntest   %eax,%eax\ncmove  %r15d,%ebx\ncallq  139 <func0+0x139>\nmov    0x28(%rsp),%rdi\nmov    %r12,%rsi\ntest   %eax,%eax\ncmove  %r15d,%ebp\nmov    %rdi,0x8(%rsp)\nmov    $0x3,%r15d\ncallq  157 <func0+0x157>\nmov    0x8(%rsp),%rdi\nmov    %r13,%rsi\ntest   %eax,%eax\ncmove  %r15d,%ebx\ncallq  16a <func0+0x16a>\nmov    0x30(%rsp),%rdi\nmov    %r12,%rsi\ntest   %eax,%eax\ncmove  %r15d,%ebp\nmov    %rdi,0x8(%rsp)\nmov    $0x4,%r15d\ncallq  188 <func0+0x188>\nmov    0x8(%rsp),%rdi\nmov    %r13,%rsi\ntest   %eax,%eax\ncmove  %r15d,%ebx\ncallq  19b <func0+0x19b>\nmov    0x38(%rsp),%rdi\nmov    %r12,%rsi\ntest   %eax,%eax\ncmove  %r15d,%ebp\nmov    %rdi,0x8(%rsp)\nmov    $0x5,%r15d\ncallq  1b9 <func0+0x1b9>\nmov    0x8(%rsp),%rdi\nmov    %r13,%rsi\ntest   %eax,%eax\ncmove  %r15d,%ebx\ncallq  1cc <func0+0x1cc>\nmov    0x40(%rsp),%rdi\nmov    %r12,%rsi\ntest   %eax,%eax\ncmove  %r15d,%ebp\nmov    %rdi,0x8(%rsp)\nmov    $0x6,%r15d\ncallq  1ea <func0+0x1ea>\nmov    0x8(%rsp),%rdi\nmov    %r13,%rsi\ntest   %eax,%eax\ncmove  %r15d,%ebx\ncallq  1fd <func0+0x1fd>\nmov    %r12,%rsi\ntest   %eax,%eax\ncmove  %r15d,%ebp\nmov    0x48(%rsp),%r15\nmov    %r15,%rdi\ncallq  213 <func0+0x213>\nmov    %r13,%rsi\nmov    %r15,%rdi\ntest   %eax,%eax\nje     2c0 <func0+0x2c0>\ncallq  226 <func0+0x226>\ntest   %eax,%eax\njne    310 <func0+0x310>\ncmp    $0x7,%ebx\nje     2ff <func0+0x2ff>\ncmp    $0xffffffff,%ebx\nje     2ff <func0+0x2ff>\nmov    $0x7,%r12d\nmov    %r12d,%eax\nsub    %ebx,%eax\nsub    $0x1,%eax\nmov    %eax,(%r14)\ntest   %eax,%eax\njle    2ff <func0+0x2ff>\ncltq\nlea    0x0(,%rax,8),%rdi\n00\ncallq  268 <func0+0x268>\nmov    %rax,%r8\nlea    0x1(%rbx),%eax\ncmp    %eax,%r12d\njle    294 <func0+0x294>\nsub    $0x2,%r12d\ncltq\nmov    %r8,%rdi\nsub    %ebx,%r12d\nlea    0x10(%rsp,%rax,8),%rsi\nlea    0x8(,%r12,8),%rdx\n00\ncallq  291 <func0+0x291>\nmov    %rax,%r8\nmov    0x58(%rsp),%rax\nxor    %fs:0x28,%rax\n00 00\njne    315 <func0+0x315>\nadd    $0x68,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\ncallq  2c5 <func0+0x2c5>\nmov    $0x7,%r12d\ntest   %eax,%eax\nje     2ff <func0+0x2ff>\ncmp    $0xffffffff,%ebp\nsete   %dl\ncmp    %r12d,%ebp\nsete   %al\nor     %al,%dl\njne    2ff <func0+0x2ff>\ncmp    $0xffffffff,%r12d\nje     2ff <func0+0x2ff>\ncmp    %r12d,%ebp\njge    31a <func0+0x31a>\nmov    %ebp,%ebx\nmov    %r12d,%eax\nsub    %ebx,%eax\nsub    $0x1,%eax\nmov    %eax,(%r14)\ntest   %eax,%eax\njg     259 <func0+0x259>\nmovl   $0x0,(%r14)\nxor    %r8d,%r8d\njmp    294 <func0+0x294>\nnopl   0x0(%rax,%rax,1)\nmov    %ebx,%r12d\njmp    2cf <func0+0x2cf>\ncallq  31a <func0+0x31a>\nmov    %r12d,%ebx\nmov    %ebp,%r12d\njmpq   246 <func0+0x246>"
    },
    {
        "task_id": 149,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,-0x3c(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x48(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x28(%rbp)\njmp    96 <func0+0x96>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncallq  49 <func0+0x49>\nand    $0x1,%eax\ntest   %rax,%rax\njne    92 <func0+0x92>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    (%rcx),%rax\nmov    %rax,(%rdx)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x48(%rbp),%rax\nmov    %edx,(%rax)\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     2a <func0+0x2a>\nmovl   $0x0,-0x28(%rbp)\njmpq   1e3 <func0+0x1e3>\nmovl   $0x0,-0x24(%rbp)\njmpq   1ca <func0+0x1ca>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncallq  d5 <func0+0xd5>\nmov    %rax,-0x18(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncallq  fc <func0+0xfc>\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nja     159 <func0+0x159>\nmov    -0x18(%rbp),%rax\ncmp    -0x10(%rbp),%rax\njne    1c6 <func0+0x1c6>\nmov    -0x24(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rcx\n00\nmov    -0x38(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  155 <func0+0x155>\ntest   %eax,%eax\njle    1c6 <func0+0x1c6>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x24(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x38(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\nmov    -0x24(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x24(%rbp)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\nsub    -0x28(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x24(%rbp)\njl     b6 <func0+0xb6>\naddl   $0x1,-0x28(%rbp)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x28(%rbp)\njl     aa <func0+0xaa>\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncallq  209 <func0+0x209>\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    249 <func0+0x249>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x28(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\n00\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x28(%rbp)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x28(%rbp)\njl     216 <func0+0x216>\nmov    -0x20(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 149,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%rbp\nmov    %rdx,%r15\nmovl   $0x0,(%rdx)\ntest   %esi,%esi\njle    109 <func0+0x109>\nmov    %rdi,%rdx\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%r9\nmov    $0xffffffffffffffff,%r8\nmov    $0x0,%eax\njmp    48 <func0+0x48>\nadd    $0x8,%rdx\ncmp    %r9,%rdx\nje     66 <func0+0x66>\nmov    (%rdx),%rsi\nmov    %r8,%rcx\nmov    %rsi,%rdi\nrepnz scas %es:(%rdi),%al\ntest   $0x1,%cl\njne    3f <func0+0x3f>\nmovslq (%r15),%rcx\nmov    %rsi,0x0(%rbp,%rcx,8)\naddl   $0x1,(%r15)\njmp    3f <func0+0x3f>\nmov    (%r15),%eax\ncmp    $0x1,%eax\njle    10e <func0+0x10e>\nmovl   $0x0,0xc(%rsp)\n00\nmov    $0xffffffffffffffff,%r14\njmp    f6 <func0+0xf6>\nmov    %r13,0x0(%rbp,%rbx,8)\nmov    %r12,0x8(%rbp,%rbx,8)\nadd    $0x1,%rbx\nmov    0xc(%rsp),%eax\nnot    %eax\nadd    (%r15),%eax\ncmp    %ebx,%eax\njle    e3 <func0+0xe3>\nmov    0x0(%rbp,%rbx,8),%r12\nmov    %r14,%rcx\nmov    %r12,%rdi\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%rdx\nmov    0x8(%rbp,%rbx,8),%r13\nmov    %r14,%rcx\nmov    %r13,%rdi\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nsub    $0x1,%rcx\ncmp    %rcx,%rdx\nja     83 <func0+0x83>\njne    8d <func0+0x8d>\nmov    %r13,%rsi\nmov    %r12,%rdi\ncallq  dd <func0+0xdd>\ntest   %eax,%eax\njg     83 <func0+0x83>\njmp    8d <func0+0x8d>\naddl   $0x1,0xc(%rsp)\nmov    0xc(%rsp),%esi\nmov    (%r15),%eax\nlea    -0x1(%rax),%edx\ncmp    %esi,%edx\njle    10e <func0+0x10e>\nmov    (%r15),%eax\nsub    0xc(%rsp),%eax\nmov    $0x0,%ebx\ncmp    $0x1,%eax\njg     9e <func0+0x9e>\njmp    e3 <func0+0xe3>\nmov    $0x0,%eax\ncltq\nlea    0x0(,%rax,8),%rdi\n00\ncallq  11d <func0+0x11d>\nmov    (%r15),%edx\ntest   %edx,%edx\njle    141 <func0+0x141>\nlea    -0x1(%rdx),%esi\nmov    $0x0,%edx\nmov    0x0(%rbp,%rdx,8),%rcx\nmov    %rcx,(%rax,%rdx,8)\nmov    %rdx,%rcx\nadd    $0x1,%rdx\ncmp    %rcx,%rsi\njne    12c <func0+0x12c>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 149,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rdi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovl   $0x0,(%rdx)\nmov    %rdx,0x18(%rsp)\ntest   %esi,%esi\njle    154 <func0+0x154>\nlea    0x8(%rdi),%rdx\nlea    -0x1(%rsi),%eax\nmov    %rdi,%r12\nxor    %ebx,%ebx\nmov    %rdx,0x10(%rsp)\nlea    (%rdx,%rax,8),%rbp\nnopl   (%rax)\nmov    (%r12),%r14\nmov    %r14,%rdi\ncallq  4c <func0+0x4c>\nmov    %rax,%r8\nmovslq %ebx,%rax\nlea    0x0(,%rax,8),%rsi\n00\nand    $0x1,%r8d\nmov    %rsi,0x8(%rsp)\njne    7d <func0+0x7d>\nmov    %r14,0x0(%r13,%rax,8)\nmov    0x18(%rsp),%rax\nadd    $0x1,%ebx\nadd    $0x8,%rsi\nmov    %rsi,0x8(%rsp)\nmov    %ebx,(%rax)\nadd    $0x8,%r12\ncmp    %r12,%rbp\njne    40 <func0+0x40>\nlea    -0x1(%rbx),%ebp\ntest   %ebp,%ebp\njle    ee <func0+0xee>\nnopl   (%rax)\nmov    0x10(%rsp),%rcx\nlea    -0x1(%rbp),%eax\nmov    %r13,%r15\nmov    %eax,0x4(%rsp)\nlea    (%rcx,%rax,8),%r12\njmp    b7 <func0+0xb7>\nnopl   (%rax)\nje     138 <func0+0x138>\nadd    $0x8,%r15\ncmp    %r15,%r12\nje     e6 <func0+0xe6>\nmov    (%r15),%r14\nmov    %r14,%rdi\ncallq  c2 <func0+0xc2>\nmov    0x8(%r15),%rbp\nmov    %rax,%rbx\nmov    %rbp,%rdi\ncallq  d1 <func0+0xd1>\ncmp    %rax,%rbx\njbe    a8 <func0+0xa8>\nmov    %rbp,(%r15)\nmov    %r14,0x8(%r15)\nadd    $0x8,%r15\ncmp    %r15,%r12\njne    b7 <func0+0xb7>\nmov    0x4(%rsp),%ebp\ntest   %ebp,%ebp\njne    90 <func0+0x90>\nmov    0x8(%rsp),%rdi\ncallq  f8 <func0+0xf8>\nmov    0x18(%rsp),%rdx\nmov    (%rdx),%ecx\nxor    %edx,%edx\nlea    -0x1(%rcx),%esi\ntest   %ecx,%ecx\njle    125 <func0+0x125>\nnopl   0x0(%rax,%rax,1)\n00\nmov    0x0(%r13,%rdx,8),%rcx\nmov    %rcx,(%rax,%rdx,8)\nmov    %rdx,%rcx\nadd    $0x1,%rdx\ncmp    %rcx,%rsi\njne    110 <func0+0x110>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\nmov    %rbp,%rsi\nmov    %r14,%rdi\ncallq  143 <func0+0x143>\ntest   %eax,%eax\njle    ae <func0+0xae>\nmov    %rbp,(%r15)\nmov    %r14,0x8(%r15)\njmp    dd <func0+0xdd>\nmovq   $0x0,0x8(%rsp)\n00 00\njmp    ee <func0+0xee>"
    },
    {
        "task_id": 149,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovl   $0x0,(%rdx)\nmov    %rdi,(%rsp)\nmov    %rdx,0x18(%rsp)\ntest   %esi,%esi\njle    154 <func0+0x154>\nlea    0x8(%rdi),%rdx\nlea    -0x1(%rsi),%eax\nmov    %rdi,%r12\nxor    %ebx,%ebx\nmov    %rdx,0x10(%rsp)\nlea    (%rdx,%rax,8),%rbp\nxchg   %ax,%ax\nmov    (%r12),%r13\nmov    %r13,%rdi\ncallq  4c <func0+0x4c>\nmov    %rax,%r8\nmovslq %ebx,%rax\nlea    0x0(,%rax,8),%rcx\n00\nand    $0x1,%r8d\nmov    %rcx,0x8(%rsp)\njne    80 <func0+0x80>\nmov    (%rsp),%rsi\nadd    $0x1,%ebx\nadd    $0x8,%rcx\nmov    %rcx,0x8(%rsp)\nmov    %r13,(%rsi,%rax,8)\nmov    0x18(%rsp),%rax\nmov    %ebx,(%rax)\nadd    $0x8,%r12\ncmp    %r12,%rbp\njne    40 <func0+0x40>\nlea    -0x1(%rbx),%ebp\ntest   %ebp,%ebp\njle    f6 <func0+0xf6>\nmov    0x10(%rsp),%rdx\nlea    -0x1(%rbp),%eax\nmov    (%rsp),%r15\nmov    %rax,%rbp\nlea    (%rdx,%rax,8),%r12\njmp    b7 <func0+0xb7>\nnopl   (%rax)\nje     140 <func0+0x140>\nadd    $0x8,%r15\ncmp    %r12,%r15\nje     f2 <func0+0xf2>\nmov    (%r15),%r13\nmov    %r13,%rdi\ncallq  c2 <func0+0xc2>\nmov    0x8(%r15),%r14\nmov    %rax,%rbx\nmov    %r14,%rdi\ncallq  d1 <func0+0xd1>\ncmp    %rax,%rbx\njbe    a8 <func0+0xa8>\nmovq   %r14,%xmm0\nmovq   %r13,%xmm1\nadd    $0x8,%r15\npunpcklqdq %xmm1,%xmm0\nmovups %xmm0,-0x8(%r15)\ncmp    %r12,%r15\njne    b7 <func0+0xb7>\ntest   %ebp,%ebp\njne    90 <func0+0x90>\nmov    0x8(%rsp),%rdi\ncallq  100 <func0+0x100>\nmov    %rax,%r8\nmov    0x18(%rsp),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njle    128 <func0+0x128>\nsub    $0x1,%eax\nmov    (%rsp),%rsi\nmov    %r8,%rdi\nlea    0x8(,%rax,8),%rdx\n00\ncallq  125 <func0+0x125>\nmov    %rax,%r8\nadd    $0x28,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopw   0x0(%rax,%rax,1)\nmov    %r14,%rsi\nmov    %r13,%rdi\ncallq  14b <func0+0x14b>\ntest   %eax,%eax\njg     d6 <func0+0xd6>\njmpq   ae <func0+0xae>\nmovq   $0x0,0x8(%rsp)\n00 00\njmp    f6 <func0+0xf6>"
    },
    {
        "task_id": 150,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %edx,-0x1c(%rbp)\nmovl   $0x1,-0x8(%rbp)\ncmpl   $0x1,-0x14(%rbp)\njg     25 <func0+0x25>\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x2,-0x4(%rbp)\njmp    46 <func0+0x46>\nmov    -0x14(%rbp),%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    42 <func0+0x42>\nmovl   $0x0,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\ncmp    %eax,-0x14(%rbp)\njge    2e <func0+0x2e>\ncmpl   $0x0,-0x8(%rbp)\nje     5c <func0+0x5c>\nmov    -0x18(%rbp),%eax\njmp    5f <func0+0x5f>\nmov    -0x1c(%rbp),%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 150,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edx,%r9d\ncmp    $0x1,%edi\nsetg   %r8b\nmovzbl %r8b,%r8d\ncmp    $0x3,%edi\njle    33 <func0+0x33>\nmov    $0x2,%ecx\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\ncmove  %edx,%r8d\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njle    1c <func0+0x1c>\ntest   %r8d,%r8d\ncmovne %esi,%r9d\nmov    %r9d,%eax\nretq"
    },
    {
        "task_id": 150,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %r8d,%r8d\ncmp    $0x1,%edi\nmov    %edx,%r10d\nsetg   %r8b\ncmp    $0x3,%edi\njle    37 <func0+0x37>\nmov    $0x2,%ecx\nxor    %r9d,%r9d\nxchg   %ax,%ax\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\ncmove  %r9d,%r8d\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %edi,%eax\njle    20 <func0+0x20>\ntest   %r8d,%r8d\ncmovne %esi,%r10d\nmov    %r10d,%eax\nretq"
    },
    {
        "task_id": 150,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nxor    %r8d,%r8d\ncmp    $0x1,%edi\nmov    %edx,%r10d\nsetg   %r8b\ncmp    $0x3,%edi\njle    37 <func0+0x37>\nmov    $0x2,%ecx\nxor    %r9d,%r9d\nxchg   %ax,%ax\nmov    %edi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\ncmove  %r9d,%r8d\nadd    $0x1,%ecx\nmov    %ecx,%eax\nimul   %ecx,%eax\ncmp    %eax,%edi\njge    20 <func0+0x20>\ntest   %r8d,%r8d\ncmovne %esi,%r10d\nmov    %r10d,%eax\nretq"
    },
    {
        "task_id": 151,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((float[]){}, 0) == 0);\n    assert(func0((float[]){5, 4}, 2) == 25);\n    assert(func0((float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovq   $0x0,-0x18(%rbp)\n00\nmovl   $0x0,-0x1c(%rbp)\njmpq   146 <func0+0x146>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm2\nmovsd  %xmm2,-0x38(%rbp)\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncallq  6a <func0+0x6a>\nmovsd  -0x38(%rbp),%xmm2\nsubsd  %xmm0,%xmm2\nmovapd %xmm2,%xmm0\nmovq   0x0(%rip),%xmm1\n00\nandpd  %xmm0,%xmm1\nmovsd  0x0(%rip),%xmm0\n00\ncomisd %xmm1,%xmm0\njbe    142 <func0+0x142>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\npxor   %xmm1,%xmm1\ncomiss %xmm1,%xmm0\njbe    142 <func0+0x142>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncallq  db <func0+0xdb>\ncvttsd2si %xmm0,%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\ncmp    $0x1,%eax\njne    142 <func0+0x142>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncallq  110 <func0+0x110>\ncvttsd2si %xmm0,%ebx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovss  (%rax),%xmm0\ncvtss2sd %xmm0,%xmm0\ncallq  135 <func0+0x135>\ncvttsd2si %xmm0,%eax\nimul   %ebx,%eax\ncltq\nadd    %rax,-0x18(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     28 <func0+0x28>\nmov    -0x18(%rbp),%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 151,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((float[]){}, 0) == 0);\n    assert(func0((float[]){5, 4}, 2) == 25);\n    assert(func0((float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\ntest   %esi,%esi\njle    9b <func0+0x9b>\nmov    %rdi,%rbx\nlea    -0x1(%rsi),%eax\nlea    0x4(%rdi,%rax,4),%rbp\nmov    $0x0,%r12d\njmp    30 <func0+0x30>\nadd    $0x4,%rbx\ncmp    %rbp,%rbx\nje     a1 <func0+0xa1>\nmovss  (%rbx),%xmm3\nmovss  %xmm3,0xc(%rsp)\nmovaps %xmm3,%xmm0\ncallq  42 <func0+0x42>\nmovss  0xc(%rsp),%xmm3\npxor   %xmm1,%xmm1\ncvtss2sd %xmm3,%xmm1\npxor   %xmm2,%xmm2\ncvtss2sd %xmm0,%xmm2\nsubsd  %xmm2,%xmm1\nandpd  0x0(%rip),%xmm1\n00\nmovsd  0x0(%rip),%xmm4\n00\ncomisd %xmm1,%xmm4\njbe    27 <func0+0x27>\ncomiss 0x0(%rip),%xmm3\njbe    27 <func0+0x27>\ncvttss2si %xmm0,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nlea    (%rax,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\njne    27 <func0+0x27>\nimul   %eax,%eax\ncltq\nadd    %rax,%r12\njmp    27 <func0+0x27>\nmov    $0x0,%r12d\nmov    %r12,%rax\nadd    $0x10,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nretq"
    },
    {
        "task_id": 151,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((float[]){}, 0) == 0);\n    assert(func0((float[]){5, 4}, 2) == 25);\n    assert(func0((float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\ntest   %esi,%esi\njle    b0 <func0+0xb0>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %r12d,%r12d\nlea    0x4(%rdi,%rax,4),%rbp\nnopw   0x0(%rax,%rax,1)\nmovss  (%rbx),%xmm2\nmovaps %xmm2,%xmm0\nmovss  %xmm2,0xc(%rsp)\ncallq  3a <func0+0x3a>\nmovss  0xc(%rsp),%xmm2\npxor   %xmm1,%xmm1\npxor   %xmm3,%xmm3\nmovsd  0x0(%rip),%xmm4\n00\ncvtss2sd %xmm0,%xmm3\ncvtss2sd %xmm2,%xmm1\nsubsd  %xmm3,%xmm1\nandpd  0x0(%rip),%xmm1\n00\ncomisd %xmm1,%xmm4\njbe    98 <func0+0x98>\npxor   %xmm5,%xmm5\ncomiss %xmm5,%xmm2\njbe    98 <func0+0x98>\ncvttss2si %xmm0,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nlea    (%rax,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\njne    98 <func0+0x98>\nimul   %eax,%eax\ncltq\nadd    %rax,%r12\nnopl   0x0(%rax)\nadd    $0x4,%rbx\ncmp    %rbx,%rbp\njne    28 <func0+0x28>\nadd    $0x10,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\nretq\nnopl   (%rax)\nadd    $0x10,%rsp\nxor    %r12d,%r12d\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\nretq"
    },
    {
        "task_id": 151,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((float[]){}, 0) == 0);\n    assert(func0((float[]){5, 4}, 2) == 25);\n    assert(func0((float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\ntest   %esi,%esi\njle    b0 <func0+0xb0>\nlea    -0x1(%rsi),%eax\nmov    %rdi,%rbx\nxor    %r12d,%r12d\nlea    0x4(%rdi,%rax,4),%rbp\nnopw   0x0(%rax,%rax,1)\nmovss  (%rbx),%xmm2\nmovaps %xmm2,%xmm0\nmovss  %xmm2,0xc(%rsp)\ncallq  3a <func0+0x3a>\nmovss  0xc(%rsp),%xmm2\npxor   %xmm1,%xmm1\npxor   %xmm3,%xmm3\nmovsd  0x0(%rip),%xmm4\n00\ncvtss2sd %xmm0,%xmm3\ncvtss2sd %xmm2,%xmm1\nsubsd  %xmm3,%xmm1\nandpd  0x0(%rip),%xmm1\n00\ncomisd %xmm1,%xmm4\njbe    98 <func0+0x98>\npxor   %xmm5,%xmm5\ncomiss %xmm5,%xmm2\njbe    98 <func0+0x98>\ncvttss2si %xmm0,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nlea    (%rax,%rcx,1),%edx\nand    $0x1,%edx\nsub    %ecx,%edx\ncmp    $0x1,%edx\njne    98 <func0+0x98>\nimul   %eax,%eax\ncltq\nadd    %rax,%r12\nnopl   0x0(%rax)\nadd    $0x4,%rbx\ncmp    %rbx,%rbp\njne    28 <func0+0x28>\nadd    $0x10,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\nretq\nnopl   (%rax)\nadd    $0x10,%rsp\nxor    %r12d,%r12d\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\nretq"
    },
    {
        "task_id": 152,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((int[]){1,2,3,4,5,1}, (int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (int[]){0,0,0,0,3,3}, 6));\n\n    func0((int[]){0,5,0,0,0,4}, (int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (int[]){4,4,1,0,0,6}, 6));\n\n    func0((int[]){1,2,3,4,5,1}, (int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (int[]){0,0,0,0,3,3}, 6));\n\n    func0((int[]){0,0,0,0,0,0}, (int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (int[]){0,0,0,0,0,0}, 6));\n\n    func0((int[]){1,2,3}, (int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (int[]){2,4,6}, 3));\n\n    func0((int[]){1,2,3,5}, (int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %ecx,-0x2c(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    70 <func0+0x70>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nsub    %eax,%edx\nmov    %edx,%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x28(%rbp),%rdx\nadd    %rdx,%rcx\ncltd\nxor    %edx,%eax\nsub    %edx,%eax\nmov    %eax,(%rcx)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     20 <func0+0x20>\nnop\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 152,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((int[]){1,2,3,4,5,1}, (int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (int[]){0,0,0,0,3,3}, 6));\n\n    func0((int[]){0,5,0,0,0,4}, (int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (int[]){4,4,1,0,0,6}, 6));\n\n    func0((int[]){1,2,3,4,5,1}, (int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (int[]){0,0,0,0,3,3}, 6));\n\n    func0((int[]){0,0,0,0,0,0}, (int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (int[]){0,0,0,0,0,0}, 6));\n\n    func0((int[]){1,2,3}, (int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (int[]){2,4,6}, 3));\n\n    func0((int[]){1,2,3,5}, (int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %ecx,%ecx\njle    34 <func0+0x34>\nlea    -0x1(%rcx),%r9d\nmov    $0x0,%eax\nmov    (%rdi,%rax,4),%ecx\nsub    (%rsi,%rax,4),%ecx\nmov    %ecx,%r8d\nsar    $0x1f,%r8d\nxor    %r8d,%ecx\nmov    %ecx,(%rdx,%rax,4)\nsub    %r8d,(%rdx,%rax,4)\nmov    %rax,%rcx\nadd    $0x1,%rax\ncmp    %r9,%rcx\njne    11 <func0+0x11>\nretq"
    },
    {
        "task_id": 152,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((int[]){1,2,3,4,5,1}, (int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (int[]){0,0,0,0,3,3}, 6));\n\n    func0((int[]){0,5,0,0,0,4}, (int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (int[]){4,4,1,0,0,6}, 6));\n\n    func0((int[]){1,2,3,4,5,1}, (int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (int[]){0,0,0,0,3,3}, 6));\n\n    func0((int[]){0,0,0,0,0,0}, (int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (int[]){0,0,0,0,0,0}, 6));\n\n    func0((int[]){1,2,3}, (int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (int[]){2,4,6}, 3));\n\n    func0((int[]){1,2,3,5}, (int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %ecx,%ecx\njle    33 <func0+0x33>\nlea    -0x1(%rcx),%r9d\nxor    %eax,%eax\nxchg   %ax,%ax\nmov    (%rdi,%rax,4),%ecx\nsub    (%rsi,%rax,4),%ecx\nmov    %ecx,%r8d\nsar    $0x1f,%r8d\nxor    %r8d,%ecx\nmov    %ecx,(%rdx,%rax,4)\nmov    %rax,%rcx\nsub    %r8d,(%rdx,%rax,4)\nadd    $0x1,%rax\ncmp    %r9,%rcx\njne    10 <func0+0x10>\nretq"
    },
    {
        "task_id": 152,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((int[]){1,2,3,4,5,1}, (int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (int[]){0,0,0,0,3,3}, 6));\n\n    func0((int[]){0,5,0,0,0,4}, (int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (int[]){4,4,1,0,0,6}, 6));\n\n    func0((int[]){1,2,3,4,5,1}, (int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (int[]){0,0,0,0,3,3}, 6));\n\n    func0((int[]){0,0,0,0,0,0}, (int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (int[]){0,0,0,0,0,0}, 6));\n\n    func0((int[]){1,2,3}, (int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (int[]){2,4,6}, 3));\n\n    func0((int[]){1,2,3,5}, (int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ntest   %ecx,%ecx\njle    11b <func0+0x11b>\nlea    0xf(%rdi),%r8\nlea    -0x1(%rcx),%eax\nsub    %rdx,%r8\ncmp    $0x1e,%r8\nseta   %r9b\ncmp    $0x2,%eax\nseta   %r8b\ntest   %r8b,%r9b\nje     f0 <func0+0xf0>\nlea    0xf(%rsi),%r8\nsub    %rdx,%r8\ncmp    $0x1e,%r8\njbe    f0 <func0+0xf0>\nmov    %ecx,%r8d\nxor    %eax,%eax\nshr    $0x2,%r8d\nshl    $0x4,%r8\nnopl   0x0(%rax)\nmovdqu (%rdi,%rax,1),%xmm0\nmovdqu (%rsi,%rax,1),%xmm2\npsubd  %xmm2,%xmm0\nmovdqa %xmm0,%xmm1\npsrad  $0x1f,%xmm1\npxor   %xmm1,%xmm0\npsubd  %xmm1,%xmm0\nmovups %xmm0,(%rdx,%rax,1)\nadd    $0x10,%rax\ncmp    %r8,%rax\njne    50 <func0+0x50>\nmov    %ecx,%eax\nand    $0xfffffffc,%eax\ntest   $0x3,%cl\nje     11b <func0+0x11b>\nmov    %eax,%r9d\nmov    (%rdi,%r9,4),%r8d\nsub    (%rsi,%r9,4),%r8d\nmov    %r8d,%r10d\nsar    $0x1f,%r10d\nxor    %r10d,%r8d\nmov    %r8d,(%rdx,%r9,4)\nlea    0x1(%rax),%r8d\nsub    %r10d,(%rdx,%r9,4)\ncmp    %r8d,%ecx\njle    11b <func0+0x11b>\nmovslq %r8d,%r8\nadd    $0x2,%eax\nmov    (%rdi,%r8,4),%r9d\nsub    (%rsi,%r8,4),%r9d\nmov    %r9d,%r10d\nsar    $0x1f,%r10d\nxor    %r10d,%r9d\nmov    %r9d,(%rdx,%r8,4)\nsub    %r10d,(%rdx,%r8,4)\ncmp    %eax,%ecx\njle    11b <func0+0x11b>\ncltq\nmov    (%rdi,%rax,4),%ecx\nsub    (%rsi,%rax,4),%ecx\nmov    %ecx,%esi\nsar    $0x1f,%esi\nxor    %esi,%ecx\nmov    %ecx,(%rdx,%rax,4)\nsub    %esi,(%rdx,%rax,4)\nretq\nnopw   0x0(%rax,%rax,1)\nmov    %eax,%r9d\nxor    %eax,%eax\nnopl   (%rax)\nmov    (%rdi,%rax,4),%ecx\nsub    (%rsi,%rax,4),%ecx\nmov    %ecx,%r8d\nsar    $0x1f,%r8d\nxor    %r8d,%ecx\nmov    %ecx,(%rdx,%rax,4)\nmov    %rax,%rcx\nsub    %r8d,(%rdx,%rax,4)\nadd    $0x1,%rax\ncmp    %r9,%rcx\njne    f8 <func0+0xf8>\nretq"
    },
    {
        "task_id": 153,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    func0(\"Watashi\", (const char* []){\"tEN\", \"niNE\", \"eIGHt8OKe\"}, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    func0(\"Boku123\", (const char* []){\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    func0(\"__YESIMHERE\", (const char* []){\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    func0(\"K\", (const char* []){\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    func0(\"__HAHA\", (const char* []){\"Tab\", \"123\", \"781345\", \"-_-\"}, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    func0(\"YameRore\", (const char* []){\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    func0(\"finNNalLLly\", (const char* []){\"Die\", \"NowW\", \"Wow\", \"WoW\"}, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    func0(\"_\", (const char* []){\"Bb\", \"91245\"}, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    func0(\"Sp\", (const char* []){\"671235\", \"Bb\"}, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %edx,-0x44(%rbp)\nmov    %rcx,-0x50(%rbp)\nmovl   $0xfffffc18,-0x20(%rbp)\nmovq   $0x0,-0x10(%rbp)\n00\nmovl   $0x0,-0x1c(%rbp)\njmpq   c6 <func0+0xc6>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    98 <func0+0x98>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x21(%rbp)\ncmpb   $0x40,-0x21(%rbp)\njle    84 <func0+0x84>\ncmpb   $0x5a,-0x21(%rbp)\njg     84 <func0+0x84>\naddl   $0x1,-0x18(%rbp)\ncmpb   $0x60,-0x21(%rbp)\njle    94 <func0+0x94>\ncmpb   $0x7a,-0x21(%rbp)\njg     94 <func0+0x94>\nsubl   $0x1,-0x18(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    61 <func0+0x61>\nmov    -0x18(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njle    c2 <func0+0xc2>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x10(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     36 <func0+0x36>\nmov    -0x10(%rbp),%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x50(%rbp),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncallq  f2 <func0+0xf2>\nnop\nleaveq\nretq"
    },
    {
        "task_id": 153,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    func0(\"Watashi\", (const char* []){\"tEN\", \"niNE\", \"eIGHt8OKe\"}, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    func0(\"Boku123\", (const char* []){\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    func0(\"__YESIMHERE\", (const char* []){\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    func0(\"K\", (const char* []){\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    func0(\"__HAHA\", (const char* []){\"Tab\", \"123\", \"781345\", \"-_-\"}, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    func0(\"YameRore\", (const char* []){\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    func0(\"finNNalLLly\", (const char* []){\"Die\", \"NowW\", \"Wow\", \"WoW\"}, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    func0(\"_\", (const char* []){\"Bb\", \"91245\"}, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    func0(\"Sp\", (const char* []){\"671235\", \"Bb\"}, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r8\nmov    %rcx,%rbp\ntest   %edx,%edx\njle    7b <func0+0x7b>\nmov    %rsi,%r10\nlea    -0x1(%rdx),%eax\nlea    0x8(%rsi,%rax,8),%rbx\nmov    $0x0,%r9d\nmov    $0xfffffc18,%edi\njmp    65 <func0+0x65>\nsub    $0x61,%eax\ncmp    $0x1a,%al\nsbb    $0x0,%ecx\nadd    $0x1,%rdx\nmovzbl -0x1(%rdx),%eax\ntest   %al,%al\nje     53 <func0+0x53>\nlea    -0x41(%rax),%esi\ncmp    $0x19,%sil\nja     2c <func0+0x2c>\nadd    $0x1,%ecx\njmp    34 <func0+0x34>\nmov    $0x0,%ecx\ncmp    %ecx,%edi\njge    5c <func0+0x5c>\nmov    %r11,%r9\nmov    %ecx,%edi\nadd    $0x8,%r10\ncmp    %rbx,%r10\nje     81 <func0+0x81>\nmov    (%r10),%r11\nmovzbl (%r11),%eax\ntest   %al,%al\nje     4e <func0+0x4e>\nlea    0x1(%r11),%rdx\nmov    $0x0,%ecx\njmp    40 <func0+0x40>\nmov    $0x0,%r9d\nlea    0x0(%rip),%rcx\nmov    $0xffffffffffffffff,%rdx\nmov    $0x1,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncallq  a1 <func0+0xa1>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 153,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    func0(\"Watashi\", (const char* []){\"tEN\", \"niNE\", \"eIGHt8OKe\"}, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    func0(\"Boku123\", (const char* []){\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    func0(\"__YESIMHERE\", (const char* []){\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    func0(\"K\", (const char* []){\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    func0(\"__HAHA\", (const char* []){\"Tab\", \"123\", \"781345\", \"-_-\"}, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    func0(\"YameRore\", (const char* []){\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    func0(\"finNNalLLly\", (const char* []){\"Die\", \"NowW\", \"Wow\", \"WoW\"}, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    func0(\"_\", (const char* []){\"Bb\", \"91245\"}, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    func0(\"Sp\", (const char* []){\"671235\", \"Bb\"}, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rdi,%r8\nmov    %rcx,%rdi\npush   %rbx\ntest   %edx,%edx\njle    a4 <func0+0xa4>\nlea    -0x1(%rdx),%eax\nmov    %rsi,%r10\nxor    %r9d,%r9d\nmov    $0xfffffc18,%ebx\nlea    0x8(%rsi,%rax,8),%rbp\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    (%r10),%r11\nmovzbl (%r11),%eax\ntest   %al,%al\nje     a0 <func0+0xa0>\nlea    0x1(%r11),%rdx\nxor    %ecx,%ecx\njmp    56 <func0+0x56>\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\nadd    $0x1,%ecx\ntest   %al,%al\nje     72 <func0+0x72>\nlea    -0x41(%rax),%esi\ncmp    $0x19,%sil\njbe    48 <func0+0x48>\nsub    $0x61,%eax\ncmp    $0x1a,%al\nsbb    $0x0,%ecx\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\njne    56 <func0+0x56>\ncmp    %ecx,%ebx\njge    7b <func0+0x7b>\nmov    %r11,%r9\nmov    %ecx,%ebx\nadd    $0x8,%r10\ncmp    %rbp,%r10\njne    30 <func0+0x30>\npop    %rbx\nlea    0x0(%rip),%rcx\nmov    $0xffffffffffffffff,%rdx\npop    %rbp\nmov    $0x1,%esi\nxor    %eax,%eax\njmpq   a0 <func0+0xa0>\nxor    %ecx,%ecx\njmp    72 <func0+0x72>\nxor    %r9d,%r9d\njmp    84 <func0+0x84>"
    },
    {
        "task_id": 153,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    func0(\"Watashi\", (const char* []){\"tEN\", \"niNE\", \"eIGHt8OKe\"}, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    func0(\"Boku123\", (const char* []){\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    func0(\"__YESIMHERE\", (const char* []){\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    func0(\"K\", (const char* []){\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    func0(\"__HAHA\", (const char* []){\"Tab\", \"123\", \"781345\", \"-_-\"}, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    func0(\"YameRore\", (const char* []){\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    func0(\"finNNalLLly\", (const char* []){\"Die\", \"NowW\", \"Wow\", \"WoW\"}, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    func0(\"_\", (const char* []){\"Bb\", \"91245\"}, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    func0(\"Sp\", (const char* []){\"671235\", \"Bb\"}, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rdi,%r8\nmov    %rcx,%rdi\npush   %rbx\ntest   %edx,%edx\njle    a4 <func0+0xa4>\nlea    -0x1(%rdx),%eax\nmov    %rsi,%r10\nxor    %r9d,%r9d\nmov    $0xfffffc18,%ebx\nlea    0x8(%rsi,%rax,8),%rbp\nnopw   0x0(%rax,%rax,1)\n00 00\nmov    (%r10),%r11\nmovzbl (%r11),%eax\ntest   %al,%al\nje     a0 <func0+0xa0>\nlea    0x1(%r11),%rdx\nxor    %ecx,%ecx\njmp    56 <func0+0x56>\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\nadd    $0x1,%ecx\ntest   %al,%al\nje     72 <func0+0x72>\nlea    -0x41(%rax),%esi\ncmp    $0x19,%sil\njbe    48 <func0+0x48>\nsub    $0x61,%eax\ncmp    $0x1a,%al\nsbb    $0x0,%ecx\nmovzbl (%rdx),%eax\nadd    $0x1,%rdx\ntest   %al,%al\njne    56 <func0+0x56>\ncmp    %ecx,%ebx\njge    7b <func0+0x7b>\nmov    %r11,%r9\nmov    %ecx,%ebx\nadd    $0x8,%r10\ncmp    %rbp,%r10\njne    30 <func0+0x30>\npop    %rbx\nlea    0x0(%rip),%rcx\nmov    $0xffffffffffffffff,%rdx\npop    %rbp\nmov    $0x1,%esi\nxor    %eax,%eax\njmpq   a0 <func0+0xa0>\nxor    %ecx,%ecx\njmp    72 <func0+0x72>\nxor    %r9d,%r9d\njmp    84 <func0+0x84>"
    },
    {
        "task_id": 154,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  20 <func0+0x20>\nmov    %eax,-0x10(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncallq  2f <func0+0x2f>\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncallq  44 <func0+0x44>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmpq   e2 <func0+0xe2>\nmov    -0xc(%rbp),%eax\nsub    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncallq  79 <func0+0x79>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x14(%rbp),%eax\ncltq\nsub    %rax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncallq  a3 <func0+0xa3>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  c6 <func0+0xc6>\ntest   %rax,%rax\nje     de <func0+0xde>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncallq  d7 <func0+0xd7>\nmov    $0x1,%eax\njmp    ff <func0+0xff>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     54 <func0+0x54>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncallq  fa <func0+0xfa>\nmov    $0x0,%eax\nleaveq\nretq"
    },
    {
        "task_id": 154,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r14\nmov    %rsi,%r13\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nmov    %rsi,%rdi\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%rbx\nlea    0x1(%rbx,%rbx,1),%edi\nmovslq %edi,%rdi\ncallq  3c <func0+0x3c>\nmov    %rax,%rbp\ntest   %ebx,%ebx\njle    9c <func0+0x9c>\nmov    %ebx,%r12d\nlea    -0x1(%rbx),%r15d\nmov    $0x0,%ebx\nmovslq %r12d,%r12\njmp    57 <func0+0x57>\nmov    %rax,%rbx\nmov    %r12,%rdx\nsub    %rbx,%rdx\nlea    0x0(%r13,%rbx,1),%rsi\nmov    %rbp,%rdi\ncallq  6a <func0+0x6a>\nlea    0x0(%rbp,%r12,1),%rdi\nsub    %rbx,%rdi\nmov    %rbx,%rdx\nmov    %r13,%rsi\ncallq  7d <func0+0x7d>\nmovb   $0x0,0x0(%rbp,%r12,1)\nmov    %rbp,%rsi\nmov    %r14,%rdi\ncallq  8e <func0+0x8e>\ntest   %rax,%rax\njne    b8 <func0+0xb8>\nlea    0x1(%rbx),%rax\ncmp    %r15,%rbx\njne    54 <func0+0x54>\nmov    %rbp,%rdi\ncallq  a4 <func0+0xa4>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    %rbp,%rdi\ncallq  c0 <func0+0xc0>\nmov    $0x1,%eax\njmp    a9 <func0+0xa9>"
    },
    {
        "task_id": 154,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rdi,%r13\nmov    %rsi,%rdi\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nsub    $0x18,%rsp\ncallq  20 <func0+0x20>\nlea    0x1(%rax,%rax,1),%edi\nmov    %rax,%rbx\nmovslq %edi,%rdi\ncallq  2f <func0+0x2f>\nmov    %rax,%r15\ntest   %ebx,%ebx\njle    b8 <func0+0xb8>\nmovslq %ebx,%r14\nlea    (%rax,%r14,1),%r12\nlea    -0x1(%rbx),%eax\nxor    %ebx,%ebx\nmov    %rax,0x8(%rsp)\njmp    5e <func0+0x5e>\nnopl   (%rax)\nlea    0x1(%rbx),%rax\ncmp    0x8(%rsp),%rbx\nje     b8 <func0+0xb8>\nmov    %rax,%rbx\nmov    %r14,%rdx\nlea    0x0(%rbp,%rbx,1),%rsi\nmov    %r15,%rdi\nsub    %rbx,%rdx\ncallq  71 <func0+0x71>\nmov    %r12,%rdi\nmov    %rbp,%rsi\nmov    %rbx,%rdx\nsub    %rbx,%rdi\ncallq  82 <func0+0x82>\nmovb   $0x0,(%r12)\nmov    %r15,%rsi\nmov    %r13,%rdi\ncallq  92 <func0+0x92>\ntest   %rax,%rax\nje     50 <func0+0x50>\nmov    %r15,%rdi\ncallq  9f <func0+0x9f>\nadd    $0x18,%rsp\nmov    $0x1,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax,%rax,1)\nmov    %r15,%rdi\ncallq  c0 <func0+0xc0>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 154,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rdi,%r13\nmov    %rsi,%rdi\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nsub    $0x18,%rsp\ncallq  20 <func0+0x20>\nlea    0x1(%rax,%rax,1),%edi\nmov    %rax,%rbx\nmovslq %edi,%rdi\ncallq  2f <func0+0x2f>\nmov    %rax,%r15\ntest   %ebx,%ebx\njle    b8 <func0+0xb8>\nmovslq %ebx,%r14\nlea    (%rax,%r14,1),%r12\nlea    -0x1(%rbx),%eax\nxor    %ebx,%ebx\nmov    %rax,0x8(%rsp)\njmp    5e <func0+0x5e>\nnopl   (%rax)\nlea    0x1(%rbx),%rax\ncmp    0x8(%rsp),%rbx\nje     b8 <func0+0xb8>\nmov    %rax,%rbx\nmov    %r14,%rdx\nlea    0x0(%rbp,%rbx,1),%rsi\nmov    %r15,%rdi\nsub    %rbx,%rdx\ncallq  71 <func0+0x71>\nmov    %r12,%rdi\nmov    %rbp,%rsi\nmov    %rbx,%rdx\nsub    %rbx,%rdi\ncallq  82 <func0+0x82>\nmovb   $0x0,(%r12)\nmov    %r15,%rsi\nmov    %r13,%rdi\ncallq  92 <func0+0x92>\ntest   %rax,%rax\nje     50 <func0+0x50>\nmov    %r15,%rdi\ncallq  9f <func0+0x9f>\nadd    $0x18,%rsp\nmov    $0x1,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax,%rax,1)\nmov    %r15,%rdi\ncallq  c0 <func0+0xc0>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 155,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (int[]){1, 0}, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmov    -0x14(%rbp),%eax\nsar    $0x1f,%eax\nxor    %eax,-0x14(%rbp)\nsub    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nmov    %eax,%ecx\nsar    $0x2,%ecx\nmov    %edx,%eax\nsar    $0x1f,%eax\nsub    %eax,%ecx\nmov    %ecx,%eax\nshl    $0x2,%eax\nadd    %ecx,%eax\nadd    %eax,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    66 <func0+0x66>\naddl   $0x1,-0xc(%rbp)\njmp    6a <func0+0x6a>\naddl   $0x1,-0x8(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nsub    %eax,%edx\nmov    %edx,%eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     29 <func0+0x29>\nmov    -0x20(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 155,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (int[]){1, 0}, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nsar    $0x1f,%eax\nxor    %eax,%edi\nsub    %eax,%edi\nmov    $0x0,%ecx\nmov    $0x0,%r8d\njmp    3a <func0+0x3a>\nadd    $0x1,%r8d\nmovslq %edi,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %edi,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\ncmp    $0x9,%edi\njle    45 <func0+0x45>\nmov    %eax,%edi\ntest   $0x1,%dil\nje     1a <func0+0x1a>\nadd    $0x1,%ecx\njmp    1e <func0+0x1e>\nmov    %r8d,(%rsi)\nmov    %ecx,0x4(%rsi)\nretq"
    },
    {
        "task_id": 155,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (int[]){1, 0}, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nxor    %edx,%edx\nxor    %ecx,%ecx\nmov    $0xcccccccd,%r8d\nsar    $0x1f,%eax\nxor    %eax,%edi\nsub    %eax,%edi\njmp    32 <func0+0x32>\nnopl   0x0(%rax)\nimul   %r8,%rax\nadd    $0x1,%ecx\nshr    $0x23,%rax\ncmp    $0x9,%edi\njle    4a <func0+0x4a>\nmov    %eax,%edi\nmov    %edi,%eax\ntest   $0x1,%dil\nje     20 <func0+0x20>\nimul   %r8,%rax\nadd    $0x1,%edx\nshr    $0x23,%rax\ncmp    $0x9,%edi\njg     30 <func0+0x30>\nmov    %ecx,(%rsi)\nmov    %edx,0x4(%rsi)\nretq"
    },
    {
        "task_id": 155,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (int[]){1, 0}, 2));\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmov    %edi,%eax\nxor    %edx,%edx\nxor    %ecx,%ecx\nmov    $0xcccccccd,%r8d\nsar    $0x1f,%eax\nxor    %eax,%edi\nsub    %eax,%edi\njmp    32 <func0+0x32>\nnopl   0x0(%rax)\nimul   %r8,%rax\nadd    $0x1,%ecx\nshr    $0x23,%rax\ncmp    $0x9,%edi\njle    4a <func0+0x4a>\nmov    %eax,%edi\nmov    %edi,%eax\ntest   $0x1,%dil\nje     20 <func0+0x20>\nimul   %r8,%rax\nadd    $0x1,%edx\nshr    $0x23,%rax\ncmp    $0x9,%edi\njg     30 <func0+0x30>\nmov    %ecx,(%rsi)\nmov    %edx,0x4(%rsi)\nretq"
    },
    {
        "task_id": 156,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xd0,%rsp\nmov    %edi,-0xc4(%rbp)\nmov    %rsi,-0xd0(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %rax,-0x70(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x68(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x60(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x58(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x50(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x48(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x18(%rbp)\nlea    0x0(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmovl   $0x3e8,-0xb0(%rbp)\n03 00 00\nmovl   $0x384,-0xac(%rbp)\n03 00 00\nmovl   $0x1f4,-0xa8(%rbp)\n01 00 00\nmovl   $0x190,-0xa4(%rbp)\n01 00 00\nmovl   $0x64,-0xa0(%rbp)\n00 00 00\nmovl   $0x5a,-0x9c(%rbp)\n00 00 00\nmovl   $0x32,-0x98(%rbp)\n00 00 00\nmovl   $0x28,-0x94(%rbp)\n00 00 00\nmovl   $0xa,-0x90(%rbp)\n00 00 00\nmovl   $0x9,-0x8c(%rbp)\n00 00 00\nmovl   $0x5,-0x88(%rbp)\n00 00 00\nmovl   $0x4,-0x84(%rbp)\n00 00 00\nmovl   $0x1,-0x80(%rbp)\nmovl   $0x0,-0xb4(%rbp)\n00 00 00\nmov    -0xd0(%rbp),%rax\nmovb   $0x0,(%rax)\njmp    1aa <func0+0x1aa>\nmov    -0xb4(%rbp),%eax\ncltq\nmov    -0x70(%rbp,%rax,8),%rdx\nmov    -0xd0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  16e <func0+0x16e>\nmov    -0xb4(%rbp),%eax\ncltq\nmov    -0xb0(%rbp,%rax,4),%eax\nsub    %eax,-0xc4(%rbp)\nmov    -0xb4(%rbp),%eax\ncltq\nmov    -0xb0(%rbp,%rax,4),%eax\ncmp    %eax,-0xc4(%rbp)\njge    14f <func0+0x14f>\ncmpl   $0x0,-0xc4(%rbp)\njle    1aa <func0+0x1aa>\naddl   $0x1,-0xb4(%rbp)\ncmpl   $0x0,-0xc4(%rbp)\njg     183 <func0+0x183>\nnop\nmov    -0x8(%rbp),%rax\nxor    %fs:0x28,%rax\n00 00\nje     1c8 <func0+0x1c8>\ncallq  1c8 <func0+0x1c8>\nleaveq\nretq"
    },
    {
        "task_id": 156,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xb0,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xa8(%rsp)\n00\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x48(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x50(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x58(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x60(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x68(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x70(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x78(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x80(%rsp)\n00\nlea    0x0(%rip),%rax\nmov    %rax,0x88(%rsp)\n00\nlea    0x0(%rip),%rax\nmov    %rax,0x90(%rsp)\n00\nlea    0x0(%rip),%rax\nmov    %rax,0x98(%rsp)\n00\nlea    0x0(%rip),%rax\nmov    %rax,0xa0(%rsp)\n00\nmovl   $0x3e8,(%rsp)\nmovl   $0x384,0x4(%rsp)\n00\nmovl   $0x1f4,0x8(%rsp)\n00\nmovl   $0x190,0xc(%rsp)\n00\nmovl   $0x64,0x10(%rsp)\n00\nmovl   $0x5a,0x14(%rsp)\n00\nmovl   $0x32,0x18(%rsp)\n00\nmovl   $0x28,0x1c(%rsp)\n00\nmovl   $0xa,0x20(%rsp)\n00\nmovl   $0x9,0x24(%rsp)\n00\nmovl   $0x5,0x28(%rsp)\n00\nmovl   $0x4,0x2c(%rsp)\n00\nmovl   $0x1,0x30(%rsp)\n00\nmovb   $0x0,(%rsi)\ntest   %edi,%edi\njle    171 <func0+0x171>\nmov    %edi,%ebx\nmov    %rsi,%r13\nmov    %rsp,%r14\nlea    0x40(%rsp),%r12\nmov    (%r14),%ebp\ncmp    %ebx,%ebp\njg     165 <func0+0x165>\nmov    (%r12),%rsi\nmov    %r13,%rdi\ncallq  15f <func0+0x15f>\nsub    %ebp,%ebx\ncmp    %ebp,%ebx\njge    153 <func0+0x153>\nadd    $0x4,%r14\nadd    $0x8,%r12\ntest   %ebx,%ebx\njg     14c <func0+0x14c>\nmov    0xa8(%rsp),%rax\n00\nxor    %fs:0x28,%rax\n00 00\njne    194 <func0+0x194>\nadd    $0xb0,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\ncallq  199 <.LC12+0x17b>"
    },
    {
        "task_id": 156,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xb0,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xa8(%rsp)\n00\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmovb   $0x0,(%rsi)\nmov    %rax,0x40(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x48(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x50(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x58(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x60(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x68(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x70(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x78(%rsp)\nlea    0x0(%rip),%rax\nmov    %rax,0x80(%rsp)\n00\nlea    0x0(%rip),%rax\nmov    %rax,0x88(%rsp)\n00\nlea    0x0(%rip),%rax\nmov    %rax,0x90(%rsp)\n00\nlea    0x0(%rip),%rax\nmov    %rax,0x98(%rsp)\n00\nlea    0x0(%rip),%rax\nmov    %rax,0xa0(%rsp)\n00\nmovabs $0x1f400000384,%rax\n01 00 00\nmov    %rax,0x4(%rsp)\nmovabs $0x6400000190,%rax\n00 00 00\nmov    %rax,0xc(%rsp)\nmovabs $0x320000005a,%rax\n00 00 00\nmov    %rax,0x14(%rsp)\nmovabs $0xa00000028,%rax\n00 00 00\nmov    %rax,0x1c(%rsp)\nmovabs $0x500000009,%rax\n00 00 00\nmov    %rax,0x24(%rsp)\nmovabs $0x100000004,%rax\n00 00 00\nmov    %rax,0x2c(%rsp)\ntest   %edi,%edi\njle    188 <func0+0x188>\nmov    %edi,%ebx\nmov    $0x3e8,%ebp\nmov    %rsi,%rdx\nxor    %r13d,%r13d\nlea    0x40(%rsp),%r14\ncmp    %ebx,%ebp\njg     17c <func0+0x17c>\nnopl   0x0(%rax,%rax,1)\n00\nmov    (%r14,%r13,2),%r12\nnopl   0x0(%rax)\nmov    %rdx,%rdi\nmov    %r12,%rsi\nsub    %ebp,%ebx\ncallq  165 <func0+0x165>\nmov    %rax,%rdx\ncmp    %ebx,%ebp\njle    158 <func0+0x158>\nadd    $0x4,%r13\ntest   %ebx,%ebx\nje     188 <func0+0x188>\nmov    (%rsp,%r13,1),%ebp\ncmp    %ebx,%ebp\njle    150 <func0+0x150>\nadd    $0x4,%r13\njmp    174 <func0+0x174>\nnopw   0x0(%rax,%rax,1)\nmov    0xa8(%rsp),%rax\n00\nxor    %fs:0x28,%rax\n00 00\njne    1ab <func0+0x1ab>\nadd    $0xb0,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nretq\ncallq  1b0 <.LC12+0x192>"
    },
    {
        "task_id": 156,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nlea    0x0(%rip),%rcx\nmov    %rsi,%rdx\npush   %r14\nmovq   %rcx,%xmm0\nlea    0x0(%rip),%rcx\npush   %r13\nxor    %r13d,%r13d\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebx\nsub    $0xb8,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0xa8(%rsp)\n00\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmovb   $0x0,(%rsi)\nmov    %rsp,%r14\nmovq   %rax,%xmm1\nlea    0x0(%rip),%rax\nlea    0x40(%rsp),%r15\nmovl   $0x1,0x30(%rsp)\n00\npunpcklqdq %xmm1,%xmm0\nmovq   %rax,%xmm2\nlea    0x0(%rip),%rax\nmovaps %xmm0,0x40(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm3\nlea    0x0(%rip),%rcx\npunpcklqdq %xmm2,%xmm0\nlea    0x0(%rip),%rax\nmovaps %xmm0,0x50(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm4\nlea    0x0(%rip),%rcx\npunpcklqdq %xmm3,%xmm0\nlea    0x0(%rip),%rax\nmovaps %xmm0,0x60(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm5\nlea    0x0(%rip),%rcx\npunpcklqdq %xmm4,%xmm0\nlea    0x0(%rip),%rax\nmovaps %xmm0,0x70(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm6\nlea    0x0(%rip),%rcx\npunpcklqdq %xmm5,%xmm0\nlea    0x0(%rip),%rax\nmovaps %xmm0,0x80(%rsp)\n00\nmovq   %rcx,%xmm0\npunpcklqdq %xmm6,%xmm0\nmov    %rax,0xa0(%rsp)\n00\nmovaps %xmm0,0x90(%rsp)\n00\nmovdqa 0x0(%rip),%xmm0\n00\nmovaps %xmm0,(%rsp)\nmovdqa 0x0(%rip),%xmm0\n00\nmovaps %xmm0,0x10(%rsp)\nmovdqa 0x0(%rip),%xmm0\n00\nmovaps %xmm0,0x20(%rsp)\ntest   %edi,%edi\njle    17c <func0+0x17c>\nnopl   0x0(%rax,%rax,1)\n00\nmov    (%r14,%r13,4),%ebp\ncmp    %ebx,%ebp\njg     1a8 <func0+0x1a8>\nmov    (%r15,%r13,8),%r12\nnopl   0x0(%rax)\nmov    %rdx,%rdi\nmov    %r12,%rsi\nsub    %ebp,%ebx\ncallq  16d <func0+0x16d>\nmov    %rax,%rdx\ncmp    %ebp,%ebx\njge    160 <func0+0x160>\nadd    $0x1,%r13\ntest   %ebx,%ebx\njne    150 <func0+0x150>\nmov    0xa8(%rsp),%rax\n00\nxor    %fs:0x28,%rax\n00 00\njne    1ae <func0+0x1ae>\nadd    $0xb8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\nadd    $0x1,%r13\njmp    150 <func0+0x150>\ncallq  1b3 <.LC15+0x193>"
    },
    {
        "task_id": 157,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovss  %xmm0,-0x4(%rbp)\nmovss  %xmm1,-0x8(%rbp)\nmovss  %xmm2,-0xc(%rbp)\nmovss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  %xmm0,%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  %xmm0,%xmm0\naddss  %xmm0,%xmm1\nmovss  -0xc(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nsubss  %xmm0,%xmm1\nmovaps %xmm1,%xmm0\nmovss  0x0(%rip),%xmm1\n00\nandps  %xmm1,%xmm0\ncvtss2sd %xmm0,%xmm1\nmovsd  0x0(%rip),%xmm0\n00\ncomisd %xmm1,%xmm0\nja     ed <func0+0xed>\nmovss  -0x4(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  %xmm0,%xmm1\nmovss  -0xc(%rbp),%xmm0\nmulss  %xmm0,%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x8(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nsubss  %xmm0,%xmm1\nmovaps %xmm1,%xmm0\nmovss  0x0(%rip),%xmm1\n00\nandps  %xmm1,%xmm0\ncvtss2sd %xmm0,%xmm1\nmovsd  0x0(%rip),%xmm0\n00\ncomisd %xmm1,%xmm0\nja     ed <func0+0xed>\nmovss  -0x8(%rbp),%xmm0\nmovaps %xmm0,%xmm1\nmulss  %xmm0,%xmm1\nmovss  -0xc(%rbp),%xmm0\nmulss  %xmm0,%xmm0\naddss  %xmm0,%xmm1\nmovss  -0x4(%rbp),%xmm0\nmulss  %xmm0,%xmm0\nsubss  %xmm0,%xmm1\nmovaps %xmm1,%xmm0\nmovss  0x0(%rip),%xmm1\n00\nandps  %xmm1,%xmm0\ncvtss2sd %xmm0,%xmm1\nmovsd  0x0(%rip),%xmm0\n00\ncomisd %xmm1,%xmm0\njbe    f4 <func0+0xf4>\nmov    $0x1,%eax\njmp    f9 <func0+0xf9>\nmov    $0x0,%eax\npop    %rbp\nretq"
    },
    {
        "task_id": 157,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmulss  %xmm0,%xmm0\nmulss  %xmm1,%xmm1\nmulss  %xmm2,%xmm2\nmovaps %xmm0,%xmm3\naddss  %xmm1,%xmm3\nsubss  %xmm2,%xmm3\nandps  0x0(%rip),%xmm3\ncvtss2sd %xmm3,%xmm3\nmov    $0x1,%eax\nmovsd  0x0(%rip),%xmm4\n00\ncomisd %xmm3,%xmm4\nja     72 <func0+0x72>\nmovaps %xmm0,%xmm3\naddss  %xmm2,%xmm3\nsubss  %xmm1,%xmm3\nandps  0x0(%rip),%xmm3\ncvtss2sd %xmm3,%xmm3\ncomisd %xmm3,%xmm4\nja     72 <func0+0x72>\naddss  %xmm2,%xmm1\nsubss  %xmm0,%xmm1\nandps  0x0(%rip),%xmm1\ncvtss2sd %xmm1,%xmm1\ncomisd %xmm1,%xmm4\nseta   %al\nmovzbl %al,%eax\nretq"
    },
    {
        "task_id": 157,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmulss  %xmm0,%xmm0\nmovsd  0x0(%rip),%xmm4\n00\nmovss  0x0(%rip),%xmm5\n00\nmov    $0x1,%eax\nmulss  %xmm1,%xmm1\nmulss  %xmm2,%xmm2\nmovaps %xmm0,%xmm3\naddss  %xmm1,%xmm3\nsubss  %xmm2,%xmm3\nandps  %xmm5,%xmm3\ncvtss2sd %xmm3,%xmm3\ncomisd %xmm3,%xmm4\nja     6d <func0+0x6d>\nmovaps %xmm0,%xmm3\naddss  %xmm2,%xmm3\nsubss  %xmm1,%xmm3\nandps  %xmm5,%xmm3\ncvtss2sd %xmm3,%xmm3\ncomisd %xmm3,%xmm4\nja     6d <func0+0x6d>\naddss  %xmm2,%xmm1\nxor    %eax,%eax\nsubss  %xmm0,%xmm1\nandps  %xmm5,%xmm1\ncvtss2sd %xmm1,%xmm1\ncomisd %xmm1,%xmm4\nseta   %al\nretq"
    },
    {
        "task_id": 157,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmulss  %xmm0,%xmm0\nmovsd  0x0(%rip),%xmm4\n00\nmovss  0x0(%rip),%xmm5\n00\nmov    $0x1,%eax\nmulss  %xmm1,%xmm1\nmulss  %xmm2,%xmm2\nmovaps %xmm0,%xmm3\naddss  %xmm1,%xmm3\nsubss  %xmm2,%xmm3\nandps  %xmm5,%xmm3\ncvtss2sd %xmm3,%xmm3\ncomisd %xmm3,%xmm4\nja     6d <func0+0x6d>\nmovaps %xmm0,%xmm3\naddss  %xmm2,%xmm3\nsubss  %xmm1,%xmm3\nandps  %xmm5,%xmm3\ncvtss2sd %xmm3,%xmm3\ncomisd %xmm3,%xmm4\nja     6d <func0+0x6d>\naddss  %xmm2,%xmm1\nxor    %eax,%eax\nsubss  %xmm0,%xmm1\nandps  %xmm5,%xmm1\ncvtss2sd %xmm1,%xmm1\ncomisd %xmm1,%xmm4\nseta   %al\nretq"
    },
    {
        "task_id": 158,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x140,%rsp\nmov    %rdi,-0x138(%rbp)\nmov    %esi,-0x13c(%rbp)\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %rax,-0x118(%rbp)\nmovl   $0x0,-0x12c(%rbp)\n00 00 00\nmovl   $0x0,-0x128(%rbp)\n00 00 00\njmpq   30e <func0+0x30e>\nmovq   $0x0,-0x110(%rbp)\n00 00 00 00\nmovq   $0x0,-0x108(%rbp)\n00 00 00 00\nmovq   $0x0,-0x100(%rbp)\n00 00 00 00\nmovq   $0x0,-0xf8(%rbp)\n00 00 00 00\nmovq   $0x0,-0xf0(%rbp)\n00 00 00 00\nmovq   $0x0,-0xe8(%rbp)\n00 00 00 00\nmovq   $0x0,-0xe0(%rbp)\n00 00 00 00\nmovq   $0x0,-0xd8(%rbp)\n00 00 00 00\nmovq   $0x0,-0xd0(%rbp)\n00 00 00 00\nmovq   $0x0,-0xc8(%rbp)\n00 00 00 00\nmovq   $0x0,-0xc0(%rbp)\n00 00 00 00\nmovq   $0x0,-0xb8(%rbp)\n00 00 00 00\nmovq   $0x0,-0xb0(%rbp)\n00 00 00 00\nmovq   $0x0,-0xa8(%rbp)\n00 00 00 00\nmovq   $0x0,-0xa0(%rbp)\n00 00 00 00\nmovq   $0x0,-0x98(%rbp)\n00 00 00 00\nmovq   $0x0,-0x90(%rbp)\n00 00 00 00\nmovq   $0x0,-0x88(%rbp)\n00 00 00 00\nmovq   $0x0,-0x80(%rbp)\n00\nmovq   $0x0,-0x78(%rbp)\n00\nmovq   $0x0,-0x70(%rbp)\n00\nmovq   $0x0,-0x68(%rbp)\n00\nmovq   $0x0,-0x60(%rbp)\n00\nmovq   $0x0,-0x58(%rbp)\n00\nmovq   $0x0,-0x50(%rbp)\n00\nmovq   $0x0,-0x48(%rbp)\n00\nmovq   $0x0,-0x40(%rbp)\n00\nmovq   $0x0,-0x38(%rbp)\n00\nmovq   $0x0,-0x30(%rbp)\n00\nmovq   $0x0,-0x28(%rbp)\n00\nmovq   $0x0,-0x20(%rbp)\n00\nmovq   $0x0,-0x18(%rbp)\n00\nmovl   $0x0,-0x124(%rbp)\n00 00 00\nmovl   $0x0,-0x120(%rbp)\n00 00 00\njmpq   255 <func0+0x255>\nmov    -0x128(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x138(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x120(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nlea    -0x110(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncallq  1e0 <func0+0x1e0>\ntest   %rax,%rax\njne    24e <func0+0x24e>\nlea    -0x110(%rbp),%rax\nmov    %rax,%rdi\ncallq  1f4 <func0+0x1f4>\nmov    %eax,-0x11c(%rbp)\nmov    -0x128(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x138(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x120(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x11c(%rbp),%eax\ncltq\nmov    %dl,-0x110(%rbp,%rax,1)\nmov    -0x11c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmovb   $0x0,-0x110(%rbp,%rax,1)\n00\naddl   $0x1,-0x124(%rbp)\naddl   $0x1,-0x120(%rbp)\nmov    -0x128(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x138(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x120(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1a1 <func0+0x1a1>\nmov    -0x124(%rbp),%eax\ncmp    -0x12c(%rbp),%eax\njg     2d7 <func0+0x2d7>\nmov    -0x124(%rbp),%eax\ncmp    -0x12c(%rbp),%eax\njne    307 <func0+0x307>\nmov    -0x128(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x138(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x118(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncallq  2d3 <func0+0x2d3>\ntest   %eax,%eax\njns    307 <func0+0x307>\nmov    -0x128(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x138(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x118(%rbp)\nmov    -0x124(%rbp),%eax\nmov    %eax,-0x12c(%rbp)\naddl   $0x1,-0x128(%rbp)\nmov    -0x128(%rbp),%eax\ncmp    -0x13c(%rbp),%eax\njl     52 <func0+0x52>\nmov    -0x118(%rbp),%rax\nmov    -0x8(%rbp),%rcx\nxor    %fs:0x28,%rcx\n00 00\nje     33b <func0+0x33b>\ncallq  33b <func0+0x33b>\nleaveq\nretq"
    },
    {
        "task_id": 158,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x138,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x128(%rsp)\n00\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %rax,0x10(%rsp)\ntest   %esi,%esi\njle    271 <func0+0x271>\nmov    %rdi,%r14\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%rax\nmov    %rax,0x18(%rsp)\nmovl   $0x0,0xc(%rsp)\n00\nlea    0x20(%rsp),%r12\njmpq   f7 <func0+0xf7>\nmov    $0xffffffffffffffff,%rcx\nmov    %r12,%rdi\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nsub    $0x1,%rcx\nmovslq %ecx,%rax\nmov    %bl,0x20(%rsp,%rax,1)\nadd    $0x1,%ecx\nmovslq %ecx,%rcx\nmovb   $0x0,0x20(%rsp,%rcx,1)\nadd    $0x1,%r13d\nadd    $0x1,%rbp\nmovzbl -0x1(%rbp),%ebx\ntest   %bl,%bl\nje     ab <func0+0xab>\nmovsbl %bl,%esi\nmov    %r12,%rdi\ncallq  9e <func0+0x9e>\ntest   %rax,%rax\njne    87 <func0+0x87>\njmp    5e <func0+0x5e>\nmov    $0x0,%r13d\nmov    0xc(%rsp),%eax\ncmp    %r13d,%eax\njl     de <func0+0xde>\njne    e8 <func0+0xe8>\nmov    0x10(%rsp),%rbx\nmov    %rbx,%rsi\nmov    %r15,%rdi\ncallq  c6 <func0+0xc6>\ntest   %eax,%eax\ncmovns 0xc(%rsp),%r13d\nmov    %r13d,0xc(%rsp)\ncmovns %rbx,%r15\nmov    %r15,0x10(%rsp)\njmp    e8 <func0+0xe8>\nmov    %r13d,0xc(%rsp)\nmov    %r15,0x10(%rsp)\nadd    $0x8,%r14\ncmp    0x18(%rsp),%r14\nje     271 <func0+0x271>\nmovq   $0x0,0x20(%rsp)\n00 00\nmovq   $0x0,0x28(%rsp)\n00 00\nmovq   $0x0,0x30(%rsp)\n00 00\nmovq   $0x0,0x38(%rsp)\n00 00\nmovq   $0x0,0x40(%rsp)\n00 00\nmovq   $0x0,0x48(%rsp)\n00 00\nmovq   $0x0,0x50(%rsp)\n00 00\nmovq   $0x0,0x58(%rsp)\n00 00\nmovq   $0x0,0x60(%rsp)\n00 00\nmovq   $0x0,0x68(%rsp)\n00 00\nmovq   $0x0,0x70(%rsp)\n00 00\nmovq   $0x0,0x78(%rsp)\n00 00\nmovq   $0x0,0x80(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x88(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x90(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x98(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xa0(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xa8(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xb0(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xb8(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xc0(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xc8(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xd0(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xd8(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xe0(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xe8(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xf0(%rsp)\n00 00 00 00 00\nmovq   $0x0,0xf8(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x100(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x108(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x110(%rsp)\n00 00 00 00 00\nmovq   $0x0,0x118(%rsp)\n00 00 00 00 00\nmov    (%r14),%r15\nmovzbl (%r15),%ebx\ntest   %bl,%bl\nje     a5 <func0+0xa5>\nlea    0x1(%r15),%rbp\nmov    $0x0,%r13d\njmpq   93 <func0+0x93>\nmov    0x128(%rsp),%rax\n00\nxor    %fs:0x28,%rax\n00 00\njne    29b <func0+0x29b>\nmov    0x10(%rsp),%rax\nadd    $0x138,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\ncallq  2a0 <func0+0x2a0>"
    },
    {
        "task_id": 158,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x138,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x128(%rsp)\n00\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %rax,0x18(%rsp)\ntest   %esi,%esi\njle    1a7 <func0+0x1a7>\nlea    -0x1(%rsi),%eax\nmovl   $0x0,0xc(%rsp)\n00\nmov    %rdi,%rbp\nlea    0x20(%rsp),%r15\nlea    0x8(%rdi,%rax,8),%rax\nmov    %rax,0x10(%rsp)\nnopl   0x0(%rax)\nmov    0x0(%rbp),%r12\npxor   %xmm0,%xmm0\nmovaps %xmm0,0x20(%rsp)\nmovzbl (%r12),%r14d\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x70(%rsp)\nmovaps %xmm0,0x80(%rsp)\n00\nmovaps %xmm0,0x90(%rsp)\n00\nmovaps %xmm0,0xa0(%rsp)\n00\nmovaps %xmm0,0xb0(%rsp)\n00\nmovaps %xmm0,0xc0(%rsp)\n00\nmovaps %xmm0,0xd0(%rsp)\n00\nmovaps %xmm0,0xe0(%rsp)\n00\nmovaps %xmm0,0xf0(%rsp)\n00\nmovaps %xmm0,0x100(%rsp)\n00\nmovaps %xmm0,0x110(%rsp)\n00\ntest   %r14b,%r14b\nje     1e8 <func0+0x1e8>\nlea    0x1(%r12),%r13\nxor    %ebx,%ebx\njmp    fe <func0+0xfe>\nnopl   (%rax)\nmovzbl 0x0(%r13),%r14d\nadd    $0x1,%r13\ntest   %r14b,%r14b\nje     16e <func0+0x16e>\nmovsbl %r14b,%esi\nmov    %r15,%rdi\ncallq  10a <func0+0x10a>\ntest   %rax,%rax\njne    f0 <func0+0xf0>\nmov    %r15,%rax\nmov    (%rax),%esi\nadd    $0x4,%rax\nlea    -0x1010101(%rsi),%edx\nnot    %esi\nand    %esi,%edx\nand    $0x80808080,%edx\nje     112 <func0+0x112>\nmov    %edx,%esi\nshr    $0x10,%esi\ntest   $0x8080,%edx\ncmove  %esi,%edx\nlea    0x2(%rax),%rsi\ncmove  %rsi,%rax\nmov    %edx,%ecx\nadd    %dl,%cl\nsbb    $0x3,%rax\nadd    $0x1,%r13\nadd    $0x1,%ebx\nsub    %r15,%rax\nmovslq %eax,%rdx\nadd    $0x1,%eax\nmov    %r14b,0x20(%rsp,%rdx,1)\nmovzbl -0x1(%r13),%r14d\ncltq\nmovb   $0x0,0x20(%rsp,%rax,1)\ntest   %r14b,%r14b\njne    fe <func0+0xfe>\ncmp    %ebx,0xc(%rsp)\njl     1d8 <func0+0x1d8>\njne    198 <func0+0x198>\nmov    0x18(%rsp),%rbx\nmov    %r12,%rdi\nmov    %rbx,%rsi\ncallq  186 <func0+0x186>\ntest   %eax,%eax\ncmovns %rbx,%r12\nmov    %r12,0x18(%rsp)\nnopl   0x0(%rax)\nadd    $0x8,%rbp\ncmp    0x10(%rsp),%rbp\njne    60 <func0+0x60>\nmov    0x128(%rsp),%rax\n00\nxor    %fs:0x28,%rax\n00 00\njne    1ec <func0+0x1ec>\nmov    0x18(%rsp),%rax\nadd    $0x138,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\nmov    %ebx,0xc(%rsp)\nmov    %r12,0x18(%rsp)\njmp    198 <func0+0x198>\nnopl   0x0(%rax,%rax,1)\nxor    %ebx,%ebx\njmp    16e <func0+0x16e>\ncallq  1f1 <func0+0x1f1>"
    },
    {
        "task_id": 158,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x138,%rsp\nmov    %fs:0x28,%rax\n00 00\nmov    %rax,0x128(%rsp)\n00\nxor    %eax,%eax\nlea    0x0(%rip),%rax\nmov    %rax,0x18(%rsp)\ntest   %esi,%esi\njle    14f <func0+0x14f>\nlea    -0x1(%rsi),%eax\nmovl   $0x0,0xc(%rsp)\n00\nmov    %rdi,%rbp\nlea    0x20(%rsp),%r15\nlea    0x8(%rdi,%rax,8),%rax\nmov    %rax,0x10(%rsp)\nnopl   0x0(%rax)\nmov    0x0(%rbp),%r12\npxor   %xmm0,%xmm0\nmovaps %xmm0,0x20(%rsp)\nmovzbl (%r12),%r14d\nmovaps %xmm0,0x30(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x70(%rsp)\nmovaps %xmm0,0x80(%rsp)\n00\nmovaps %xmm0,0x90(%rsp)\n00\nmovaps %xmm0,0xa0(%rsp)\n00\nmovaps %xmm0,0xb0(%rsp)\n00\nmovaps %xmm0,0xc0(%rsp)\n00\nmovaps %xmm0,0xd0(%rsp)\n00\nmovaps %xmm0,0xe0(%rsp)\n00\nmovaps %xmm0,0xf0(%rsp)\n00\nmovaps %xmm0,0x100(%rsp)\n00\nmovaps %xmm0,0x110(%rsp)\n00\ntest   %r14b,%r14b\nje     200 <func0+0x200>\nlea    0x1(%r12),%r13\nxor    %ebx,%ebx\nnopl   0x0(%rax,%rax,1)\nmovsbl %r14b,%esi\nmov    %r15,%rdi\ncallq  fc <func0+0xfc>\ntest   %rax,%rax\nje     180 <func0+0x180>\nmovzbl 0x0(%r13),%r14d\nadd    $0x1,%r13\ntest   %r14b,%r14b\njne    f0 <func0+0xf0>\ncmp    %ebx,0xc(%rsp)\njl     1ed <func0+0x1ed>\njne    140 <func0+0x140>\nmov    0x18(%rsp),%rbx\nmov    %r12,%rdi\nmov    %rbx,%rsi\ncallq  12b <func0+0x12b>\ntest   %eax,%eax\ncmovns %rbx,%r12\nmov    %r12,0x18(%rsp)\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nadd    $0x8,%rbp\ncmp    0x10(%rsp),%rbp\njne    60 <func0+0x60>\nmov    0x128(%rsp),%rax\n00\nxor    %fs:0x28,%rax\n00 00\njne    207 <func0+0x207>\nmov    0x18(%rsp),%rax\nadd    $0x138,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   (%rax)\nmov    %r15,%rax\nmov    (%rax),%esi\nadd    $0x4,%rax\nlea    -0x1010101(%rsi),%edx\nnot    %esi\nand    %esi,%edx\nand    $0x80808080,%edx\nje     183 <func0+0x183>\nmov    %edx,%esi\nshr    $0x10,%esi\ntest   $0x8080,%edx\ncmove  %esi,%edx\nlea    0x2(%rax),%rsi\ncmove  %rsi,%rax\nmov    %edx,%ecx\nadd    %dl,%cl\nsbb    $0x3,%rax\nadd    $0x1,%r13\nadd    $0x1,%ebx\nsub    %r15,%rax\nmovslq %eax,%rdx\nadd    $0x1,%eax\ncltq\nmov    %r14b,0x20(%rsp,%rdx,1)\nmovb   $0x0,0x20(%rsp,%rax,1)\nmovzbl -0x1(%r13),%r14d\ntest   %r14b,%r14b\njne    f0 <func0+0xf0>\ncmp    %ebx,0xc(%rsp)\njge    119 <func0+0x119>\nmov    %ebx,0xc(%rsp)\nmov    %r12,0x18(%rsp)\njmpq   140 <func0+0x140>\nnopl   0x0(%rax,%rax,1)\nxor    %ebx,%ebx\njmpq   10f <func0+0x10f>\ncallq  20c <func0+0x20c>"
    },
    {
        "task_id": 159,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (int[]){5, 0}));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %edx,-0xc(%rbp)\nmov    %rcx,-0x18(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njle    3b <func0+0x3b>\nmov    -0x4(%rbp),%edx\nmov    -0xc(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmovl   $0x0,(%rax)\njmp    59 <func0+0x59>\nmov    -0x4(%rbp),%edx\nmov    -0x8(%rbp),%eax\nadd    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0xc(%rbp),%eax\nsub    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 159,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (int[]){5, 0}));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %edx,%esi\njle    14 <func0+0x14>\nadd    %edi,%edx\nmov    %edx,(%rcx)\nmovl   $0x0,0x4(%rcx)\nretq\nadd    %esi,%edi\nmov    %edi,(%rcx)\nsub    %esi,%edx\nmov    %edx,0x4(%rcx)\nretq"
    },
    {
        "task_id": 159,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (int[]){5, 0}));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %edx,%esi\njle    18 <func0+0x18>\nadd    %edi,%edx\nmovl   $0x0,0x4(%rcx)\nmov    %edx,(%rcx)\nretq\nnopl   0x0(%rax)\nadd    %esi,%edi\nsub    %esi,%edx\nmov    %edi,(%rcx)\nmov    %edx,0x4(%rcx)\nretq"
    },
    {
        "task_id": 159,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (int[]){5, 0}));\n    \n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\ncmp    %edx,%esi\njle    18 <func0+0x18>\nadd    %edx,%edi\nxor    %edx,%edx\nmov    %edx,0x4(%rcx)\nmov    %edi,(%rcx)\nretq\nnopw   0x0(%rax,%rax,1)\nadd    %esi,%edi\nsub    %esi,%edx\nmov    %edx,0x4(%rcx)\nmov    %edi,(%rcx)\nretq"
    },
    {
        "task_id": 160,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %edx,-0x44(%rbp)\nmov    %ecx,-0x48(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  2b <func0+0x2b>\nmov    %rax,-0x10(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncallq  40 <func0+0x40>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    97 <func0+0x97>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x24(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x10(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x24(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x48(%rbp),%eax\njl     4d <func0+0x4d>\nmovl   $0x0,-0x20(%rbp)\njmpq   2c0 <func0+0x2c0>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  d1 <func0+0xd1>\ntest   %eax,%eax\njne    2bc <func0+0x2bc>\njmp    11b <func0+0x11b>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x20(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    db <func0+0xdb>\njmp    1ac <func0+0x1ac>\nmov    -0x20(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x20(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x20(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x20(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    164 <func0+0x164>\nmov    -0x20(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncvtsi2sd %eax,%xmm1\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncvtsi2sd %eax,%xmm0\ncallq  25e <func0+0x25e>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\ncvttsd2si %xmm0,%eax\nmov    %eax,(%rdx)\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x20(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     ab <func0+0xab>\nmovl   $0x0,-0x1c(%rbp)\njmpq   5c4 <func0+0x5c4>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  2fe <func0+0x2fe>\ntest   %eax,%eax\nje     372 <func0+0x372>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  328 <func0+0x328>\ntest   %eax,%eax\njne    5c0 <func0+0x5c0>\njmp    372 <func0+0x372>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    332 <func0+0x332>\njmp    403 <func0+0x403>\nmov    -0x1c(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x1c(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    3bb <func0+0x3bb>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  478 <func0+0x478>\ntest   %eax,%eax\njne    509 <func0+0x509>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rsi\n00\nmov    -0x8(%rbp),%rdx\nadd    %rsi,%rdx\nmov    (%rdx),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rsi\n00\nmov    -0x10(%rbp),%rdx\nadd    %rsi,%rdx\nimul   %ecx,%eax\nmov    %eax,(%rdx)\njmpq   58f <func0+0x58f>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x10(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%edi\nmov    -0x1c(%rbp),%ecx\nmovslq %ecx,%rcx\nlea    0x0(,%rcx,4),%rsi\n00\nmov    -0x8(%rbp),%rcx\nadd    %rsi,%rcx\nmov    (%rcx),%ecx\nmovslq %ecx,%rcx\nlea    0x0(,%rcx,4),%rsi\n00\nmov    -0x10(%rbp),%rcx\nadd    %rsi,%rcx\ncltd\nidiv   %edi\nmov    %eax,(%rcx)\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     2d8 <func0+0x2d8>\nmovl   $0x0,-0x18(%rbp)\njmpq   8c2 <func0+0x8c2>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  602 <func0+0x602>\ntest   %eax,%eax\nje     676 <func0+0x676>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  62c <func0+0x62c>\ntest   %eax,%eax\njne    8be <func0+0x8be>\njmp    676 <func0+0x676>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    636 <func0+0x636>\njmp    707 <func0+0x707>\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rcx\n00\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njne    6bf <func0+0x6bf>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\n00\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\ncallq  77c <func0+0x77c>\ntest   %eax,%eax\njne    80a <func0+0x80a>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rsi\n00\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rsi\n00\nmov    -0x10(%rbp),%rax\nadd    %rsi,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\njmpq   88d <func0+0x88d>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rsi\n00\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,4),%rsi\n00\nmov    -0x10(%rbp),%rax\nadd    %rsi,%rax\nsub    %edx,%ecx\nmov    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\n00\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     5dc <func0+0x5dc>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncallq  8e3 <func0+0x8e3>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncallq  8ef <func0+0x8ef>\nmov    -0x14(%rbp),%eax\nleaveq\nretq"
    },
    {
        "task_id": 160,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,0x20(%rsp)\nmov    %rsi,%r13\nmov    %edx,%ebp\nmov    %ecx,%r14d\nmovslq %ecx,%rbx\nshl    $0x2,%rbx\nmov    %rbx,%rdi\ncallq  2e <func0+0x2e>\nmov    %rax,%r12\nmov    %rbx,%rdi\ncallq  39 <func0+0x39>\nmov    %rax,%rbx\ntest   %r14d,%r14d\njle    62 <func0+0x62>\nlea    -0x1(%r14),%ecx\nmov    $0x0,%eax\nmov    0x0(%r13,%rax,4),%edx\nmov    %edx,(%r12,%rax,4)\nmov    %eax,(%rbx,%rax,4)\nmov    %rax,%rdx\nadd    $0x1,%rax\ncmp    %rcx,%rdx\njne    4a <func0+0x4a>\ntest   %ebp,%ebp\njle    318 <func0+0x318>\nmov    0x20(%rsp),%r13\nmov    %r13,%r14\nlea    0x4(%rbx),%r15\nlea    -0x1(%rbp),%eax\nmov    %rax,0x28(%rsp)\nlea    0x8(%r13,%rax,8),%rax\nmov    %rax,0x8(%rsp)\njmp    d4 <func0+0xd4>\nmov    -0x4(%rbp),%eax\nmov    %eax,0x14(%rsp)\ncltq\nlea    (%r12,%rax,4),%rdi\nmov    %rdi,0x18(%rsp)\npxor   %xmm0,%xmm0\ncvtsi2sdl (%rdi),%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sdl (%r12,%rsi,1),%xmm1\ncallq  b3 <func0+0xb3>\ncvttsd2si %xmm0,%eax\nmov    0x18(%rsp),%rdi\nmov    %eax,(%rdi)\nmov    0x14(%rsp),%eax\nmov    %eax,0x0(%rbp)\nadd    $0x8,%r13\nadd    $0x4,%r15\ncmp    0x8(%rsp),%r13\nje     143 <func0+0x143>\nmov    0x0(%r13),%rsi\nmov    $0x3,%ecx\nlea    0x0(%rip),%rdi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %al\nsbb    $0x0,%al\ntest   %al,%al\njne    c5 <func0+0xc5>\nmov    %r15,%rbp\nmov    -0x4(%r15),%edx\nmovslq %edx,%rax\nmov    (%rbx,%rax,4),%eax\ncmp    %eax,%edx\nje     10e <func0+0x10e>\nmov    %eax,-0x4(%rbp)\nmov    %eax,%edx\ncltq\nmov    (%rbx,%rax,4),%eax\ncmp    %edx,%eax\njne    100 <func0+0x100>\nmov    0x0(%rbp),%edx\nmovslq %edx,%rax\nlea    0x0(,%rax,4),%rsi\n00\nmov    (%rbx,%rax,4),%eax\ncmp    %eax,%edx\nje     8a <func0+0x8a>\nmov    %eax,0x0(%rbp)\nmovslq %eax,%rdx\nlea    0x0(,%rdx,4),%rsi\n00\nmov    %eax,%ecx\nmov    (%rbx,%rdx,4),%eax\ncmp    %ecx,%eax\njne    127 <func0+0x127>\njmpq   8a <func0+0x8a>\nmov    %rbx,%r9\nmov    0x28(%rsp),%rax\nlea    0x4(%rbx,%rax,4),%rbp\nmov    %rbx,%r10\nmov    0x20(%rsp),%r11\nlea    0x0(%rip),%r13\nlea    0x0(%rip),%r15\njmpq   1f8 <func0+0x1f8>\nmov    %r10,%r8\nmov    (%r10),%ecx\nmovslq %ecx,%rdx\nmov    (%rbx,%rdx,4),%edx\ncmp    %edx,%ecx\nje     18a <func0+0x18a>\nmov    %edx,(%r8)\nmov    %edx,%ecx\nmovslq %edx,%rdx\nmov    (%rbx,%rdx,4),%edx\ncmp    %ecx,%edx\njne    17b <func0+0x17b>\nmov    0x4(%r8),%esi\nmovslq %esi,%rcx\nlea    0x0(,%rcx,4),%rdi\n00\nmov    %rdi,%rdx\nmov    (%rbx,%rcx,4),%ecx\ncmp    %ecx,%esi\nje     1be <func0+0x1be>\nmov    %ecx,0x4(%r8)\nmovslq %ecx,%rsi\nlea    0x0(,%rsi,4),%rdi\n00\nmov    %rdi,%rdx\nmov    %ecx,%edi\nmov    (%rbx,%rsi,4),%ecx\ncmp    %edi,%ecx\njne    1a3 <func0+0x1a3>\nmov    $0x2,%ecx\nmov    %rax,%rsi\nmov    %r13,%rdi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %al\nsbb    $0x0,%al\ntest   %al,%al\njne    232 <func0+0x232>\nmovslq (%r8),%rax\nlea    (%r12,%rax,4),%rcx\nmov    (%rcx),%eax\nimul   (%r12,%rdx,1),%eax\nmov    %eax,(%rcx)\nmov    (%r8),%eax\nmov    %eax,0x4(%r8)\nadd    $0x8,%r11\nadd    $0x4,%r10\ncmp    %r10,%rbp\nje     247 <func0+0x247>\nmov    (%r11),%rax\nmov    $0x2,%ecx\nmov    %rax,%rsi\nmov    %r13,%rdi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %dl\nsbb    $0x0,%dl\ntest   %dl,%dl\nje     16b <func0+0x16b>\nmov    $0x3,%ecx\nmov    %rax,%rsi\nmov    %r15,%rdi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %dl\nsbb    $0x0,%dl\ntest   %dl,%dl\njne    1eb <func0+0x1eb>\njmpq   16b <func0+0x16b>\nmovslq (%r8),%rax\nlea    (%r12,%rax,4),%rcx\nmov    (%rcx),%eax\nmov    %rdx,%rdi\ncltd\nidivl  (%r12,%rdi,1)\nmov    %eax,(%rcx)\njmp    1e4 <func0+0x1e4>\nlea    0x0(%rip),%r10\nlea    0x0(%rip),%r11\njmp    2d3 <func0+0x2d3>\nmov    %r9,%rdx\nmov    (%r9),%ecx\nmovslq %ecx,%rax\nmov    (%rbx,%rax,4),%eax\ncmp    %eax,%ecx\nje     274 <func0+0x274>\nmov    %eax,(%rdx)\nmov    %eax,%ecx\ncltq\nmov    (%rbx,%rax,4),%eax\ncmp    %ecx,%eax\njne    267 <func0+0x267>\nmov    0x4(%rdx),%ecx\nmovslq %ecx,%rax\nlea    0x0(,%rax,4),%r13\n00\nmov    (%rbx,%rax,4),%eax\ncmp    %eax,%ecx\nje     2a0 <func0+0x2a0>\nmov    %eax,0x4(%rdx)\nmovslq %eax,%rcx\nlea    0x0(,%rcx,4),%r13\n00\nmov    %eax,%esi\nmov    (%rbx,%rcx,4),%eax\ncmp    %esi,%eax\njne    289 <func0+0x289>\nmov    $0x2,%ecx\nmov    %r8,%rsi\nmov    %r10,%rdi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %al\nsbb    $0x0,%al\ntest   %al,%al\njne    30b <func0+0x30b>\nmovslq (%rdx),%rax\nmov    (%r12,%r13,1),%ecx\nadd    %ecx,(%r12,%rax,4)\nmov    (%rdx),%eax\nmov    %eax,0x4(%rdx)\nadd    $0x8,%r14\nadd    $0x4,%r9\ncmp    %r9,%rbp\nje     318 <func0+0x318>\nmov    (%r14),%r8\nmov    $0x2,%ecx\nmov    %r8,%rsi\nmov    %r10,%rdi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %al\nsbb    $0x0,%al\ntest   %al,%al\nje     257 <func0+0x257>\nmov    $0x2,%ecx\nmov    %r8,%rsi\nmov    %r11,%rdi\nrepz cmpsb %es:(%rdi),%ds:(%rsi)\nseta   %al\nsbb    $0x0,%al\ntest   %al,%al\njne    2c6 <func0+0x2c6>\njmpq   257 <func0+0x257>\nmovslq (%rdx),%rax\nmov    (%r12,%r13,1),%ecx\nsub    %ecx,(%r12,%rax,4)\njmp    2c1 <func0+0x2c1>\nmov    (%r12),%ebp\nmov    %r12,%rdi\ncallq  324 <func0+0x324>\nmov    %rbx,%rdi\ncallq  32c <func0+0x32c>\nmov    %ebp,%eax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq"
    },
    {
        "task_id": 160,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\npush   %r12\npush   %rbp\nmovslq %ecx,%rbp\npush   %rbx\nmov    %rbp,%r13\nshl    $0x2,%rbp\nmov    %rsi,%rbx\nmov    %rbp,%rdi\nsub    $0x18,%rsp\nmov    %edx,0x8(%rsp)\ncallq  2e <func0+0x2e>\nmov    %rbp,%rdi\nmov    %rax,%r12\ncallq  39 <func0+0x39>\nmov    0x8(%rsp),%edx\nlea    -0x1(%r13),%esi\nmov    %rax,%rbp\nxor    %eax,%eax\ntest   %r13d,%r13d\njle    67 <func0+0x67>\nnopl   0x0(%rax,%rax,1)\nmov    (%rbx,%rax,4),%ecx\nmov    %eax,0x0(%rbp,%rax,4)\nmov    %ecx,(%r12,%rax,4)\nmov    %rax,%rcx\nadd    $0x1,%rax\ncmp    %rcx,%rsi\njne    50 <func0+0x50>\nlea    -0x1(%rdx),%r15d\nxor    %r13d,%r13d\ntest   %edx,%edx\njle    2bb <func0+0x2bb>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    (%r14,%r13,8),%rax\ncmpb   $0x2a,(%rax)\njne    135 <func0+0x135>\ncmpb   $0x2a,0x1(%rax)\njne    135 <func0+0x135>\ncmpb   $0x0,0x2(%rax)\njne    135 <func0+0x135>\nmovslq 0x0(%rbp,%r13,4),%rax\nmov    %rax,%rbx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%ebx\nje     ca <func0+0xca>\nnopl   0x0(%rax)\ncltq\nmov    %eax,0x0(%rbp,%r13,4)\nmov    %rax,%rbx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %ebx,%eax\njne    b8 <func0+0xb8>\nmovslq 0x4(%rbp,%r13,4),%rax\nmov    %rax,%rdx\nlea    0x0(,%rax,4),%rsi\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%edx\nje     102 <func0+0x102>\nnopw   0x0(%rax,%rax,1)\nmovslq %eax,%rdx\nmov    %eax,0x4(%rbp,%r13,4)\nmov    %eax,%ecx\nmov    0x0(%rbp,%rdx,4),%eax\nlea    0x0(,%rdx,4),%rsi\n00\ncmp    %ecx,%eax\njne    e8 <func0+0xe8>\nmovslq %ebx,%rax\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sdl (%r12,%rsi,1),%xmm1\nlea    (%r12,%rax,4),%rdx\ncvtsi2sdl (%rdx),%xmm0\nmov    %rdx,0x8(%rsp)\ncallq  125 <func0+0x125>\nmov    0x8(%rsp),%rdx\nmov    %ebx,0x4(%rbp,%r13,4)\ncvttsd2si %xmm0,%eax\nmov    %eax,(%rdx)\nlea    0x1(%r13),%rax\ncmp    %r13,%r15\nje     150 <func0+0x150>\nmov    %rax,%r13\njmpq   80 <func0+0x80>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmov    %r14,%r8\nmov    %rbp,%rdi\nlea    0x0(%rbp,%rax,4),%r9\nmov    %rbp,%rsi\nmov    %r14,%r11\nnopl   0x0(%rax)\nmov    (%r11),%r13\nmovzbl 0x0(%r13),%ebx\ncmp    $0x2a,%ebx\njne    300 <func0+0x300>\ncmpb   $0x0,0x1(%r13)\njne    300 <func0+0x300>\nmovslq (%rsi),%rax\nmov    %rax,%rcx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%ecx\nje     1a7 <func0+0x1a7>\nnopw   0x0(%rax,%rax,1)\ncltq\nmov    %eax,(%rsi)\nmov    %rax,%rcx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %ecx,%eax\njne    198 <func0+0x198>\nmovslq 0x4(%rsi),%rax\nmov    %rax,%rdx\nlea    0x0(,%rax,4),%r14\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %edx,%eax\nje     1da <func0+0x1da>\nxchg   %ax,%ax\nmovslq %eax,%rdx\nmov    %eax,0x4(%rsi)\nmov    %eax,%r10d\nmov    0x0(%rbp,%rdx,4),%eax\nlea    0x0(,%rdx,4),%r14\n00\ncmp    %r10d,%eax\njne    1c0 <func0+0x1c0>\nsub    $0x2a,%ebx\njne    1e4 <func0+0x1e4>\nmovzbl 0x1(%r13),%ebx\nmovslq %ecx,%rax\nmov    (%r12,%r14,1),%r13d\nlea    (%r12,%rax,4),%r10\nmov    (%r10),%eax\ntest   %ebx,%ebx\njne    330 <func0+0x330>\nimul   %r13d,%eax\nmov    %eax,(%r10)\nmov    %ecx,0x4(%rsi)\nadd    $0x4,%rsi\nadd    $0x8,%r11\ncmp    %rsi,%r9\njne    168 <func0+0x168>\nnopl   (%rax)\nmov    (%r8),%rax\nmovzbl (%rax),%r11d\ncmp    $0x2b,%r11d\njne    2e8 <func0+0x2e8>\ncmpb   $0x0,0x1(%rax)\njne    2e8 <func0+0x2e8>\nmovslq (%rdi),%rax\nmov    %rax,%rdx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %edx,%eax\nje     257 <func0+0x257>\nnopl   0x0(%rax)\ncltq\nmov    %eax,(%rdi)\nmov    %rax,%rdx\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %edx,%eax\njne    248 <func0+0x248>\nmovslq 0x4(%rdi),%rax\nmov    %rax,%rcx\nlea    0x0(,%rax,4),%r10\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%ecx\nje     288 <func0+0x288>\nxchg   %ax,%ax\nmovslq %eax,%rcx\nmov    %eax,0x4(%rdi)\nmov    %eax,%esi\nmov    0x0(%rbp,%rcx,4),%eax\nlea    0x0(,%rcx,4),%r10\n00\ncmp    %esi,%eax\njne    270 <func0+0x270>\nmovslq %edx,%rax\nmov    (%r12,%r10,1),%esi\nmov    %edx,0x4(%rdi)\nlea    (%r12,%rax,4),%rcx\nmov    (%rcx),%eax\nmov    %eax,%r10d\nadd    %esi,%eax\nsub    %esi,%r10d\ncmp    $0x2b,%r11d\ncmovne %r10d,%eax\nmov    %eax,(%rcx)\nadd    $0x4,%rdi\nadd    $0x8,%r8\ncmp    %rdi,%r9\njne    218 <func0+0x218>\nmov    %r12,%rdi\nmov    (%r12),%r13d\ncallq  2c7 <func0+0x2c7>\nmov    %rbp,%rdi\ncallq  2cf <func0+0x2cf>\nadd    $0x18,%rsp\nmov    %r13d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\ncmp    $0x2d,%r11d\njne    2aa <func0+0x2aa>\ncmpb   $0x0,0x1(%rax)\nje     233 <func0+0x233>\njmp    2aa <func0+0x2aa>\nnopw   0x0(%rax,%rax,1)\ncmpb   $0x2f,0x0(%r13)\njne    204 <func0+0x204>\ncmpb   $0x2f,0x1(%r13)\njne    204 <func0+0x204>\ncmpb   $0x0,0x2(%r13)\nje     184 <func0+0x184>\njmpq   204 <func0+0x204>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\ncltd\nidiv   %r13d\nmov    %eax,(%r10)\njmpq   201 <func0+0x201>"
    },
    {
        "task_id": 160,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\nmov    %rsi,%r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\nmov    %edx,%r13d\npush   %r12\npush   %rbp\nmovslq %ecx,%rbp\npush   %rbx\nmov    %rbp,%rbx\nshl    $0x2,%rbp\nmov    %rbp,%rdi\nsub    $0x18,%rsp\ncallq  2d <func0+0x2d>\nmov    %rbp,%rdi\nmov    %rax,%r12\ncallq  38 <func0+0x38>\nmov    %rax,%rbp\ntest   %ebx,%ebx\njle    d2 <func0+0xd2>\nlea    -0x1(%rbx),%eax\nmov    %r15,%rsi\nmov    %r12,%rdi\nlea    0x4(,%rax,4),%rdx\n00\nmov    %eax,0x8(%rsp)\ncallq  5d <func0+0x5d>\nmov    0x8(%rsp),%ecx\ncmp    $0x2,%ecx\njbe    3ec <func0+0x3ec>\nmov    %ebx,%edx\nmovdqa 0x0(%rip),%xmm0\n00\nmovdqa 0x0(%rip),%xmm2\n00\nmov    %rbp,%rax\nshr    $0x2,%edx\nshl    $0x4,%rdx\nadd    %rbp,%rdx\nnopl   0x0(%rax)\nmovdqa %xmm0,%xmm1\nadd    $0x10,%rax\npaddd  %xmm2,%xmm0\nmovups %xmm1,-0x10(%rax)\ncmp    %rax,%rdx\njne    90 <func0+0x90>\nmov    %ebx,%eax\nand    $0xfffffffc,%eax\ntest   $0x3,%bl\nje     d2 <func0+0xd2>\nmovslq %eax,%rdx\nmov    %eax,0x0(%rbp,%rdx,4)\nlea    0x1(%rax),%edx\ncmp    %edx,%ebx\njle    d2 <func0+0xd2>\nmovslq %edx,%rcx\nadd    $0x2,%eax\nmov    %edx,0x0(%rbp,%rcx,4)\ncmp    %eax,%ebx\njle    d2 <func0+0xd2>\nmovslq %eax,%rdx\nmov    %eax,0x0(%rbp,%rdx,4)\nlea    -0x1(%r13),%esi\nxor    %ebx,%ebx\ntest   %r13d,%r13d\njle    373 <func0+0x373>\nnopl   0x0(%rax)\nmov    (%r14,%rbx,8),%rax\ncmpb   $0x2a,(%rax)\njne    1b7 <func0+0x1b7>\ncmpb   $0x2a,0x1(%rax)\njne    1b7 <func0+0x1b7>\ncmpb   $0x0,0x2(%rax)\njne    1b7 <func0+0x1b7>\nmovslq 0x0(%rbp,%rbx,4),%rax\nmov    %rax,%r13\nlea    0x0(,%rax,4),%rcx\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%r13d\nje     143 <func0+0x143>\nnopw   0x0(%rax,%rax,1)\nmovslq %eax,%rdx\nmov    %eax,0x0(%rbp,%rbx,4)\nmov    %eax,%r13d\nmov    0x0(%rbp,%rdx,4),%eax\nlea    0x0(,%rdx,4),%rcx\n00\ncmp    %r13d,%eax\njne    128 <func0+0x128>\nmovslq 0x4(%rbp,%rbx,4),%rax\nmov    %rax,%rdx\nlea    0x0(,%rax,4),%rdi\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%edx\nje     185 <func0+0x185>\nnopl   0x0(%rax,%rax,1)\nmovslq %eax,%rdx\nmov    %eax,0x4(%rbp,%rbx,4)\nmov    %eax,%ecx\nmov    0x0(%rbp,%rdx,4),%eax\nlea    0x0(,%rdx,4),%rdi\n00\ncmp    %ecx,%eax\njne    160 <func0+0x160>\nmovslq 0x0(%rbp,%rbx,4),%rcx\nmov    %rcx,%r13\nshl    $0x2,%rcx\nlea    (%r12,%rcx,1),%r15\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\nmov    %rsi,0x8(%rsp)\ncvtsi2sdl (%r15),%xmm0\ncvtsi2sdl (%r12,%rdi,1),%xmm1\ncallq  1a6 <func0+0x1a6>\nmov    %r13d,0x4(%rbp,%rbx,4)\nmov    0x8(%rsp),%rsi\ncvttsd2si %xmm0,%eax\nmov    %eax,(%r15)\nlea    0x1(%rbx),%rax\ncmp    %rbx,%rsi\nje     1d0 <func0+0x1d0>\nmov    %rax,%rbx\njmpq   e8 <func0+0xe8>\nnopl   0x0(%rax,%rax,1)\n00\nmov    %r14,%rdi\nmov    %rbp,%rsi\nlea    0x0(%rbp,%rax,4),%r8\nmov    %rbp,%rcx\nmov    %r14,%r10\nnopl   0x0(%rax)\nmov    (%r10),%rbx\nmovzbl (%rbx),%r11d\ncmp    $0x2a,%r11d\njne    3b8 <func0+0x3b8>\ncmpb   $0x0,0x1(%rbx)\njne    3b8 <func0+0x3b8>\nmovslq (%rcx),%rax\nmov    %rax,%r9\nlea    0x0(,%rax,4),%r13\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%r9d\nje     239 <func0+0x239>\nnopw   0x0(%rax,%rax,1)\nmovslq %eax,%rdx\nmov    %eax,(%rcx)\nmov    %eax,%r9d\nmov    0x0(%rbp,%rdx,4),%eax\nlea    0x0(,%rdx,4),%r13\n00\ncmp    %r9d,%eax\njne    220 <func0+0x220>\nmovslq 0x4(%rcx),%rax\nmov    %rax,%rdx\nlea    0x0(,%rax,4),%r14\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %edx,%eax\nje     274 <func0+0x274>\nmovslq %eax,%rdx\nmov    %eax,0x4(%rcx)\nmov    %eax,%r9d\nmov    0x0(%rbp,%rdx,4),%eax\nlea    0x0(,%rdx,4),%r14\n00\ncmp    %r9d,%eax\njne    250 <func0+0x250>\nmovslq (%rcx),%r13\nmov    %r13,%r9\nshl    $0x2,%r13\nsub    $0x2a,%r11d\njne    27f <func0+0x27f>\nmovzbl 0x1(%rbx),%r11d\nadd    %r12,%r13\nmov    (%r12,%r14,1),%ebx\nmov    0x0(%r13),%eax\ntest   %r11d,%r11d\njne    3e0 <func0+0x3e0>\nimul   %ebx,%eax\nmov    %eax,0x0(%r13)\nmov    %r9d,0x4(%rcx)\nadd    $0x4,%rcx\nadd    $0x8,%r10\ncmp    %rcx,%r8\njne    1e8 <func0+0x1e8>\nnop\nmov    (%rdi),%rax\nmovzbl (%rax),%r10d\ncmp    $0x2b,%r10d\njne    3a0 <func0+0x3a0>\ncmpb   $0x0,0x1(%rax)\njne    3a0 <func0+0x3a0>\nmovslq (%rsi),%rax\nmov    %rax,%rcx\nlea    0x0(,%rax,4),%r9\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %ecx,%eax\nje     2ff <func0+0x2ff>\nnopl   0x0(%rax)\nmovslq %eax,%rdx\nmov    %eax,(%rsi)\nmov    %eax,%ecx\nmov    0x0(%rbp,%rdx,4),%eax\nlea    0x0(,%rdx,4),%r9\n00\ncmp    %ecx,%eax\njne    2e8 <func0+0x2e8>\nmovslq 0x4(%rsi),%rax\nmov    %rax,%rdx\nlea    0x0(,%rax,4),%r11\n00\nmov    0x0(%rbp,%rax,4),%eax\ncmp    %eax,%edx\nje     342 <func0+0x342>\nnopw   %cs:0x0(%rax,%rax,1)\n00 00 00\nmovslq %eax,%rdx\nmov    %eax,0x4(%rsi)\nmov    %eax,%ecx\nmov    0x0(%rbp,%rdx,4),%eax\nlea    0x0(,%rdx,4),%r11\n00\ncmp    %ecx,%eax\njne    320 <func0+0x320>\nmovslq (%rsi),%r9\nmov    %r9,%rcx\nshl    $0x2,%r9\nadd    %r12,%r9\nmov    (%r12,%r11,1),%edx\nmov    %ecx,0x4(%rsi)\nmov    (%r9),%eax\nmov    %eax,%r11d\nadd    %edx,%eax\nsub    %edx,%r11d\ncmp    $0x2b,%r10d\ncmovne %r11d,%eax\nmov    %eax,(%r9)\nadd    $0x4,%rsi\nadd    $0x8,%rdi\ncmp    %rsi,%r8\njne    2b0 <func0+0x2b0>\nmov    %r12,%rdi\nmov    (%r12),%r13d\ncallq  37f <func0+0x37f>\nmov    %rbp,%rdi\ncallq  387 <func0+0x387>\nadd    $0x18,%rsp\nmov    %r13d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax)\ncmp    $0x2d,%r10d\njne    362 <func0+0x362>\ncmpb   $0x0,0x1(%rax)\nje     2cb <func0+0x2cb>\njmp    362 <func0+0x362>\nnopw   0x0(%rax,%rax,1)\ncmpb   $0x2f,(%rbx)\njne    29e <func0+0x29e>\ncmpb   $0x2f,0x1(%rbx)\njne    29e <func0+0x29e>\ncmpb   $0x0,0x2(%rbx)\nje     203 <func0+0x203>\njmpq   29e <func0+0x29e>\nnopw   0x0(%rax,%rax,1)\ncltd\nidiv   %ebx\nmov    %eax,0x0(%r13)\njmpq   29a <func0+0x29a>\nxor    %eax,%eax\njmpq   af <func0+0xaf>"
    },
    {
        "task_id": 161,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncallq  23 <func0+0x23>\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmpq   12c <func0+0x12c>\ncallq  37 <func0+0x37>\nmov    (%rax),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovzbl %dl,%edx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x400,%eax\ntest   %eax,%eax\nje     124 <func0+0x124>\ncallq  6b <func0+0x6b>\nmov    (%rax),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovzbl %dl,%edx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x100,%eax\ntest   %eax,%eax\nje     c5 <func0+0xc5>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncallq  b0 <func0+0xb0>\nmov    %eax,%ecx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\njmp    128 <func0+0x128>\ncallq  ca <func0+0xca>\nmov    (%rax),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rdx),%edx\nmovzbl %dl,%edx\nadd    %rdx,%rdx\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x200,%eax\ntest   %eax,%eax\nje     128 <func0+0x128>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%edi\ncallq  10f <func0+0x10f>\nmov    %eax,%ecx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\njmp    128 <func0+0x128>\naddl   $0x1,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     32 <func0+0x32>\nmov    -0x10(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njne    1af <func0+0x1af>\nmovl   $0x0,-0x8(%rbp)\njmp    19e <func0+0x19e>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x11(%rbp)\nmov    -0x4(%rbp),%eax\nsub    -0x8(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\nmov    -0x4(%rbp),%eax\nsub    -0x8(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x11(%rbp),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\ncmp    %eax,-0x8(%rbp)\njl     149 <func0+0x149>\nmov    -0x28(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 161,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%r12\nmov    $0xffffffffffffffff,%rcx\nmov    $0x0,%eax\nrepnz scas %es:(%rdi),%al\nnot    %rcx\nlea    -0x1(%rcx),%r14\nmov    %r14,0x8(%rsp)\ntest   %r14d,%r14d\njle    a1 <func0+0xa1>\ncallq  39 <func0+0x39>\nmov    %rax,%r13\nmov    %r12,%rbx\nlea    -0x1(%r14),%eax\nlea    0x1(%r12,%rax,1),%r15\nmov    $0x0,%r14d\njmp    75 <func0+0x75>\ntest   $0x2,%ah\nje     6c <func0+0x6c>\ncallq  5a <func0+0x5a>\nmov    (%rax),%rax\nmov    (%rax,%rbp,4),%eax\nmov    (%rsp),%rdx\nmov    %al,(%rdx)\njmp    6c <func0+0x6c>\nadd    $0x1,%r14d\nadd    $0x1,%rbx\ncmp    %r15,%rbx\nje     a7 <func0+0xa7>\nmov    %rbx,(%rsp)\nmovzbl (%rbx),%ebp\nmov    0x0(%r13),%rax\nmovzwl (%rax,%rbp,2),%eax\ntest   $0x4,%ah\nje     68 <func0+0x68>\ntest   $0x1,%ah\nje     50 <func0+0x50>\ncallq  93 <func0+0x93>\nmov    (%rax),%rax\nmov    (%rax,%rbp,4),%eax\nmov    (%rsp),%rsi\nmov    %al,(%rsi)\njmp    6c <func0+0x6c>\nmov    $0x0,%r14d\ncmp    %r14d,0x8(%rsp)\nje     c0 <func0+0xc0>\nmov    %r12,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nmov    0x8(%rsp),%rax\nmov    %eax,%edi\nshr    $0x1f,%edi\nadd    %eax,%edi\nsar    %edi\ncmp    $0x1,%eax\njle    ae <func0+0xae>\ncltq\nlea    -0x1(%r12,%rax,1),%rdx\nmov    $0x0,%eax\nmovzbl (%r12,%rax,1),%ecx\nmovzbl (%rdx),%esi\nmov    %sil,(%r12,%rax,1)\nmov    %cl,(%rdx)\nadd    $0x1,%rax\nsub    $0x1,%rdx\ncmp    %eax,%edi\njg     df <func0+0xdf>\njmp    ae <func0+0xae>"
    },
    {
        "task_id": 161,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncallq  1a <func0+0x1a>\nmov    %rax,0x8(%rsp)\ntest   %eax,%eax\njle    100 <func0+0x100>\nmov    %rax,%r15\nmov    %r12,%rbx\ncallq  32 <func0+0x32>\nmov    %rax,%r14\nlea    -0x1(%r15),%eax\nxor    %r15d,%r15d\nlea    0x1(%r12,%rax,1),%r13\njmp    63 <func0+0x63>\nnopl   0x0(%rax,%rax,1)\ntest   $0x1,%ah\nje     a0 <func0+0xa0>\ncallq  52 <func0+0x52>\nmov    (%rax),%rax\nmov    (%rax,%rbp,4),%eax\nmov    %al,(%rbx)\nadd    $0x1,%rbx\ncmp    %r13,%rbx\nje     7f <func0+0x7f>\nmovzbl (%rbx),%ebp\nmov    (%r14),%rax\nmovzwl (%rax,%rbp,2),%eax\ntest   $0x4,%ah\njne    48 <func0+0x48>\nadd    $0x1,%rbx\nadd    $0x1,%r15d\ncmp    %r13,%rbx\njne    63 <func0+0x63>\ncmp    %r15d,0x8(%rsp)\nje     b8 <func0+0xb8>\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax,%rax,1)\n00\ntest   $0x2,%ah\nje     5a <func0+0x5a>\ncallq  aa <func0+0xaa>\nmov    (%rax),%rax\nmov    (%rax,%rbp,4),%eax\nmov    %al,(%rbx)\njmp    5a <func0+0x5a>\nnopl   0x0(%rax)\nmov    0x8(%rsp),%rax\nmov    %eax,%ecx\nsar    %ecx\nje     86 <func0+0x86>\nmovslq %eax,%r13\nsub    $0x1,%ecx\nmov    %r12,%rdx\nlea    -0x2(%r12,%r13,1),%rdi\nlea    -0x1(%r12,%r13,1),%rax\nsub    %rcx,%rdi\nnopl   0x0(%rax)\nmovzbl (%rdx),%ecx\nmovzbl (%rax),%esi\nsub    $0x1,%rax\nadd    $0x1,%rdx\nmov    %sil,-0x1(%rdx)\nmov    %cl,0x1(%rax)\ncmp    %rax,%rdi\njne    e0 <func0+0xe0>\njmp    86 <func0+0x86>\nnopl   0x0(%rax)\nxor    %r15d,%r15d\njmpq   7f <func0+0x7f>"
    },
    {
        "task_id": 161,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncallq  1a <func0+0x1a>\nmov    %rax,0x8(%rsp)\ntest   %eax,%eax\njle    100 <func0+0x100>\nmov    %rax,%r15\nmov    %r12,%rbx\ncallq  32 <func0+0x32>\nmov    %rax,%r14\nlea    -0x1(%r15),%eax\nxor    %r15d,%r15d\nlea    0x1(%r12,%rax,1),%r13\njmp    63 <func0+0x63>\nnopl   0x0(%rax,%rax,1)\ntest   $0x1,%ah\nje     a0 <func0+0xa0>\ncallq  52 <func0+0x52>\nmov    (%rax),%rax\nmov    (%rax,%rbp,4),%eax\nmov    %al,(%rbx)\nadd    $0x1,%rbx\ncmp    %rbx,%r13\nje     7f <func0+0x7f>\nmovzbl (%rbx),%ebp\nmov    (%r14),%rax\nmovzwl (%rax,%rbp,2),%eax\ntest   $0x4,%ah\njne    48 <func0+0x48>\nadd    $0x1,%rbx\nadd    $0x1,%r15d\ncmp    %rbx,%r13\njne    63 <func0+0x63>\ncmp    %r15d,0x8(%rsp)\nje     b8 <func0+0xb8>\nadd    $0x18,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nretq\nnopl   0x0(%rax,%rax,1)\n00\ntest   $0x2,%ah\nje     5a <func0+0x5a>\ncallq  aa <func0+0xaa>\nmov    (%rax),%rax\nmov    (%rax,%rbp,4),%eax\nmov    %al,(%rbx)\njmp    5a <func0+0x5a>\nnopl   0x0(%rax)\nmov    0x8(%rsp),%rax\nmov    %eax,%ecx\nsar    %ecx\nje     86 <func0+0x86>\nmovslq %eax,%r13\nsub    $0x1,%ecx\nmov    %r12,%rdx\nlea    -0x2(%r12,%r13,1),%rdi\nlea    -0x1(%r12,%r13,1),%rax\nsub    %rcx,%rdi\nnopl   0x0(%rax)\nmovzbl (%rdx),%ecx\nmovzbl (%rax),%esi\nsub    $0x1,%rax\nadd    $0x1,%rdx\nmov    %sil,-0x1(%rdx)\nmov    %cl,0x1(%rax)\ncmp    %rax,%rdi\njne    e0 <func0+0xe0>\njmp    86 <func0+0x86>\nnopl   0x0(%rax)\nxor    %r15d,%r15d\njmpq   7f <func0+0x7f>"
    },
    {
        "task_id": 162,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    2c <func0+0x2c>\nlea    0x0(%rip),%rdi\ncallq  27 <func0+0x27>\njmpq   ce <func0+0xce>\nmovl   $0xffffffff,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    86 <func0+0x86>\nmov    -0x10(%rbp),%edx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x15(%rbp)\nmovzbl -0x15(%rbp),%eax\nxor    %eax,-0x14(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    7c <func0+0x7c>\nmov    -0x14(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     75 <func0+0x75>\nmov    -0x14(%rbp),%eax\nshr    %eax\nxor    $0xedb88320,%eax\nmov    %eax,-0x14(%rbp)\njmp    78 <func0+0x78>\nshrl   -0x14(%rbp)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njbe    5c <func0+0x5c>\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%edx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    3c <func0+0x3c>\nnotl   -0x14(%rbp)\nmov    $0x9,%edi\ncallq  a4 <func0+0xa4>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     ca <func0+0xca>\nmov    -0x14(%rbp),%edx\nmov    -0x8(%rbp),%rax\nlea    0x0(%rip),%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncallq  ca <func0+0xca>\nmov    -0x8(%rbp),%rax\nleaveq\nretq"
    },
    {
        "task_id": 162,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovzbl (%rdi),%eax\nmov    $0x0,%esi\nmov    $0xffffffff,%r8d\ntest   %al,%al\njne    3a <func0+0x3a>\nlea    0x0(%rip),%rdi\ncallq  28 <func0+0x28>\nmov    %rax,%rbp\njmp    9d <func0+0x9d>\nadd    $0x1,%esi\nmov    %esi,%eax\nmovzbl (%rdi,%rax,1),%eax\ntest   %al,%al\nje     65 <func0+0x65>\nmovzbl %al,%eax\nxor    %eax,%r8d\nmov    $0x8,%edx\nmov    %r8d,%eax\nshr    %eax\nxor    $0xedb88320,%eax\nmov    %r8d,%ecx\nshr    %ecx\ntest   $0x1,%r8b\ncmove  %ecx,%eax\nmov    %eax,%r8d\nsub    $0x1,%edx\njne    45 <func0+0x45>\njmp    2d <func0+0x2d>\nmov    %r8d,%ebx\nnot    %ebx\nmov    $0x9,%edi\ncallq  74 <func0+0x74>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     9d <func0+0x9d>\nmov    %ebx,%r8d\nlea    0x0(%rip),%rcx\nmov    $0x9,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncallq  9d <func0+0x9d>\nmov    %rbp,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nretq"
    },
    {
        "task_id": 162,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     9b <func0+0x9b>\npush   %r12\nxor    %esi,%esi\nmov    $0xffffffff,%r8d\npush   %rbx\nsub    $0x8,%rsp\nxchg   %ax,%ax\nxor    %eax,%r8d\nmov    $0x8,%eax\nnopl   0x0(%rax,%rax,1)\n00\nmov    %r8d,%ecx\nshr    %r8d\nmov    %r8d,%edx\nand    $0x1,%ecx\nxor    $0xedb88320,%edx\ntest   %ecx,%ecx\ncmovne %edx,%r8d\nsub    $0x1,%eax\njne    30 <func0+0x30>\nlea    0x1(%rsi),%eax\nmov    %rax,%rsi\nmovzbl (%rdi,%rax,1),%eax\ntest   %al,%al\njne    20 <func0+0x20>\nmov    $0x9,%edi\nmov    %r8d,%ebx\ncallq  68 <func0+0x68>\nnot    %ebx\nmov    %rax,%r12\ntest   %rax,%rax\nje     90 <func0+0x90>\nmov    %rax,%rdi\nmov    %ebx,%r8d\nlea    0x0(%rip),%rcx\nxor    %eax,%eax\nmov    $0x9,%edx\nmov    $0x1,%esi\ncallq  90 <func0+0x90>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %r12\nretq\nlea    0x0(%rip),%rdi\njmpq   a7 <.LC1+0xa2>"
    },
    {
        "task_id": 162,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     107 <func0+0x107>\npush   %r12\nxor    %ecx,%ecx\nmov    $0xffffffff,%r8d\npush   %rbx\nsub    $0x8,%rsp\nxchg   %ax,%ax\nmovzbl %al,%eax\nxor    %r8d,%eax\nmov    %eax,%edx\nshr    %edx\nmov    %edx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%al\ncmovne %esi,%edx\nmov    %edx,%eax\nshr    %eax\nmov    %eax,%esi\nxor    $0xedb88320,%esi\nand    $0x1,%edx\ncmovne %esi,%eax\nmov    %eax,%edx\nshr    %edx\nmov    %edx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%al\ncmovne %esi,%edx\nmov    %edx,%eax\nshr    %eax\nmov    %eax,%esi\nxor    $0xedb88320,%esi\nand    $0x1,%edx\ncmovne %esi,%eax\nmov    %eax,%edx\nshr    %edx\nmov    %edx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%al\ncmovne %esi,%edx\nmov    %edx,%eax\nshr    %eax\nmov    %eax,%esi\nxor    $0xedb88320,%esi\nand    $0x1,%edx\ncmovne %esi,%eax\nmov    %eax,%edx\nshr    %edx\nmov    %edx,%esi\nxor    $0xedb88320,%esi\ntest   $0x1,%al\ncmovne %esi,%edx\nmov    %edx,%r8d\nshr    %r8d\nmov    %r8d,%eax\nxor    $0xedb88320,%eax\nand    $0x1,%edx\ncmovne %eax,%r8d\nlea    0x1(%rcx),%eax\nmov    %rax,%rcx\nmovzbl (%rdi,%rax,1),%eax\ntest   %al,%al\njne    20 <func0+0x20>\nmov    $0x9,%edi\nmov    %r8d,%ebx\ncallq  d4 <func0+0xd4>\nnot    %ebx\nmov    %rax,%r12\ntest   %rax,%rax\nje     fc <func0+0xfc>\nmov    %rax,%rdi\nmov    %ebx,%r8d\nlea    0x0(%rip),%rcx\nxor    %eax,%eax\nmov    $0x9,%edx\nmov    $0x1,%esi\ncallq  fc <func0+0xfc>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %r12\nretq\nlea    0x0(%rip),%rdi\njmpq   113 <.LC1+0x10e>"
    },
    {
        "task_id": 163,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %rdx,-0x20(%rbp)\nmov    %rcx,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    3a <func0+0x3a>\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x8(%rbp)\njmp    7b <func0+0x7b>\ncmpl   $0x9,-0x8(%rbp)\njg     77 <func0+0x77>\nmov    -0x8(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    77 <func0+0x77>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%ecx\nmov    -0x28(%rbp),%rdx\nmov    %ecx,(%rdx)\ncltq\nlea    0x0(,%rax,4),%rdx\n00\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njle    42 <func0+0x42>\nnop\nnop\npop    %rbp\nretq"
    },
    {
        "task_id": 163,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovl   $0x0,(%rcx)\ncmp    %edi,%esi\njge    1d <func0+0x1d>\nmov    %edi,%eax\nmov    %esi,%edi\nmov    %eax,%esi\njmp    1d <func0+0x1d>\nadd    $0x1,%edi\ncmp    %edi,%esi\njl     38 <func0+0x38>\ncmp    $0x9,%edi\njg     16 <func0+0x16>\ntest   $0x1,%dil\njne    16 <func0+0x16>\nmov    (%rcx),%eax\nlea    0x1(%rax),%r8d\nmov    %r8d,(%rcx)\ncltq\nmov    %edi,(%rdx,%rax,4)\njmp    16 <func0+0x16>\nretq"
    },
    {
        "task_id": 163,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovl   $0x0,(%rcx)\ncmp    %edi,%esi\njge    18 <func0+0x18>\nmov    %edi,%eax\nmov    %esi,%edi\nmov    %eax,%esi\nnopl   0x0(%rax)\ncmp    $0x9,%edi\njg     30 <func0+0x30>\ntest   $0x1,%dil\njne    30 <func0+0x30>\nmovslq (%rcx),%rax\nlea    0x1(%rax),%r8d\nmov    %r8d,(%rcx)\nmov    %edi,(%rdx,%rax,4)\nadd    $0x1,%edi\ncmp    %edi,%esi\njge    18 <func0+0x18>\nretq"
    },
    {
        "task_id": 163,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "input_asm_prompt": "<func0>:\nendbr64\nmovl   $0x0,(%rcx)\ncmp    %edi,%esi\njge    14 <func0+0x14>\nmov    %edi,%eax\nmov    %esi,%edi\nmov    %eax,%esi\ncmp    $0x9,%edi\njg     48 <func0+0x48>\ncmp    $0x9,%esi\nmov    $0x9,%eax\ncmovg  %eax,%esi\nnopl   0x0(%rax)\ntest   $0x1,%dil\njne    3b <func0+0x3b>\nmovslq (%rcx),%rax\nlea    0x1(%rax),%r8d\nmov    %r8d,(%rcx)\nmov    %edi,(%rdx,%rax,4)\nadd    $0x1,%edi\ncmp    %esi,%edi\njle    28 <func0+0x28>\nretq\nnopl   0x0(%rax,%rax,1)\nretq"
    }
]